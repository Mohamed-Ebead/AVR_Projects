
RTOS_1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002f28  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000022  00800060  00002f28  00002fbc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000008a  00800082  00800082  00002fde  2**0
                  ALLOC
  3 .stab         00004980  00000000  00000000  00002fe0  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00002b9e  00000000  00000000  00007960  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 5e 07 	jmp	0xebc	; 0xebc <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e8 e2       	ldi	r30, 0x28	; 40
      68:	ff e2       	ldi	r31, 0x2F	; 47
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a2 38       	cpi	r26, 0x82	; 130
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	11 e0       	ldi	r17, 0x01	; 1
      78:	a2 e8       	ldi	r26, 0x82	; 130
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	ac 30       	cpi	r26, 0x0C	; 12
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 e3 15 	call	0x2bc6	; 0x2bc6 <main>
      8a:	0c 94 92 17 	jmp	0x2f24	; 0x2f24 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <xCoRoutineCreate>:
      92:	df 93       	push	r29
      94:	cf 93       	push	r28
      96:	cd b7       	in	r28, 0x3d	; 61
      98:	de b7       	in	r29, 0x3e	; 62
      9a:	27 97       	sbiw	r28, 0x07	; 7
      9c:	0f b6       	in	r0, 0x3f	; 63
      9e:	f8 94       	cli
      a0:	de bf       	out	0x3e, r29	; 62
      a2:	0f be       	out	0x3f, r0	; 63
      a4:	cd bf       	out	0x3d, r28	; 61
      a6:	9d 83       	std	Y+5, r25	; 0x05
      a8:	8c 83       	std	Y+4, r24	; 0x04
      aa:	6e 83       	std	Y+6, r22	; 0x06
      ac:	4f 83       	std	Y+7, r20	; 0x07
      ae:	8a e1       	ldi	r24, 0x1A	; 26
      b0:	90 e0       	ldi	r25, 0x00	; 0
      b2:	0e 94 21 03 	call	0x642	; 0x642 <pvPortMalloc>
      b6:	9a 83       	std	Y+2, r25	; 0x02
      b8:	89 83       	std	Y+1, r24	; 0x01
      ba:	89 81       	ldd	r24, Y+1	; 0x01
      bc:	9a 81       	ldd	r25, Y+2	; 0x02
      be:	00 97       	sbiw	r24, 0x00	; 0
      c0:	09 f4       	brne	.+2      	; 0xc4 <xCoRoutineCreate+0x32>
      c2:	6f c0       	rjmp	.+222    	; 0x1a2 <xCoRoutineCreate+0x110>
      c4:	80 91 82 00 	lds	r24, 0x0082
      c8:	90 91 83 00 	lds	r25, 0x0083
      cc:	00 97       	sbiw	r24, 0x00	; 0
      ce:	41 f4       	brne	.+16     	; 0xe0 <xCoRoutineCreate+0x4e>
      d0:	89 81       	ldd	r24, Y+1	; 0x01
      d2:	9a 81       	ldd	r25, Y+2	; 0x02
      d4:	90 93 83 00 	sts	0x0083, r25
      d8:	80 93 82 00 	sts	0x0082, r24
      dc:	0e 94 b0 02 	call	0x560	; 0x560 <prvInitialiseCoRoutineLists>
      e0:	8e 81       	ldd	r24, Y+6	; 0x06
      e2:	82 30       	cpi	r24, 0x02	; 2
      e4:	10 f0       	brcs	.+4      	; 0xea <xCoRoutineCreate+0x58>
      e6:	81 e0       	ldi	r24, 0x01	; 1
      e8:	8e 83       	std	Y+6, r24	; 0x06
      ea:	e9 81       	ldd	r30, Y+1	; 0x01
      ec:	fa 81       	ldd	r31, Y+2	; 0x02
      ee:	11 8e       	std	Z+25, r1	; 0x19
      f0:	10 8e       	std	Z+24, r1	; 0x18
      f2:	e9 81       	ldd	r30, Y+1	; 0x01
      f4:	fa 81       	ldd	r31, Y+2	; 0x02
      f6:	8e 81       	ldd	r24, Y+6	; 0x06
      f8:	86 8b       	std	Z+22, r24	; 0x16
      fa:	e9 81       	ldd	r30, Y+1	; 0x01
      fc:	fa 81       	ldd	r31, Y+2	; 0x02
      fe:	8f 81       	ldd	r24, Y+7	; 0x07
     100:	87 8b       	std	Z+23, r24	; 0x17
     102:	e9 81       	ldd	r30, Y+1	; 0x01
     104:	fa 81       	ldd	r31, Y+2	; 0x02
     106:	8c 81       	ldd	r24, Y+4	; 0x04
     108:	9d 81       	ldd	r25, Y+5	; 0x05
     10a:	91 83       	std	Z+1, r25	; 0x01
     10c:	80 83       	st	Z, r24
     10e:	89 81       	ldd	r24, Y+1	; 0x01
     110:	9a 81       	ldd	r25, Y+2	; 0x02
     112:	02 96       	adiw	r24, 0x02	; 2
     114:	0e 94 7e 03 	call	0x6fc	; 0x6fc <vListInitialiseItem>
     118:	89 81       	ldd	r24, Y+1	; 0x01
     11a:	9a 81       	ldd	r25, Y+2	; 0x02
     11c:	0c 96       	adiw	r24, 0x0c	; 12
     11e:	0e 94 7e 03 	call	0x6fc	; 0x6fc <vListInitialiseItem>
     122:	e9 81       	ldd	r30, Y+1	; 0x01
     124:	fa 81       	ldd	r31, Y+2	; 0x02
     126:	89 81       	ldd	r24, Y+1	; 0x01
     128:	9a 81       	ldd	r25, Y+2	; 0x02
     12a:	91 87       	std	Z+9, r25	; 0x09
     12c:	80 87       	std	Z+8, r24	; 0x08
     12e:	e9 81       	ldd	r30, Y+1	; 0x01
     130:	fa 81       	ldd	r31, Y+2	; 0x02
     132:	89 81       	ldd	r24, Y+1	; 0x01
     134:	9a 81       	ldd	r25, Y+2	; 0x02
     136:	93 8b       	std	Z+19, r25	; 0x13
     138:	82 8b       	std	Z+18, r24	; 0x12
     13a:	8e 81       	ldd	r24, Y+6	; 0x06
     13c:	28 2f       	mov	r18, r24
     13e:	30 e0       	ldi	r19, 0x00	; 0
     140:	82 e0       	ldi	r24, 0x02	; 2
     142:	90 e0       	ldi	r25, 0x00	; 0
     144:	82 1b       	sub	r24, r18
     146:	93 0b       	sbc	r25, r19
     148:	e9 81       	ldd	r30, Y+1	; 0x01
     14a:	fa 81       	ldd	r31, Y+2	; 0x02
     14c:	95 87       	std	Z+13, r25	; 0x0d
     14e:	84 87       	std	Z+12, r24	; 0x0c
     150:	e9 81       	ldd	r30, Y+1	; 0x01
     152:	fa 81       	ldd	r31, Y+2	; 0x02
     154:	96 89       	ldd	r25, Z+22	; 0x16
     156:	80 91 84 00 	lds	r24, 0x0084
     15a:	89 17       	cp	r24, r25
     15c:	28 f4       	brcc	.+10     	; 0x168 <xCoRoutineCreate+0xd6>
     15e:	e9 81       	ldd	r30, Y+1	; 0x01
     160:	fa 81       	ldd	r31, Y+2	; 0x02
     162:	86 89       	ldd	r24, Z+22	; 0x16
     164:	80 93 84 00 	sts	0x0084, r24
     168:	e9 81       	ldd	r30, Y+1	; 0x01
     16a:	fa 81       	ldd	r31, Y+2	; 0x02
     16c:	86 89       	ldd	r24, Z+22	; 0x16
     16e:	28 2f       	mov	r18, r24
     170:	30 e0       	ldi	r19, 0x00	; 0
     172:	c9 01       	movw	r24, r18
     174:	88 0f       	add	r24, r24
     176:	99 1f       	adc	r25, r25
     178:	88 0f       	add	r24, r24
     17a:	99 1f       	adc	r25, r25
     17c:	88 0f       	add	r24, r24
     17e:	99 1f       	adc	r25, r25
     180:	82 0f       	add	r24, r18
     182:	93 1f       	adc	r25, r19
     184:	ac 01       	movw	r20, r24
     186:	45 57       	subi	r20, 0x75	; 117
     188:	5f 4f       	sbci	r21, 0xFF	; 255
     18a:	89 81       	ldd	r24, Y+1	; 0x01
     18c:	9a 81       	ldd	r25, Y+2	; 0x02
     18e:	9c 01       	movw	r18, r24
     190:	2e 5f       	subi	r18, 0xFE	; 254
     192:	3f 4f       	sbci	r19, 0xFF	; 255
     194:	ca 01       	movw	r24, r20
     196:	b9 01       	movw	r22, r18
     198:	0e 94 8e 03 	call	0x71c	; 0x71c <vListInsertEnd>
     19c:	81 e0       	ldi	r24, 0x01	; 1
     19e:	8b 83       	std	Y+3, r24	; 0x03
     1a0:	02 c0       	rjmp	.+4      	; 0x1a6 <xCoRoutineCreate+0x114>
     1a2:	8f ef       	ldi	r24, 0xFF	; 255
     1a4:	8b 83       	std	Y+3, r24	; 0x03
     1a6:	8b 81       	ldd	r24, Y+3	; 0x03
     1a8:	27 96       	adiw	r28, 0x07	; 7
     1aa:	0f b6       	in	r0, 0x3f	; 63
     1ac:	f8 94       	cli
     1ae:	de bf       	out	0x3e, r29	; 62
     1b0:	0f be       	out	0x3f, r0	; 63
     1b2:	cd bf       	out	0x3d, r28	; 61
     1b4:	cf 91       	pop	r28
     1b6:	df 91       	pop	r29
     1b8:	08 95       	ret

000001ba <vCoRoutineAddToDelayedList>:
	return xReturn;	
}
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
     1ba:	df 93       	push	r29
     1bc:	cf 93       	push	r28
     1be:	00 d0       	rcall	.+0      	; 0x1c0 <vCoRoutineAddToDelayedList+0x6>
     1c0:	00 d0       	rcall	.+0      	; 0x1c2 <vCoRoutineAddToDelayedList+0x8>
     1c2:	00 d0       	rcall	.+0      	; 0x1c4 <vCoRoutineAddToDelayedList+0xa>
     1c4:	cd b7       	in	r28, 0x3d	; 61
     1c6:	de b7       	in	r29, 0x3e	; 62
     1c8:	9c 83       	std	Y+4, r25	; 0x04
     1ca:	8b 83       	std	Y+3, r24	; 0x03
     1cc:	7e 83       	std	Y+6, r23	; 0x06
     1ce:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     1d0:	20 91 85 00 	lds	r18, 0x0085
     1d4:	30 91 86 00 	lds	r19, 0x0086
     1d8:	8b 81       	ldd	r24, Y+3	; 0x03
     1da:	9c 81       	ldd	r25, Y+4	; 0x04
     1dc:	82 0f       	add	r24, r18
     1de:	93 1f       	adc	r25, r19
     1e0:	9a 83       	std	Y+2, r25	; 0x02
     1e2:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     1e4:	80 91 82 00 	lds	r24, 0x0082
     1e8:	90 91 83 00 	lds	r25, 0x0083
     1ec:	02 96       	adiw	r24, 0x02	; 2
     1ee:	0e 94 46 04 	call	0x88c	; 0x88c <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     1f2:	e0 91 82 00 	lds	r30, 0x0082
     1f6:	f0 91 83 00 	lds	r31, 0x0083
     1fa:	89 81       	ldd	r24, Y+1	; 0x01
     1fc:	9a 81       	ldd	r25, Y+2	; 0x02
     1fe:	93 83       	std	Z+3, r25	; 0x03
     200:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
     202:	20 91 85 00 	lds	r18, 0x0085
     206:	30 91 86 00 	lds	r19, 0x0086
     20a:	89 81       	ldd	r24, Y+1	; 0x01
     20c:	9a 81       	ldd	r25, Y+2	; 0x02
     20e:	82 17       	cp	r24, r18
     210:	93 07       	cpc	r25, r19
     212:	70 f4       	brcc	.+28     	; 0x230 <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     214:	80 91 b1 00 	lds	r24, 0x00B1
     218:	90 91 b2 00 	lds	r25, 0x00B2
     21c:	20 91 82 00 	lds	r18, 0x0082
     220:	30 91 83 00 	lds	r19, 0x0083
     224:	2e 5f       	subi	r18, 0xFE	; 254
     226:	3f 4f       	sbci	r19, 0xFF	; 255
     228:	b9 01       	movw	r22, r18
     22a:	0e 94 da 03 	call	0x7b4	; 0x7b4 <vListInsert>
     22e:	0d c0       	rjmp	.+26     	; 0x24a <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     230:	80 91 af 00 	lds	r24, 0x00AF
     234:	90 91 b0 00 	lds	r25, 0x00B0
     238:	20 91 82 00 	lds	r18, 0x0082
     23c:	30 91 83 00 	lds	r19, 0x0083
     240:	2e 5f       	subi	r18, 0xFE	; 254
     242:	3f 4f       	sbci	r19, 0xFF	; 255
     244:	b9 01       	movw	r22, r18
     246:	0e 94 da 03 	call	0x7b4	; 0x7b4 <vListInsert>
	}

	if( pxEventList )
     24a:	8d 81       	ldd	r24, Y+5	; 0x05
     24c:	9e 81       	ldd	r25, Y+6	; 0x06
     24e:	00 97       	sbiw	r24, 0x00	; 0
     250:	61 f0       	breq	.+24     	; 0x26a <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     252:	80 91 82 00 	lds	r24, 0x0082
     256:	90 91 83 00 	lds	r25, 0x0083
     25a:	9c 01       	movw	r18, r24
     25c:	24 5f       	subi	r18, 0xF4	; 244
     25e:	3f 4f       	sbci	r19, 0xFF	; 255
     260:	8d 81       	ldd	r24, Y+5	; 0x05
     262:	9e 81       	ldd	r25, Y+6	; 0x06
     264:	b9 01       	movw	r22, r18
     266:	0e 94 da 03 	call	0x7b4	; 0x7b4 <vListInsert>
	}
}
     26a:	26 96       	adiw	r28, 0x06	; 6
     26c:	0f b6       	in	r0, 0x3f	; 63
     26e:	f8 94       	cli
     270:	de bf       	out	0x3e, r29	; 62
     272:	0f be       	out	0x3f, r0	; 63
     274:	cd bf       	out	0x3d, r28	; 61
     276:	cf 91       	pop	r28
     278:	df 91       	pop	r29
     27a:	08 95       	ret

0000027c <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
     27c:	df 93       	push	r29
     27e:	cf 93       	push	r28
     280:	00 d0       	rcall	.+0      	; 0x282 <prvCheckPendingReadyList+0x6>
     282:	cd b7       	in	r28, 0x3d	; 61
     284:	de b7       	in	r29, 0x3e	; 62
     286:	3a c0       	rjmp	.+116    	; 0x2fc <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
     288:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
     28a:	e0 91 b8 00 	lds	r30, 0x00B8
     28e:	f0 91 b9 00 	lds	r31, 0x00B9
     292:	86 81       	ldd	r24, Z+6	; 0x06
     294:	97 81       	ldd	r25, Z+7	; 0x07
     296:	9a 83       	std	Y+2, r25	; 0x02
     298:	89 83       	std	Y+1, r24	; 0x01
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     29a:	89 81       	ldd	r24, Y+1	; 0x01
     29c:	9a 81       	ldd	r25, Y+2	; 0x02
     29e:	0c 96       	adiw	r24, 0x0c	; 12
     2a0:	0e 94 46 04 	call	0x88c	; 0x88c <vListRemove>
		}
		portENABLE_INTERRUPTS();
     2a4:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     2a6:	89 81       	ldd	r24, Y+1	; 0x01
     2a8:	9a 81       	ldd	r25, Y+2	; 0x02
     2aa:	02 96       	adiw	r24, 0x02	; 2
     2ac:	0e 94 46 04 	call	0x88c	; 0x88c <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
     2b0:	e9 81       	ldd	r30, Y+1	; 0x01
     2b2:	fa 81       	ldd	r31, Y+2	; 0x02
     2b4:	96 89       	ldd	r25, Z+22	; 0x16
     2b6:	80 91 84 00 	lds	r24, 0x0084
     2ba:	89 17       	cp	r24, r25
     2bc:	28 f4       	brcc	.+10     	; 0x2c8 <prvCheckPendingReadyList+0x4c>
     2be:	e9 81       	ldd	r30, Y+1	; 0x01
     2c0:	fa 81       	ldd	r31, Y+2	; 0x02
     2c2:	86 89       	ldd	r24, Z+22	; 0x16
     2c4:	80 93 84 00 	sts	0x0084, r24
     2c8:	e9 81       	ldd	r30, Y+1	; 0x01
     2ca:	fa 81       	ldd	r31, Y+2	; 0x02
     2cc:	86 89       	ldd	r24, Z+22	; 0x16
     2ce:	28 2f       	mov	r18, r24
     2d0:	30 e0       	ldi	r19, 0x00	; 0
     2d2:	c9 01       	movw	r24, r18
     2d4:	88 0f       	add	r24, r24
     2d6:	99 1f       	adc	r25, r25
     2d8:	88 0f       	add	r24, r24
     2da:	99 1f       	adc	r25, r25
     2dc:	88 0f       	add	r24, r24
     2de:	99 1f       	adc	r25, r25
     2e0:	82 0f       	add	r24, r18
     2e2:	93 1f       	adc	r25, r19
     2e4:	ac 01       	movw	r20, r24
     2e6:	45 57       	subi	r20, 0x75	; 117
     2e8:	5f 4f       	sbci	r21, 0xFF	; 255
     2ea:	89 81       	ldd	r24, Y+1	; 0x01
     2ec:	9a 81       	ldd	r25, Y+2	; 0x02
     2ee:	9c 01       	movw	r18, r24
     2f0:	2e 5f       	subi	r18, 0xFE	; 254
     2f2:	3f 4f       	sbci	r19, 0xFF	; 255
     2f4:	ca 01       	movw	r24, r20
     2f6:	b9 01       	movw	r22, r18
     2f8:	0e 94 8e 03 	call	0x71c	; 0x71c <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     2fc:	80 91 b3 00 	lds	r24, 0x00B3
     300:	88 23       	and	r24, r24
     302:	09 f0       	breq	.+2      	; 0x306 <prvCheckPendingReadyList+0x8a>
     304:	c1 cf       	rjmp	.-126    	; 0x288 <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
     306:	0f 90       	pop	r0
     308:	0f 90       	pop	r0
     30a:	cf 91       	pop	r28
     30c:	df 91       	pop	r29
     30e:	08 95       	ret

00000310 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
     310:	df 93       	push	r29
     312:	cf 93       	push	r28
     314:	00 d0       	rcall	.+0      	; 0x316 <prvCheckDelayedList+0x6>
     316:	00 d0       	rcall	.+0      	; 0x318 <prvCheckDelayedList+0x8>
     318:	cd b7       	in	r28, 0x3d	; 61
     31a:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     31c:	0e 94 b4 0e 	call	0x1d68	; 0x1d68 <xTaskGetTickCount>
     320:	20 91 87 00 	lds	r18, 0x0087
     324:	30 91 88 00 	lds	r19, 0x0088
     328:	82 1b       	sub	r24, r18
     32a:	93 0b       	sbc	r25, r19
     32c:	90 93 8a 00 	sts	0x008A, r25
     330:	80 93 89 00 	sts	0x0089, r24
     334:	85 c0       	rjmp	.+266    	; 0x440 <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
     336:	80 91 85 00 	lds	r24, 0x0085
     33a:	90 91 86 00 	lds	r25, 0x0086
     33e:	01 96       	adiw	r24, 0x01	; 1
     340:	90 93 86 00 	sts	0x0086, r25
     344:	80 93 85 00 	sts	0x0085, r24
		xPassedTicks--;
     348:	80 91 89 00 	lds	r24, 0x0089
     34c:	90 91 8a 00 	lds	r25, 0x008A
     350:	01 97       	sbiw	r24, 0x01	; 1
     352:	90 93 8a 00 	sts	0x008A, r25
     356:	80 93 89 00 	sts	0x0089, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
     35a:	80 91 85 00 	lds	r24, 0x0085
     35e:	90 91 86 00 	lds	r25, 0x0086
     362:	00 97       	sbiw	r24, 0x00	; 0
     364:	09 f0       	breq	.+2      	; 0x368 <prvCheckDelayedList+0x58>
     366:	64 c0       	rjmp	.+200    	; 0x430 <prvCheckDelayedList+0x120>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
     368:	80 91 af 00 	lds	r24, 0x00AF
     36c:	90 91 b0 00 	lds	r25, 0x00B0
     370:	9a 83       	std	Y+2, r25	; 0x02
     372:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     374:	80 91 b1 00 	lds	r24, 0x00B1
     378:	90 91 b2 00 	lds	r25, 0x00B2
     37c:	90 93 b0 00 	sts	0x00B0, r25
     380:	80 93 af 00 	sts	0x00AF, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
     384:	89 81       	ldd	r24, Y+1	; 0x01
     386:	9a 81       	ldd	r25, Y+2	; 0x02
     388:	90 93 b2 00 	sts	0x00B2, r25
     38c:	80 93 b1 00 	sts	0x00B1, r24
     390:	4f c0       	rjmp	.+158    	; 0x430 <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     392:	e0 91 af 00 	lds	r30, 0x00AF
     396:	f0 91 b0 00 	lds	r31, 0x00B0
     39a:	05 80       	ldd	r0, Z+5	; 0x05
     39c:	f6 81       	ldd	r31, Z+6	; 0x06
     39e:	e0 2d       	mov	r30, r0
     3a0:	86 81       	ldd	r24, Z+6	; 0x06
     3a2:	97 81       	ldd	r25, Z+7	; 0x07
     3a4:	9c 83       	std	Y+4, r25	; 0x04
     3a6:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
     3a8:	eb 81       	ldd	r30, Y+3	; 0x03
     3aa:	fc 81       	ldd	r31, Y+4	; 0x04
     3ac:	22 81       	ldd	r18, Z+2	; 0x02
     3ae:	33 81       	ldd	r19, Z+3	; 0x03
     3b0:	80 91 85 00 	lds	r24, 0x0085
     3b4:	90 91 86 00 	lds	r25, 0x0086
     3b8:	82 17       	cp	r24, r18
     3ba:	93 07       	cpc	r25, r19
     3bc:	08 f4       	brcc	.+2      	; 0x3c0 <prvCheckDelayedList+0xb0>
     3be:	40 c0       	rjmp	.+128    	; 0x440 <prvCheckDelayedList+0x130>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
     3c0:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
     3c2:	8b 81       	ldd	r24, Y+3	; 0x03
     3c4:	9c 81       	ldd	r25, Y+4	; 0x04
     3c6:	02 96       	adiw	r24, 0x02	; 2
     3c8:	0e 94 46 04 	call	0x88c	; 0x88c <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
     3cc:	eb 81       	ldd	r30, Y+3	; 0x03
     3ce:	fc 81       	ldd	r31, Y+4	; 0x04
     3d0:	84 89       	ldd	r24, Z+20	; 0x14
     3d2:	95 89       	ldd	r25, Z+21	; 0x15
     3d4:	00 97       	sbiw	r24, 0x00	; 0
     3d6:	29 f0       	breq	.+10     	; 0x3e2 <prvCheckDelayedList+0xd2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
     3d8:	8b 81       	ldd	r24, Y+3	; 0x03
     3da:	9c 81       	ldd	r25, Y+4	; 0x04
     3dc:	0c 96       	adiw	r24, 0x0c	; 12
     3de:	0e 94 46 04 	call	0x88c	; 0x88c <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
     3e2:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
     3e4:	eb 81       	ldd	r30, Y+3	; 0x03
     3e6:	fc 81       	ldd	r31, Y+4	; 0x04
     3e8:	96 89       	ldd	r25, Z+22	; 0x16
     3ea:	80 91 84 00 	lds	r24, 0x0084
     3ee:	89 17       	cp	r24, r25
     3f0:	28 f4       	brcc	.+10     	; 0x3fc <prvCheckDelayedList+0xec>
     3f2:	eb 81       	ldd	r30, Y+3	; 0x03
     3f4:	fc 81       	ldd	r31, Y+4	; 0x04
     3f6:	86 89       	ldd	r24, Z+22	; 0x16
     3f8:	80 93 84 00 	sts	0x0084, r24
     3fc:	eb 81       	ldd	r30, Y+3	; 0x03
     3fe:	fc 81       	ldd	r31, Y+4	; 0x04
     400:	86 89       	ldd	r24, Z+22	; 0x16
     402:	28 2f       	mov	r18, r24
     404:	30 e0       	ldi	r19, 0x00	; 0
     406:	c9 01       	movw	r24, r18
     408:	88 0f       	add	r24, r24
     40a:	99 1f       	adc	r25, r25
     40c:	88 0f       	add	r24, r24
     40e:	99 1f       	adc	r25, r25
     410:	88 0f       	add	r24, r24
     412:	99 1f       	adc	r25, r25
     414:	82 0f       	add	r24, r18
     416:	93 1f       	adc	r25, r19
     418:	ac 01       	movw	r20, r24
     41a:	45 57       	subi	r20, 0x75	; 117
     41c:	5f 4f       	sbci	r21, 0xFF	; 255
     41e:	8b 81       	ldd	r24, Y+3	; 0x03
     420:	9c 81       	ldd	r25, Y+4	; 0x04
     422:	9c 01       	movw	r18, r24
     424:	2e 5f       	subi	r18, 0xFE	; 254
     426:	3f 4f       	sbci	r19, 0xFF	; 255
     428:	ca 01       	movw	r24, r20
     42a:	b9 01       	movw	r22, r18
     42c:	0e 94 8e 03 	call	0x71c	; 0x71c <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     430:	e0 91 af 00 	lds	r30, 0x00AF
     434:	f0 91 b0 00 	lds	r31, 0x00B0
     438:	80 81       	ld	r24, Z
     43a:	88 23       	and	r24, r24
     43c:	09 f0       	breq	.+2      	; 0x440 <prvCheckDelayedList+0x130>
     43e:	a9 cf       	rjmp	.-174    	; 0x392 <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
     440:	80 91 89 00 	lds	r24, 0x0089
     444:	90 91 8a 00 	lds	r25, 0x008A
     448:	00 97       	sbiw	r24, 0x00	; 0
     44a:	09 f0       	breq	.+2      	; 0x44e <prvCheckDelayedList+0x13e>
     44c:	74 cf       	rjmp	.-280    	; 0x336 <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
     44e:	80 91 85 00 	lds	r24, 0x0085
     452:	90 91 86 00 	lds	r25, 0x0086
     456:	90 93 88 00 	sts	0x0088, r25
     45a:	80 93 87 00 	sts	0x0087, r24
}
     45e:	0f 90       	pop	r0
     460:	0f 90       	pop	r0
     462:	0f 90       	pop	r0
     464:	0f 90       	pop	r0
     466:	cf 91       	pop	r28
     468:	df 91       	pop	r29
     46a:	08 95       	ret

0000046c <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
     46c:	df 93       	push	r29
     46e:	cf 93       	push	r28
     470:	00 d0       	rcall	.+0      	; 0x472 <vCoRoutineSchedule+0x6>
     472:	cd b7       	in	r28, 0x3d	; 61
     474:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
     476:	0e 94 3e 01 	call	0x27c	; 0x27c <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
     47a:	0e 94 88 01 	call	0x310	; 0x310 <prvCheckDelayedList>
     47e:	0a c0       	rjmp	.+20     	; 0x494 <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
     480:	80 91 84 00 	lds	r24, 0x0084
     484:	88 23       	and	r24, r24
     486:	09 f4       	brne	.+2      	; 0x48a <vCoRoutineSchedule+0x1e>
     488:	66 c0       	rjmp	.+204    	; 0x556 <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
     48a:	80 91 84 00 	lds	r24, 0x0084
     48e:	81 50       	subi	r24, 0x01	; 1
     490:	80 93 84 00 	sts	0x0084, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     494:	80 91 84 00 	lds	r24, 0x0084
     498:	28 2f       	mov	r18, r24
     49a:	30 e0       	ldi	r19, 0x00	; 0
     49c:	c9 01       	movw	r24, r18
     49e:	88 0f       	add	r24, r24
     4a0:	99 1f       	adc	r25, r25
     4a2:	88 0f       	add	r24, r24
     4a4:	99 1f       	adc	r25, r25
     4a6:	88 0f       	add	r24, r24
     4a8:	99 1f       	adc	r25, r25
     4aa:	82 0f       	add	r24, r18
     4ac:	93 1f       	adc	r25, r19
     4ae:	fc 01       	movw	r30, r24
     4b0:	e5 57       	subi	r30, 0x75	; 117
     4b2:	ff 4f       	sbci	r31, 0xFF	; 255
     4b4:	80 81       	ld	r24, Z
     4b6:	88 23       	and	r24, r24
     4b8:	19 f3       	breq	.-58     	; 0x480 <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
     4ba:	80 91 84 00 	lds	r24, 0x0084
     4be:	28 2f       	mov	r18, r24
     4c0:	30 e0       	ldi	r19, 0x00	; 0
     4c2:	c9 01       	movw	r24, r18
     4c4:	88 0f       	add	r24, r24
     4c6:	99 1f       	adc	r25, r25
     4c8:	88 0f       	add	r24, r24
     4ca:	99 1f       	adc	r25, r25
     4cc:	88 0f       	add	r24, r24
     4ce:	99 1f       	adc	r25, r25
     4d0:	82 0f       	add	r24, r18
     4d2:	93 1f       	adc	r25, r19
     4d4:	85 57       	subi	r24, 0x75	; 117
     4d6:	9f 4f       	sbci	r25, 0xFF	; 255
     4d8:	9a 83       	std	Y+2, r25	; 0x02
     4da:	89 83       	std	Y+1, r24	; 0x01
     4dc:	e9 81       	ldd	r30, Y+1	; 0x01
     4de:	fa 81       	ldd	r31, Y+2	; 0x02
     4e0:	01 80       	ldd	r0, Z+1	; 0x01
     4e2:	f2 81       	ldd	r31, Z+2	; 0x02
     4e4:	e0 2d       	mov	r30, r0
     4e6:	82 81       	ldd	r24, Z+2	; 0x02
     4e8:	93 81       	ldd	r25, Z+3	; 0x03
     4ea:	e9 81       	ldd	r30, Y+1	; 0x01
     4ec:	fa 81       	ldd	r31, Y+2	; 0x02
     4ee:	92 83       	std	Z+2, r25	; 0x02
     4f0:	81 83       	std	Z+1, r24	; 0x01
     4f2:	e9 81       	ldd	r30, Y+1	; 0x01
     4f4:	fa 81       	ldd	r31, Y+2	; 0x02
     4f6:	21 81       	ldd	r18, Z+1	; 0x01
     4f8:	32 81       	ldd	r19, Z+2	; 0x02
     4fa:	89 81       	ldd	r24, Y+1	; 0x01
     4fc:	9a 81       	ldd	r25, Y+2	; 0x02
     4fe:	03 96       	adiw	r24, 0x03	; 3
     500:	28 17       	cp	r18, r24
     502:	39 07       	cpc	r19, r25
     504:	59 f4       	brne	.+22     	; 0x51c <vCoRoutineSchedule+0xb0>
     506:	e9 81       	ldd	r30, Y+1	; 0x01
     508:	fa 81       	ldd	r31, Y+2	; 0x02
     50a:	01 80       	ldd	r0, Z+1	; 0x01
     50c:	f2 81       	ldd	r31, Z+2	; 0x02
     50e:	e0 2d       	mov	r30, r0
     510:	82 81       	ldd	r24, Z+2	; 0x02
     512:	93 81       	ldd	r25, Z+3	; 0x03
     514:	e9 81       	ldd	r30, Y+1	; 0x01
     516:	fa 81       	ldd	r31, Y+2	; 0x02
     518:	92 83       	std	Z+2, r25	; 0x02
     51a:	81 83       	std	Z+1, r24	; 0x01
     51c:	e9 81       	ldd	r30, Y+1	; 0x01
     51e:	fa 81       	ldd	r31, Y+2	; 0x02
     520:	01 80       	ldd	r0, Z+1	; 0x01
     522:	f2 81       	ldd	r31, Z+2	; 0x02
     524:	e0 2d       	mov	r30, r0
     526:	86 81       	ldd	r24, Z+6	; 0x06
     528:	97 81       	ldd	r25, Z+7	; 0x07
     52a:	90 93 83 00 	sts	0x0083, r25
     52e:	80 93 82 00 	sts	0x0082, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
     532:	e0 91 82 00 	lds	r30, 0x0082
     536:	f0 91 83 00 	lds	r31, 0x0083
     53a:	40 81       	ld	r20, Z
     53c:	51 81       	ldd	r21, Z+1	; 0x01
     53e:	80 91 82 00 	lds	r24, 0x0082
     542:	90 91 83 00 	lds	r25, 0x0083
     546:	e0 91 82 00 	lds	r30, 0x0082
     54a:	f0 91 83 00 	lds	r31, 0x0083
     54e:	27 89       	ldd	r18, Z+23	; 0x17
     550:	62 2f       	mov	r22, r18
     552:	fa 01       	movw	r30, r20
     554:	09 95       	icall

	return;
}
     556:	0f 90       	pop	r0
     558:	0f 90       	pop	r0
     55a:	cf 91       	pop	r28
     55c:	df 91       	pop	r29
     55e:	08 95       	ret

00000560 <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
     560:	df 93       	push	r29
     562:	cf 93       	push	r28
     564:	0f 92       	push	r0
     566:	cd b7       	in	r28, 0x3d	; 61
     568:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
     56a:	19 82       	std	Y+1, r1	; 0x01
     56c:	13 c0       	rjmp	.+38     	; 0x594 <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
     56e:	89 81       	ldd	r24, Y+1	; 0x01
     570:	28 2f       	mov	r18, r24
     572:	30 e0       	ldi	r19, 0x00	; 0
     574:	c9 01       	movw	r24, r18
     576:	88 0f       	add	r24, r24
     578:	99 1f       	adc	r25, r25
     57a:	88 0f       	add	r24, r24
     57c:	99 1f       	adc	r25, r25
     57e:	88 0f       	add	r24, r24
     580:	99 1f       	adc	r25, r25
     582:	82 0f       	add	r24, r18
     584:	93 1f       	adc	r25, r19
     586:	85 57       	subi	r24, 0x75	; 117
     588:	9f 4f       	sbci	r25, 0xFF	; 255
     58a:	0e 94 54 03 	call	0x6a8	; 0x6a8 <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
     58e:	89 81       	ldd	r24, Y+1	; 0x01
     590:	8f 5f       	subi	r24, 0xFF	; 255
     592:	89 83       	std	Y+1, r24	; 0x01
     594:	89 81       	ldd	r24, Y+1	; 0x01
     596:	82 30       	cpi	r24, 0x02	; 2
     598:	50 f3       	brcs	.-44     	; 0x56e <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
     59a:	8d e9       	ldi	r24, 0x9D	; 157
     59c:	90 e0       	ldi	r25, 0x00	; 0
     59e:	0e 94 54 03 	call	0x6a8	; 0x6a8 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
     5a2:	86 ea       	ldi	r24, 0xA6	; 166
     5a4:	90 e0       	ldi	r25, 0x00	; 0
     5a6:	0e 94 54 03 	call	0x6a8	; 0x6a8 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
     5aa:	83 eb       	ldi	r24, 0xB3	; 179
     5ac:	90 e0       	ldi	r25, 0x00	; 0
     5ae:	0e 94 54 03 	call	0x6a8	; 0x6a8 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
     5b2:	8d e9       	ldi	r24, 0x9D	; 157
     5b4:	90 e0       	ldi	r25, 0x00	; 0
     5b6:	90 93 b0 00 	sts	0x00B0, r25
     5ba:	80 93 af 00 	sts	0x00AF, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
     5be:	86 ea       	ldi	r24, 0xA6	; 166
     5c0:	90 e0       	ldi	r25, 0x00	; 0
     5c2:	90 93 b2 00 	sts	0x00B2, r25
     5c6:	80 93 b1 00 	sts	0x00B1, r24
}
     5ca:	0f 90       	pop	r0
     5cc:	cf 91       	pop	r28
     5ce:	df 91       	pop	r29
     5d0:	08 95       	ret

000005d2 <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
     5d2:	df 93       	push	r29
     5d4:	cf 93       	push	r28
     5d6:	00 d0       	rcall	.+0      	; 0x5d8 <xCoRoutineRemoveFromEventList+0x6>
     5d8:	00 d0       	rcall	.+0      	; 0x5da <xCoRoutineRemoveFromEventList+0x8>
     5da:	0f 92       	push	r0
     5dc:	cd b7       	in	r28, 0x3d	; 61
     5de:	de b7       	in	r29, 0x3e	; 62
     5e0:	9d 83       	std	Y+5, r25	; 0x05
     5e2:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     5e4:	ec 81       	ldd	r30, Y+4	; 0x04
     5e6:	fd 81       	ldd	r31, Y+5	; 0x05
     5e8:	05 80       	ldd	r0, Z+5	; 0x05
     5ea:	f6 81       	ldd	r31, Z+6	; 0x06
     5ec:	e0 2d       	mov	r30, r0
     5ee:	86 81       	ldd	r24, Z+6	; 0x06
     5f0:	97 81       	ldd	r25, Z+7	; 0x07
     5f2:	9b 83       	std	Y+3, r25	; 0x03
     5f4:	8a 83       	std	Y+2, r24	; 0x02
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     5f6:	8a 81       	ldd	r24, Y+2	; 0x02
     5f8:	9b 81       	ldd	r25, Y+3	; 0x03
     5fa:	0c 96       	adiw	r24, 0x0c	; 12
     5fc:	0e 94 46 04 	call	0x88c	; 0x88c <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
     600:	8a 81       	ldd	r24, Y+2	; 0x02
     602:	9b 81       	ldd	r25, Y+3	; 0x03
     604:	9c 01       	movw	r18, r24
     606:	24 5f       	subi	r18, 0xF4	; 244
     608:	3f 4f       	sbci	r19, 0xFF	; 255
     60a:	83 eb       	ldi	r24, 0xB3	; 179
     60c:	90 e0       	ldi	r25, 0x00	; 0
     60e:	b9 01       	movw	r22, r18
     610:	0e 94 8e 03 	call	0x71c	; 0x71c <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
     614:	ea 81       	ldd	r30, Y+2	; 0x02
     616:	fb 81       	ldd	r31, Y+3	; 0x03
     618:	96 89       	ldd	r25, Z+22	; 0x16
     61a:	e0 91 82 00 	lds	r30, 0x0082
     61e:	f0 91 83 00 	lds	r31, 0x0083
     622:	86 89       	ldd	r24, Z+22	; 0x16
     624:	98 17       	cp	r25, r24
     626:	18 f0       	brcs	.+6      	; 0x62e <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
     628:	81 e0       	ldi	r24, 0x01	; 1
     62a:	89 83       	std	Y+1, r24	; 0x01
     62c:	01 c0       	rjmp	.+2      	; 0x630 <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
     62e:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
     630:	89 81       	ldd	r24, Y+1	; 0x01
}
     632:	0f 90       	pop	r0
     634:	0f 90       	pop	r0
     636:	0f 90       	pop	r0
     638:	0f 90       	pop	r0
     63a:	0f 90       	pop	r0
     63c:	cf 91       	pop	r28
     63e:	df 91       	pop	r29
     640:	08 95       	ret

00000642 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     642:	df 93       	push	r29
     644:	cf 93       	push	r28
     646:	00 d0       	rcall	.+0      	; 0x648 <pvPortMalloc+0x6>
     648:	00 d0       	rcall	.+0      	; 0x64a <pvPortMalloc+0x8>
     64a:	cd b7       	in	r28, 0x3d	; 61
     64c:	de b7       	in	r29, 0x3e	; 62
     64e:	9c 83       	std	Y+4, r25	; 0x04
     650:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn;

	vTaskSuspendAll();
     652:	0e 94 1e 0e 	call	0x1c3c	; 0x1c3c <vTaskSuspendAll>
	{
		pvReturn = malloc( xWantedSize );
     656:	8b 81       	ldd	r24, Y+3	; 0x03
     658:	9c 81       	ldd	r25, Y+4	; 0x04
     65a:	0e 94 6e 16 	call	0x2cdc	; 0x2cdc <malloc>
     65e:	9a 83       	std	Y+2, r25	; 0x02
     660:	89 83       	std	Y+1, r24	; 0x01
	}
	xTaskResumeAll();
     662:	0e 94 2a 0e 	call	0x1c54	; 0x1c54 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif
	
	return pvReturn;
     666:	89 81       	ldd	r24, Y+1	; 0x01
     668:	9a 81       	ldd	r25, Y+2	; 0x02
}
     66a:	0f 90       	pop	r0
     66c:	0f 90       	pop	r0
     66e:	0f 90       	pop	r0
     670:	0f 90       	pop	r0
     672:	cf 91       	pop	r28
     674:	df 91       	pop	r29
     676:	08 95       	ret

00000678 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     678:	df 93       	push	r29
     67a:	cf 93       	push	r28
     67c:	00 d0       	rcall	.+0      	; 0x67e <vPortFree+0x6>
     67e:	cd b7       	in	r28, 0x3d	; 61
     680:	de b7       	in	r29, 0x3e	; 62
     682:	9a 83       	std	Y+2, r25	; 0x02
     684:	89 83       	std	Y+1, r24	; 0x01
	if( pv )
     686:	89 81       	ldd	r24, Y+1	; 0x01
     688:	9a 81       	ldd	r25, Y+2	; 0x02
     68a:	00 97       	sbiw	r24, 0x00	; 0
     68c:	41 f0       	breq	.+16     	; 0x69e <vPortFree+0x26>
	{
		vTaskSuspendAll();
     68e:	0e 94 1e 0e 	call	0x1c3c	; 0x1c3c <vTaskSuspendAll>
		{
			free( pv );
     692:	89 81       	ldd	r24, Y+1	; 0x01
     694:	9a 81       	ldd	r25, Y+2	; 0x02
     696:	0e 94 1b 17 	call	0x2e36	; 0x2e36 <free>
		}
		xTaskResumeAll();
     69a:	0e 94 2a 0e 	call	0x1c54	; 0x1c54 <xTaskResumeAll>
	}
}
     69e:	0f 90       	pop	r0
     6a0:	0f 90       	pop	r0
     6a2:	cf 91       	pop	r28
     6a4:	df 91       	pop	r29
     6a6:	08 95       	ret

000006a8 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     6a8:	df 93       	push	r29
     6aa:	cf 93       	push	r28
     6ac:	00 d0       	rcall	.+0      	; 0x6ae <vListInitialise+0x6>
     6ae:	cd b7       	in	r28, 0x3d	; 61
     6b0:	de b7       	in	r29, 0x3e	; 62
     6b2:	9a 83       	std	Y+2, r25	; 0x02
     6b4:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     6b6:	89 81       	ldd	r24, Y+1	; 0x01
     6b8:	9a 81       	ldd	r25, Y+2	; 0x02
     6ba:	03 96       	adiw	r24, 0x03	; 3
     6bc:	e9 81       	ldd	r30, Y+1	; 0x01
     6be:	fa 81       	ldd	r31, Y+2	; 0x02
     6c0:	92 83       	std	Z+2, r25	; 0x02
     6c2:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     6c4:	e9 81       	ldd	r30, Y+1	; 0x01
     6c6:	fa 81       	ldd	r31, Y+2	; 0x02
     6c8:	8f ef       	ldi	r24, 0xFF	; 255
     6ca:	9f ef       	ldi	r25, 0xFF	; 255
     6cc:	94 83       	std	Z+4, r25	; 0x04
     6ce:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     6d0:	89 81       	ldd	r24, Y+1	; 0x01
     6d2:	9a 81       	ldd	r25, Y+2	; 0x02
     6d4:	03 96       	adiw	r24, 0x03	; 3
     6d6:	e9 81       	ldd	r30, Y+1	; 0x01
     6d8:	fa 81       	ldd	r31, Y+2	; 0x02
     6da:	96 83       	std	Z+6, r25	; 0x06
     6dc:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     6de:	89 81       	ldd	r24, Y+1	; 0x01
     6e0:	9a 81       	ldd	r25, Y+2	; 0x02
     6e2:	03 96       	adiw	r24, 0x03	; 3
     6e4:	e9 81       	ldd	r30, Y+1	; 0x01
     6e6:	fa 81       	ldd	r31, Y+2	; 0x02
     6e8:	90 87       	std	Z+8, r25	; 0x08
     6ea:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     6ec:	e9 81       	ldd	r30, Y+1	; 0x01
     6ee:	fa 81       	ldd	r31, Y+2	; 0x02
     6f0:	10 82       	st	Z, r1
}
     6f2:	0f 90       	pop	r0
     6f4:	0f 90       	pop	r0
     6f6:	cf 91       	pop	r28
     6f8:	df 91       	pop	r29
     6fa:	08 95       	ret

000006fc <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
     6fc:	df 93       	push	r29
     6fe:	cf 93       	push	r28
     700:	00 d0       	rcall	.+0      	; 0x702 <vListInitialiseItem+0x6>
     702:	cd b7       	in	r28, 0x3d	; 61
     704:	de b7       	in	r29, 0x3e	; 62
     706:	9a 83       	std	Y+2, r25	; 0x02
     708:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     70a:	e9 81       	ldd	r30, Y+1	; 0x01
     70c:	fa 81       	ldd	r31, Y+2	; 0x02
     70e:	11 86       	std	Z+9, r1	; 0x09
     710:	10 86       	std	Z+8, r1	; 0x08
}
     712:	0f 90       	pop	r0
     714:	0f 90       	pop	r0
     716:	cf 91       	pop	r28
     718:	df 91       	pop	r29
     71a:	08 95       	ret

0000071c <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     71c:	df 93       	push	r29
     71e:	cf 93       	push	r28
     720:	00 d0       	rcall	.+0      	; 0x722 <vListInsertEnd+0x6>
     722:	00 d0       	rcall	.+0      	; 0x724 <vListInsertEnd+0x8>
     724:	00 d0       	rcall	.+0      	; 0x726 <vListInsertEnd+0xa>
     726:	cd b7       	in	r28, 0x3d	; 61
     728:	de b7       	in	r29, 0x3e	; 62
     72a:	9c 83       	std	Y+4, r25	; 0x04
     72c:	8b 83       	std	Y+3, r24	; 0x03
     72e:	7e 83       	std	Y+6, r23	; 0x06
     730:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     732:	eb 81       	ldd	r30, Y+3	; 0x03
     734:	fc 81       	ldd	r31, Y+4	; 0x04
     736:	81 81       	ldd	r24, Z+1	; 0x01
     738:	92 81       	ldd	r25, Z+2	; 0x02
     73a:	9a 83       	std	Y+2, r25	; 0x02
     73c:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
     73e:	e9 81       	ldd	r30, Y+1	; 0x01
     740:	fa 81       	ldd	r31, Y+2	; 0x02
     742:	82 81       	ldd	r24, Z+2	; 0x02
     744:	93 81       	ldd	r25, Z+3	; 0x03
     746:	ed 81       	ldd	r30, Y+5	; 0x05
     748:	fe 81       	ldd	r31, Y+6	; 0x06
     74a:	93 83       	std	Z+3, r25	; 0x03
     74c:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
     74e:	eb 81       	ldd	r30, Y+3	; 0x03
     750:	fc 81       	ldd	r31, Y+4	; 0x04
     752:	81 81       	ldd	r24, Z+1	; 0x01
     754:	92 81       	ldd	r25, Z+2	; 0x02
     756:	ed 81       	ldd	r30, Y+5	; 0x05
     758:	fe 81       	ldd	r31, Y+6	; 0x06
     75a:	95 83       	std	Z+5, r25	; 0x05
     75c:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     75e:	e9 81       	ldd	r30, Y+1	; 0x01
     760:	fa 81       	ldd	r31, Y+2	; 0x02
     762:	02 80       	ldd	r0, Z+2	; 0x02
     764:	f3 81       	ldd	r31, Z+3	; 0x03
     766:	e0 2d       	mov	r30, r0
     768:	8d 81       	ldd	r24, Y+5	; 0x05
     76a:	9e 81       	ldd	r25, Y+6	; 0x06
     76c:	95 83       	std	Z+5, r25	; 0x05
     76e:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     770:	8d 81       	ldd	r24, Y+5	; 0x05
     772:	9e 81       	ldd	r25, Y+6	; 0x06
     774:	e9 81       	ldd	r30, Y+1	; 0x01
     776:	fa 81       	ldd	r31, Y+2	; 0x02
     778:	93 83       	std	Z+3, r25	; 0x03
     77a:	82 83       	std	Z+2, r24	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     77c:	8d 81       	ldd	r24, Y+5	; 0x05
     77e:	9e 81       	ldd	r25, Y+6	; 0x06
     780:	eb 81       	ldd	r30, Y+3	; 0x03
     782:	fc 81       	ldd	r31, Y+4	; 0x04
     784:	92 83       	std	Z+2, r25	; 0x02
     786:	81 83       	std	Z+1, r24	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     788:	ed 81       	ldd	r30, Y+5	; 0x05
     78a:	fe 81       	ldd	r31, Y+6	; 0x06
     78c:	8b 81       	ldd	r24, Y+3	; 0x03
     78e:	9c 81       	ldd	r25, Y+4	; 0x04
     790:	91 87       	std	Z+9, r25	; 0x09
     792:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     794:	eb 81       	ldd	r30, Y+3	; 0x03
     796:	fc 81       	ldd	r31, Y+4	; 0x04
     798:	80 81       	ld	r24, Z
     79a:	8f 5f       	subi	r24, 0xFF	; 255
     79c:	eb 81       	ldd	r30, Y+3	; 0x03
     79e:	fc 81       	ldd	r31, Y+4	; 0x04
     7a0:	80 83       	st	Z, r24
}
     7a2:	26 96       	adiw	r28, 0x06	; 6
     7a4:	0f b6       	in	r0, 0x3f	; 63
     7a6:	f8 94       	cli
     7a8:	de bf       	out	0x3e, r29	; 62
     7aa:	0f be       	out	0x3f, r0	; 63
     7ac:	cd bf       	out	0x3d, r28	; 61
     7ae:	cf 91       	pop	r28
     7b0:	df 91       	pop	r29
     7b2:	08 95       	ret

000007b4 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     7b4:	df 93       	push	r29
     7b6:	cf 93       	push	r28
     7b8:	cd b7       	in	r28, 0x3d	; 61
     7ba:	de b7       	in	r29, 0x3e	; 62
     7bc:	28 97       	sbiw	r28, 0x08	; 8
     7be:	0f b6       	in	r0, 0x3f	; 63
     7c0:	f8 94       	cli
     7c2:	de bf       	out	0x3e, r29	; 62
     7c4:	0f be       	out	0x3f, r0	; 63
     7c6:	cd bf       	out	0x3d, r28	; 61
     7c8:	9e 83       	std	Y+6, r25	; 0x06
     7ca:	8d 83       	std	Y+5, r24	; 0x05
     7cc:	78 87       	std	Y+8, r23	; 0x08
     7ce:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     7d0:	ef 81       	ldd	r30, Y+7	; 0x07
     7d2:	f8 85       	ldd	r31, Y+8	; 0x08
     7d4:	80 81       	ld	r24, Z
     7d6:	91 81       	ldd	r25, Z+1	; 0x01
     7d8:	9a 83       	std	Y+2, r25	; 0x02
     7da:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     7dc:	89 81       	ldd	r24, Y+1	; 0x01
     7de:	9a 81       	ldd	r25, Y+2	; 0x02
     7e0:	2f ef       	ldi	r18, 0xFF	; 255
     7e2:	8f 3f       	cpi	r24, 0xFF	; 255
     7e4:	92 07       	cpc	r25, r18
     7e6:	39 f4       	brne	.+14     	; 0x7f6 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     7e8:	ed 81       	ldd	r30, Y+5	; 0x05
     7ea:	fe 81       	ldd	r31, Y+6	; 0x06
     7ec:	87 81       	ldd	r24, Z+7	; 0x07
     7ee:	90 85       	ldd	r25, Z+8	; 0x08
     7f0:	9c 83       	std	Y+4, r25	; 0x04
     7f2:	8b 83       	std	Y+3, r24	; 0x03
     7f4:	18 c0       	rjmp	.+48     	; 0x826 <vListInsert+0x72>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     7f6:	8d 81       	ldd	r24, Y+5	; 0x05
     7f8:	9e 81       	ldd	r25, Y+6	; 0x06
     7fa:	03 96       	adiw	r24, 0x03	; 3
     7fc:	9c 83       	std	Y+4, r25	; 0x04
     7fe:	8b 83       	std	Y+3, r24	; 0x03
     800:	06 c0       	rjmp	.+12     	; 0x80e <vListInsert+0x5a>
     802:	eb 81       	ldd	r30, Y+3	; 0x03
     804:	fc 81       	ldd	r31, Y+4	; 0x04
     806:	82 81       	ldd	r24, Z+2	; 0x02
     808:	93 81       	ldd	r25, Z+3	; 0x03
     80a:	9c 83       	std	Y+4, r25	; 0x04
     80c:	8b 83       	std	Y+3, r24	; 0x03
     80e:	eb 81       	ldd	r30, Y+3	; 0x03
     810:	fc 81       	ldd	r31, Y+4	; 0x04
     812:	02 80       	ldd	r0, Z+2	; 0x02
     814:	f3 81       	ldd	r31, Z+3	; 0x03
     816:	e0 2d       	mov	r30, r0
     818:	20 81       	ld	r18, Z
     81a:	31 81       	ldd	r19, Z+1	; 0x01
     81c:	89 81       	ldd	r24, Y+1	; 0x01
     81e:	9a 81       	ldd	r25, Y+2	; 0x02
     820:	82 17       	cp	r24, r18
     822:	93 07       	cpc	r25, r19
     824:	70 f7       	brcc	.-36     	; 0x802 <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     826:	eb 81       	ldd	r30, Y+3	; 0x03
     828:	fc 81       	ldd	r31, Y+4	; 0x04
     82a:	82 81       	ldd	r24, Z+2	; 0x02
     82c:	93 81       	ldd	r25, Z+3	; 0x03
     82e:	ef 81       	ldd	r30, Y+7	; 0x07
     830:	f8 85       	ldd	r31, Y+8	; 0x08
     832:	93 83       	std	Z+3, r25	; 0x03
     834:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     836:	ef 81       	ldd	r30, Y+7	; 0x07
     838:	f8 85       	ldd	r31, Y+8	; 0x08
     83a:	02 80       	ldd	r0, Z+2	; 0x02
     83c:	f3 81       	ldd	r31, Z+3	; 0x03
     83e:	e0 2d       	mov	r30, r0
     840:	8f 81       	ldd	r24, Y+7	; 0x07
     842:	98 85       	ldd	r25, Y+8	; 0x08
     844:	95 83       	std	Z+5, r25	; 0x05
     846:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     848:	ef 81       	ldd	r30, Y+7	; 0x07
     84a:	f8 85       	ldd	r31, Y+8	; 0x08
     84c:	8b 81       	ldd	r24, Y+3	; 0x03
     84e:	9c 81       	ldd	r25, Y+4	; 0x04
     850:	95 83       	std	Z+5, r25	; 0x05
     852:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     854:	8f 81       	ldd	r24, Y+7	; 0x07
     856:	98 85       	ldd	r25, Y+8	; 0x08
     858:	eb 81       	ldd	r30, Y+3	; 0x03
     85a:	fc 81       	ldd	r31, Y+4	; 0x04
     85c:	93 83       	std	Z+3, r25	; 0x03
     85e:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     860:	ef 81       	ldd	r30, Y+7	; 0x07
     862:	f8 85       	ldd	r31, Y+8	; 0x08
     864:	8d 81       	ldd	r24, Y+5	; 0x05
     866:	9e 81       	ldd	r25, Y+6	; 0x06
     868:	91 87       	std	Z+9, r25	; 0x09
     86a:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     86c:	ed 81       	ldd	r30, Y+5	; 0x05
     86e:	fe 81       	ldd	r31, Y+6	; 0x06
     870:	80 81       	ld	r24, Z
     872:	8f 5f       	subi	r24, 0xFF	; 255
     874:	ed 81       	ldd	r30, Y+5	; 0x05
     876:	fe 81       	ldd	r31, Y+6	; 0x06
     878:	80 83       	st	Z, r24
}
     87a:	28 96       	adiw	r28, 0x08	; 8
     87c:	0f b6       	in	r0, 0x3f	; 63
     87e:	f8 94       	cli
     880:	de bf       	out	0x3e, r29	; 62
     882:	0f be       	out	0x3f, r0	; 63
     884:	cd bf       	out	0x3d, r28	; 61
     886:	cf 91       	pop	r28
     888:	df 91       	pop	r29
     88a:	08 95       	ret

0000088c <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     88c:	df 93       	push	r29
     88e:	cf 93       	push	r28
     890:	00 d0       	rcall	.+0      	; 0x892 <vListRemove+0x6>
     892:	00 d0       	rcall	.+0      	; 0x894 <vListRemove+0x8>
     894:	cd b7       	in	r28, 0x3d	; 61
     896:	de b7       	in	r29, 0x3e	; 62
     898:	9c 83       	std	Y+4, r25	; 0x04
     89a:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     89c:	eb 81       	ldd	r30, Y+3	; 0x03
     89e:	fc 81       	ldd	r31, Y+4	; 0x04
     8a0:	a2 81       	ldd	r26, Z+2	; 0x02
     8a2:	b3 81       	ldd	r27, Z+3	; 0x03
     8a4:	eb 81       	ldd	r30, Y+3	; 0x03
     8a6:	fc 81       	ldd	r31, Y+4	; 0x04
     8a8:	84 81       	ldd	r24, Z+4	; 0x04
     8aa:	95 81       	ldd	r25, Z+5	; 0x05
     8ac:	15 96       	adiw	r26, 0x05	; 5
     8ae:	9c 93       	st	X, r25
     8b0:	8e 93       	st	-X, r24
     8b2:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     8b4:	eb 81       	ldd	r30, Y+3	; 0x03
     8b6:	fc 81       	ldd	r31, Y+4	; 0x04
     8b8:	a4 81       	ldd	r26, Z+4	; 0x04
     8ba:	b5 81       	ldd	r27, Z+5	; 0x05
     8bc:	eb 81       	ldd	r30, Y+3	; 0x03
     8be:	fc 81       	ldd	r31, Y+4	; 0x04
     8c0:	82 81       	ldd	r24, Z+2	; 0x02
     8c2:	93 81       	ldd	r25, Z+3	; 0x03
     8c4:	13 96       	adiw	r26, 0x03	; 3
     8c6:	9c 93       	st	X, r25
     8c8:	8e 93       	st	-X, r24
     8ca:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     8cc:	eb 81       	ldd	r30, Y+3	; 0x03
     8ce:	fc 81       	ldd	r31, Y+4	; 0x04
     8d0:	80 85       	ldd	r24, Z+8	; 0x08
     8d2:	91 85       	ldd	r25, Z+9	; 0x09
     8d4:	9a 83       	std	Y+2, r25	; 0x02
     8d6:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     8d8:	e9 81       	ldd	r30, Y+1	; 0x01
     8da:	fa 81       	ldd	r31, Y+2	; 0x02
     8dc:	21 81       	ldd	r18, Z+1	; 0x01
     8de:	32 81       	ldd	r19, Z+2	; 0x02
     8e0:	8b 81       	ldd	r24, Y+3	; 0x03
     8e2:	9c 81       	ldd	r25, Y+4	; 0x04
     8e4:	28 17       	cp	r18, r24
     8e6:	39 07       	cpc	r19, r25
     8e8:	41 f4       	brne	.+16     	; 0x8fa <vListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     8ea:	eb 81       	ldd	r30, Y+3	; 0x03
     8ec:	fc 81       	ldd	r31, Y+4	; 0x04
     8ee:	84 81       	ldd	r24, Z+4	; 0x04
     8f0:	95 81       	ldd	r25, Z+5	; 0x05
     8f2:	e9 81       	ldd	r30, Y+1	; 0x01
     8f4:	fa 81       	ldd	r31, Y+2	; 0x02
     8f6:	92 83       	std	Z+2, r25	; 0x02
     8f8:	81 83       	std	Z+1, r24	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
     8fa:	eb 81       	ldd	r30, Y+3	; 0x03
     8fc:	fc 81       	ldd	r31, Y+4	; 0x04
     8fe:	11 86       	std	Z+9, r1	; 0x09
     900:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     902:	e9 81       	ldd	r30, Y+1	; 0x01
     904:	fa 81       	ldd	r31, Y+2	; 0x02
     906:	80 81       	ld	r24, Z
     908:	81 50       	subi	r24, 0x01	; 1
     90a:	e9 81       	ldd	r30, Y+1	; 0x01
     90c:	fa 81       	ldd	r31, Y+2	; 0x02
     90e:	80 83       	st	Z, r24
}
     910:	0f 90       	pop	r0
     912:	0f 90       	pop	r0
     914:	0f 90       	pop	r0
     916:	0f 90       	pop	r0
     918:	cf 91       	pop	r28
     91a:	df 91       	pop	r29
     91c:	08 95       	ret

0000091e <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
     91e:	df 93       	push	r29
     920:	cf 93       	push	r28
     922:	cd b7       	in	r28, 0x3d	; 61
     924:	de b7       	in	r29, 0x3e	; 62
     926:	28 97       	sbiw	r28, 0x08	; 8
     928:	0f b6       	in	r0, 0x3f	; 63
     92a:	f8 94       	cli
     92c:	de bf       	out	0x3e, r29	; 62
     92e:	0f be       	out	0x3f, r0	; 63
     930:	cd bf       	out	0x3d, r28	; 61
     932:	9c 83       	std	Y+4, r25	; 0x04
     934:	8b 83       	std	Y+3, r24	; 0x03
     936:	7e 83       	std	Y+6, r23	; 0x06
     938:	6d 83       	std	Y+5, r22	; 0x05
     93a:	58 87       	std	Y+8, r21	; 0x08
     93c:	4f 83       	std	Y+7, r20	; 0x07
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     93e:	eb 81       	ldd	r30, Y+3	; 0x03
     940:	fc 81       	ldd	r31, Y+4	; 0x04
     942:	81 e1       	ldi	r24, 0x11	; 17
     944:	80 83       	st	Z, r24
	pxTopOfStack--;
     946:	8b 81       	ldd	r24, Y+3	; 0x03
     948:	9c 81       	ldd	r25, Y+4	; 0x04
     94a:	01 97       	sbiw	r24, 0x01	; 1
     94c:	9c 83       	std	Y+4, r25	; 0x04
     94e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
     950:	eb 81       	ldd	r30, Y+3	; 0x03
     952:	fc 81       	ldd	r31, Y+4	; 0x04
     954:	82 e2       	ldi	r24, 0x22	; 34
     956:	80 83       	st	Z, r24
	pxTopOfStack--;
     958:	8b 81       	ldd	r24, Y+3	; 0x03
     95a:	9c 81       	ldd	r25, Y+4	; 0x04
     95c:	01 97       	sbiw	r24, 0x01	; 1
     95e:	9c 83       	std	Y+4, r25	; 0x04
     960:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
     962:	eb 81       	ldd	r30, Y+3	; 0x03
     964:	fc 81       	ldd	r31, Y+4	; 0x04
     966:	83 e3       	ldi	r24, 0x33	; 51
     968:	80 83       	st	Z, r24
	pxTopOfStack--;
     96a:	8b 81       	ldd	r24, Y+3	; 0x03
     96c:	9c 81       	ldd	r25, Y+4	; 0x04
     96e:	01 97       	sbiw	r24, 0x01	; 1
     970:	9c 83       	std	Y+4, r25	; 0x04
     972:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
     974:	8d 81       	ldd	r24, Y+5	; 0x05
     976:	9e 81       	ldd	r25, Y+6	; 0x06
     978:	9a 83       	std	Y+2, r25	; 0x02
     97a:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     97c:	89 81       	ldd	r24, Y+1	; 0x01
     97e:	eb 81       	ldd	r30, Y+3	; 0x03
     980:	fc 81       	ldd	r31, Y+4	; 0x04
     982:	80 83       	st	Z, r24
	pxTopOfStack--;
     984:	8b 81       	ldd	r24, Y+3	; 0x03
     986:	9c 81       	ldd	r25, Y+4	; 0x04
     988:	01 97       	sbiw	r24, 0x01	; 1
     98a:	9c 83       	std	Y+4, r25	; 0x04
     98c:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     98e:	89 81       	ldd	r24, Y+1	; 0x01
     990:	9a 81       	ldd	r25, Y+2	; 0x02
     992:	89 2f       	mov	r24, r25
     994:	99 27       	eor	r25, r25
     996:	9a 83       	std	Y+2, r25	; 0x02
     998:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     99a:	89 81       	ldd	r24, Y+1	; 0x01
     99c:	eb 81       	ldd	r30, Y+3	; 0x03
     99e:	fc 81       	ldd	r31, Y+4	; 0x04
     9a0:	80 83       	st	Z, r24
	pxTopOfStack--;
     9a2:	8b 81       	ldd	r24, Y+3	; 0x03
     9a4:	9c 81       	ldd	r25, Y+4	; 0x04
     9a6:	01 97       	sbiw	r24, 0x01	; 1
     9a8:	9c 83       	std	Y+4, r25	; 0x04
     9aa:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
     9ac:	eb 81       	ldd	r30, Y+3	; 0x03
     9ae:	fc 81       	ldd	r31, Y+4	; 0x04
     9b0:	10 82       	st	Z, r1
	pxTopOfStack--;
     9b2:	8b 81       	ldd	r24, Y+3	; 0x03
     9b4:	9c 81       	ldd	r25, Y+4	; 0x04
     9b6:	01 97       	sbiw	r24, 0x01	; 1
     9b8:	9c 83       	std	Y+4, r25	; 0x04
     9ba:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     9bc:	eb 81       	ldd	r30, Y+3	; 0x03
     9be:	fc 81       	ldd	r31, Y+4	; 0x04
     9c0:	80 e8       	ldi	r24, 0x80	; 128
     9c2:	80 83       	st	Z, r24
	pxTopOfStack--;
     9c4:	8b 81       	ldd	r24, Y+3	; 0x03
     9c6:	9c 81       	ldd	r25, Y+4	; 0x04
     9c8:	01 97       	sbiw	r24, 0x01	; 1
     9ca:	9c 83       	std	Y+4, r25	; 0x04
     9cc:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
     9ce:	eb 81       	ldd	r30, Y+3	; 0x03
     9d0:	fc 81       	ldd	r31, Y+4	; 0x04
     9d2:	10 82       	st	Z, r1
	pxTopOfStack--;
     9d4:	8b 81       	ldd	r24, Y+3	; 0x03
     9d6:	9c 81       	ldd	r25, Y+4	; 0x04
     9d8:	01 97       	sbiw	r24, 0x01	; 1
     9da:	9c 83       	std	Y+4, r25	; 0x04
     9dc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
     9de:	eb 81       	ldd	r30, Y+3	; 0x03
     9e0:	fc 81       	ldd	r31, Y+4	; 0x04
     9e2:	82 e0       	ldi	r24, 0x02	; 2
     9e4:	80 83       	st	Z, r24
	pxTopOfStack--;
     9e6:	8b 81       	ldd	r24, Y+3	; 0x03
     9e8:	9c 81       	ldd	r25, Y+4	; 0x04
     9ea:	01 97       	sbiw	r24, 0x01	; 1
     9ec:	9c 83       	std	Y+4, r25	; 0x04
     9ee:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
     9f0:	eb 81       	ldd	r30, Y+3	; 0x03
     9f2:	fc 81       	ldd	r31, Y+4	; 0x04
     9f4:	83 e0       	ldi	r24, 0x03	; 3
     9f6:	80 83       	st	Z, r24
	pxTopOfStack--;
     9f8:	8b 81       	ldd	r24, Y+3	; 0x03
     9fa:	9c 81       	ldd	r25, Y+4	; 0x04
     9fc:	01 97       	sbiw	r24, 0x01	; 1
     9fe:	9c 83       	std	Y+4, r25	; 0x04
     a00:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
     a02:	eb 81       	ldd	r30, Y+3	; 0x03
     a04:	fc 81       	ldd	r31, Y+4	; 0x04
     a06:	84 e0       	ldi	r24, 0x04	; 4
     a08:	80 83       	st	Z, r24
	pxTopOfStack--;
     a0a:	8b 81       	ldd	r24, Y+3	; 0x03
     a0c:	9c 81       	ldd	r25, Y+4	; 0x04
     a0e:	01 97       	sbiw	r24, 0x01	; 1
     a10:	9c 83       	std	Y+4, r25	; 0x04
     a12:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
     a14:	eb 81       	ldd	r30, Y+3	; 0x03
     a16:	fc 81       	ldd	r31, Y+4	; 0x04
     a18:	85 e0       	ldi	r24, 0x05	; 5
     a1a:	80 83       	st	Z, r24
	pxTopOfStack--;
     a1c:	8b 81       	ldd	r24, Y+3	; 0x03
     a1e:	9c 81       	ldd	r25, Y+4	; 0x04
     a20:	01 97       	sbiw	r24, 0x01	; 1
     a22:	9c 83       	std	Y+4, r25	; 0x04
     a24:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
     a26:	eb 81       	ldd	r30, Y+3	; 0x03
     a28:	fc 81       	ldd	r31, Y+4	; 0x04
     a2a:	86 e0       	ldi	r24, 0x06	; 6
     a2c:	80 83       	st	Z, r24
	pxTopOfStack--;
     a2e:	8b 81       	ldd	r24, Y+3	; 0x03
     a30:	9c 81       	ldd	r25, Y+4	; 0x04
     a32:	01 97       	sbiw	r24, 0x01	; 1
     a34:	9c 83       	std	Y+4, r25	; 0x04
     a36:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
     a38:	eb 81       	ldd	r30, Y+3	; 0x03
     a3a:	fc 81       	ldd	r31, Y+4	; 0x04
     a3c:	87 e0       	ldi	r24, 0x07	; 7
     a3e:	80 83       	st	Z, r24
	pxTopOfStack--;
     a40:	8b 81       	ldd	r24, Y+3	; 0x03
     a42:	9c 81       	ldd	r25, Y+4	; 0x04
     a44:	01 97       	sbiw	r24, 0x01	; 1
     a46:	9c 83       	std	Y+4, r25	; 0x04
     a48:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
     a4a:	eb 81       	ldd	r30, Y+3	; 0x03
     a4c:	fc 81       	ldd	r31, Y+4	; 0x04
     a4e:	88 e0       	ldi	r24, 0x08	; 8
     a50:	80 83       	st	Z, r24
	pxTopOfStack--;
     a52:	8b 81       	ldd	r24, Y+3	; 0x03
     a54:	9c 81       	ldd	r25, Y+4	; 0x04
     a56:	01 97       	sbiw	r24, 0x01	; 1
     a58:	9c 83       	std	Y+4, r25	; 0x04
     a5a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
     a5c:	eb 81       	ldd	r30, Y+3	; 0x03
     a5e:	fc 81       	ldd	r31, Y+4	; 0x04
     a60:	89 e0       	ldi	r24, 0x09	; 9
     a62:	80 83       	st	Z, r24
	pxTopOfStack--;
     a64:	8b 81       	ldd	r24, Y+3	; 0x03
     a66:	9c 81       	ldd	r25, Y+4	; 0x04
     a68:	01 97       	sbiw	r24, 0x01	; 1
     a6a:	9c 83       	std	Y+4, r25	; 0x04
     a6c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
     a6e:	eb 81       	ldd	r30, Y+3	; 0x03
     a70:	fc 81       	ldd	r31, Y+4	; 0x04
     a72:	80 e1       	ldi	r24, 0x10	; 16
     a74:	80 83       	st	Z, r24
	pxTopOfStack--;
     a76:	8b 81       	ldd	r24, Y+3	; 0x03
     a78:	9c 81       	ldd	r25, Y+4	; 0x04
     a7a:	01 97       	sbiw	r24, 0x01	; 1
     a7c:	9c 83       	std	Y+4, r25	; 0x04
     a7e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
     a80:	eb 81       	ldd	r30, Y+3	; 0x03
     a82:	fc 81       	ldd	r31, Y+4	; 0x04
     a84:	81 e1       	ldi	r24, 0x11	; 17
     a86:	80 83       	st	Z, r24
	pxTopOfStack--;
     a88:	8b 81       	ldd	r24, Y+3	; 0x03
     a8a:	9c 81       	ldd	r25, Y+4	; 0x04
     a8c:	01 97       	sbiw	r24, 0x01	; 1
     a8e:	9c 83       	std	Y+4, r25	; 0x04
     a90:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
     a92:	eb 81       	ldd	r30, Y+3	; 0x03
     a94:	fc 81       	ldd	r31, Y+4	; 0x04
     a96:	82 e1       	ldi	r24, 0x12	; 18
     a98:	80 83       	st	Z, r24
	pxTopOfStack--;
     a9a:	8b 81       	ldd	r24, Y+3	; 0x03
     a9c:	9c 81       	ldd	r25, Y+4	; 0x04
     a9e:	01 97       	sbiw	r24, 0x01	; 1
     aa0:	9c 83       	std	Y+4, r25	; 0x04
     aa2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
     aa4:	eb 81       	ldd	r30, Y+3	; 0x03
     aa6:	fc 81       	ldd	r31, Y+4	; 0x04
     aa8:	83 e1       	ldi	r24, 0x13	; 19
     aaa:	80 83       	st	Z, r24
	pxTopOfStack--;
     aac:	8b 81       	ldd	r24, Y+3	; 0x03
     aae:	9c 81       	ldd	r25, Y+4	; 0x04
     ab0:	01 97       	sbiw	r24, 0x01	; 1
     ab2:	9c 83       	std	Y+4, r25	; 0x04
     ab4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
     ab6:	eb 81       	ldd	r30, Y+3	; 0x03
     ab8:	fc 81       	ldd	r31, Y+4	; 0x04
     aba:	84 e1       	ldi	r24, 0x14	; 20
     abc:	80 83       	st	Z, r24
	pxTopOfStack--;
     abe:	8b 81       	ldd	r24, Y+3	; 0x03
     ac0:	9c 81       	ldd	r25, Y+4	; 0x04
     ac2:	01 97       	sbiw	r24, 0x01	; 1
     ac4:	9c 83       	std	Y+4, r25	; 0x04
     ac6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
     ac8:	eb 81       	ldd	r30, Y+3	; 0x03
     aca:	fc 81       	ldd	r31, Y+4	; 0x04
     acc:	85 e1       	ldi	r24, 0x15	; 21
     ace:	80 83       	st	Z, r24
	pxTopOfStack--;
     ad0:	8b 81       	ldd	r24, Y+3	; 0x03
     ad2:	9c 81       	ldd	r25, Y+4	; 0x04
     ad4:	01 97       	sbiw	r24, 0x01	; 1
     ad6:	9c 83       	std	Y+4, r25	; 0x04
     ad8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
     ada:	eb 81       	ldd	r30, Y+3	; 0x03
     adc:	fc 81       	ldd	r31, Y+4	; 0x04
     ade:	86 e1       	ldi	r24, 0x16	; 22
     ae0:	80 83       	st	Z, r24
	pxTopOfStack--;
     ae2:	8b 81       	ldd	r24, Y+3	; 0x03
     ae4:	9c 81       	ldd	r25, Y+4	; 0x04
     ae6:	01 97       	sbiw	r24, 0x01	; 1
     ae8:	9c 83       	std	Y+4, r25	; 0x04
     aea:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
     aec:	eb 81       	ldd	r30, Y+3	; 0x03
     aee:	fc 81       	ldd	r31, Y+4	; 0x04
     af0:	87 e1       	ldi	r24, 0x17	; 23
     af2:	80 83       	st	Z, r24
	pxTopOfStack--;
     af4:	8b 81       	ldd	r24, Y+3	; 0x03
     af6:	9c 81       	ldd	r25, Y+4	; 0x04
     af8:	01 97       	sbiw	r24, 0x01	; 1
     afa:	9c 83       	std	Y+4, r25	; 0x04
     afc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
     afe:	eb 81       	ldd	r30, Y+3	; 0x03
     b00:	fc 81       	ldd	r31, Y+4	; 0x04
     b02:	88 e1       	ldi	r24, 0x18	; 24
     b04:	80 83       	st	Z, r24
	pxTopOfStack--;
     b06:	8b 81       	ldd	r24, Y+3	; 0x03
     b08:	9c 81       	ldd	r25, Y+4	; 0x04
     b0a:	01 97       	sbiw	r24, 0x01	; 1
     b0c:	9c 83       	std	Y+4, r25	; 0x04
     b0e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
     b10:	eb 81       	ldd	r30, Y+3	; 0x03
     b12:	fc 81       	ldd	r31, Y+4	; 0x04
     b14:	89 e1       	ldi	r24, 0x19	; 25
     b16:	80 83       	st	Z, r24
	pxTopOfStack--;
     b18:	8b 81       	ldd	r24, Y+3	; 0x03
     b1a:	9c 81       	ldd	r25, Y+4	; 0x04
     b1c:	01 97       	sbiw	r24, 0x01	; 1
     b1e:	9c 83       	std	Y+4, r25	; 0x04
     b20:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
     b22:	eb 81       	ldd	r30, Y+3	; 0x03
     b24:	fc 81       	ldd	r31, Y+4	; 0x04
     b26:	80 e2       	ldi	r24, 0x20	; 32
     b28:	80 83       	st	Z, r24
	pxTopOfStack--;
     b2a:	8b 81       	ldd	r24, Y+3	; 0x03
     b2c:	9c 81       	ldd	r25, Y+4	; 0x04
     b2e:	01 97       	sbiw	r24, 0x01	; 1
     b30:	9c 83       	std	Y+4, r25	; 0x04
     b32:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
     b34:	eb 81       	ldd	r30, Y+3	; 0x03
     b36:	fc 81       	ldd	r31, Y+4	; 0x04
     b38:	81 e2       	ldi	r24, 0x21	; 33
     b3a:	80 83       	st	Z, r24
	pxTopOfStack--;
     b3c:	8b 81       	ldd	r24, Y+3	; 0x03
     b3e:	9c 81       	ldd	r25, Y+4	; 0x04
     b40:	01 97       	sbiw	r24, 0x01	; 1
     b42:	9c 83       	std	Y+4, r25	; 0x04
     b44:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
     b46:	eb 81       	ldd	r30, Y+3	; 0x03
     b48:	fc 81       	ldd	r31, Y+4	; 0x04
     b4a:	82 e2       	ldi	r24, 0x22	; 34
     b4c:	80 83       	st	Z, r24
	pxTopOfStack--;
     b4e:	8b 81       	ldd	r24, Y+3	; 0x03
     b50:	9c 81       	ldd	r25, Y+4	; 0x04
     b52:	01 97       	sbiw	r24, 0x01	; 1
     b54:	9c 83       	std	Y+4, r25	; 0x04
     b56:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
     b58:	eb 81       	ldd	r30, Y+3	; 0x03
     b5a:	fc 81       	ldd	r31, Y+4	; 0x04
     b5c:	83 e2       	ldi	r24, 0x23	; 35
     b5e:	80 83       	st	Z, r24
	pxTopOfStack--;
     b60:	8b 81       	ldd	r24, Y+3	; 0x03
     b62:	9c 81       	ldd	r25, Y+4	; 0x04
     b64:	01 97       	sbiw	r24, 0x01	; 1
     b66:	9c 83       	std	Y+4, r25	; 0x04
     b68:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
     b6a:	8f 81       	ldd	r24, Y+7	; 0x07
     b6c:	98 85       	ldd	r25, Y+8	; 0x08
     b6e:	9a 83       	std	Y+2, r25	; 0x02
     b70:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     b72:	89 81       	ldd	r24, Y+1	; 0x01
     b74:	eb 81       	ldd	r30, Y+3	; 0x03
     b76:	fc 81       	ldd	r31, Y+4	; 0x04
     b78:	80 83       	st	Z, r24
	pxTopOfStack--;
     b7a:	8b 81       	ldd	r24, Y+3	; 0x03
     b7c:	9c 81       	ldd	r25, Y+4	; 0x04
     b7e:	01 97       	sbiw	r24, 0x01	; 1
     b80:	9c 83       	std	Y+4, r25	; 0x04
     b82:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     b84:	89 81       	ldd	r24, Y+1	; 0x01
     b86:	9a 81       	ldd	r25, Y+2	; 0x02
     b88:	89 2f       	mov	r24, r25
     b8a:	99 27       	eor	r25, r25
     b8c:	9a 83       	std	Y+2, r25	; 0x02
     b8e:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     b90:	89 81       	ldd	r24, Y+1	; 0x01
     b92:	eb 81       	ldd	r30, Y+3	; 0x03
     b94:	fc 81       	ldd	r31, Y+4	; 0x04
     b96:	80 83       	st	Z, r24
	pxTopOfStack--;
     b98:	8b 81       	ldd	r24, Y+3	; 0x03
     b9a:	9c 81       	ldd	r25, Y+4	; 0x04
     b9c:	01 97       	sbiw	r24, 0x01	; 1
     b9e:	9c 83       	std	Y+4, r25	; 0x04
     ba0:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
     ba2:	eb 81       	ldd	r30, Y+3	; 0x03
     ba4:	fc 81       	ldd	r31, Y+4	; 0x04
     ba6:	86 e2       	ldi	r24, 0x26	; 38
     ba8:	80 83       	st	Z, r24
	pxTopOfStack--;
     baa:	8b 81       	ldd	r24, Y+3	; 0x03
     bac:	9c 81       	ldd	r25, Y+4	; 0x04
     bae:	01 97       	sbiw	r24, 0x01	; 1
     bb0:	9c 83       	std	Y+4, r25	; 0x04
     bb2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
     bb4:	eb 81       	ldd	r30, Y+3	; 0x03
     bb6:	fc 81       	ldd	r31, Y+4	; 0x04
     bb8:	87 e2       	ldi	r24, 0x27	; 39
     bba:	80 83       	st	Z, r24
	pxTopOfStack--;
     bbc:	8b 81       	ldd	r24, Y+3	; 0x03
     bbe:	9c 81       	ldd	r25, Y+4	; 0x04
     bc0:	01 97       	sbiw	r24, 0x01	; 1
     bc2:	9c 83       	std	Y+4, r25	; 0x04
     bc4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
     bc6:	eb 81       	ldd	r30, Y+3	; 0x03
     bc8:	fc 81       	ldd	r31, Y+4	; 0x04
     bca:	88 e2       	ldi	r24, 0x28	; 40
     bcc:	80 83       	st	Z, r24
	pxTopOfStack--;
     bce:	8b 81       	ldd	r24, Y+3	; 0x03
     bd0:	9c 81       	ldd	r25, Y+4	; 0x04
     bd2:	01 97       	sbiw	r24, 0x01	; 1
     bd4:	9c 83       	std	Y+4, r25	; 0x04
     bd6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
     bd8:	eb 81       	ldd	r30, Y+3	; 0x03
     bda:	fc 81       	ldd	r31, Y+4	; 0x04
     bdc:	89 e2       	ldi	r24, 0x29	; 41
     bde:	80 83       	st	Z, r24
	pxTopOfStack--;
     be0:	8b 81       	ldd	r24, Y+3	; 0x03
     be2:	9c 81       	ldd	r25, Y+4	; 0x04
     be4:	01 97       	sbiw	r24, 0x01	; 1
     be6:	9c 83       	std	Y+4, r25	; 0x04
     be8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
     bea:	eb 81       	ldd	r30, Y+3	; 0x03
     bec:	fc 81       	ldd	r31, Y+4	; 0x04
     bee:	80 e3       	ldi	r24, 0x30	; 48
     bf0:	80 83       	st	Z, r24
	pxTopOfStack--;
     bf2:	8b 81       	ldd	r24, Y+3	; 0x03
     bf4:	9c 81       	ldd	r25, Y+4	; 0x04
     bf6:	01 97       	sbiw	r24, 0x01	; 1
     bf8:	9c 83       	std	Y+4, r25	; 0x04
     bfa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
     bfc:	eb 81       	ldd	r30, Y+3	; 0x03
     bfe:	fc 81       	ldd	r31, Y+4	; 0x04
     c00:	81 e3       	ldi	r24, 0x31	; 49
     c02:	80 83       	st	Z, r24
	pxTopOfStack--;
     c04:	8b 81       	ldd	r24, Y+3	; 0x03
     c06:	9c 81       	ldd	r25, Y+4	; 0x04
     c08:	01 97       	sbiw	r24, 0x01	; 1
     c0a:	9c 83       	std	Y+4, r25	; 0x04
     c0c:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
     c0e:	8b 81       	ldd	r24, Y+3	; 0x03
     c10:	9c 81       	ldd	r25, Y+4	; 0x04
}
     c12:	28 96       	adiw	r28, 0x08	; 8
     c14:	0f b6       	in	r0, 0x3f	; 63
     c16:	f8 94       	cli
     c18:	de bf       	out	0x3e, r29	; 62
     c1a:	0f be       	out	0x3f, r0	; 63
     c1c:	cd bf       	out	0x3d, r28	; 61
     c1e:	cf 91       	pop	r28
     c20:	df 91       	pop	r29
     c22:	08 95       	ret

00000c24 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
     c24:	df 93       	push	r29
     c26:	cf 93       	push	r28
     c28:	cd b7       	in	r28, 0x3d	; 61
     c2a:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
     c2c:	0e 94 02 07 	call	0xe04	; 0xe04 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     c30:	a0 91 bc 00 	lds	r26, 0x00BC
     c34:	b0 91 bd 00 	lds	r27, 0x00BD
     c38:	cd 91       	ld	r28, X+
     c3a:	cd bf       	out	0x3d, r28	; 61
     c3c:	dd 91       	ld	r29, X+
     c3e:	de bf       	out	0x3e, r29	; 62
     c40:	ff 91       	pop	r31
     c42:	ef 91       	pop	r30
     c44:	df 91       	pop	r29
     c46:	cf 91       	pop	r28
     c48:	bf 91       	pop	r27
     c4a:	af 91       	pop	r26
     c4c:	9f 91       	pop	r25
     c4e:	8f 91       	pop	r24
     c50:	7f 91       	pop	r23
     c52:	6f 91       	pop	r22
     c54:	5f 91       	pop	r21
     c56:	4f 91       	pop	r20
     c58:	3f 91       	pop	r19
     c5a:	2f 91       	pop	r18
     c5c:	1f 91       	pop	r17
     c5e:	0f 91       	pop	r16
     c60:	ff 90       	pop	r15
     c62:	ef 90       	pop	r14
     c64:	df 90       	pop	r13
     c66:	cf 90       	pop	r12
     c68:	bf 90       	pop	r11
     c6a:	af 90       	pop	r10
     c6c:	9f 90       	pop	r9
     c6e:	8f 90       	pop	r8
     c70:	7f 90       	pop	r7
     c72:	6f 90       	pop	r6
     c74:	5f 90       	pop	r5
     c76:	4f 90       	pop	r4
     c78:	3f 90       	pop	r3
     c7a:	2f 90       	pop	r2
     c7c:	1f 90       	pop	r1
     c7e:	0f 90       	pop	r0
     c80:	0f be       	out	0x3f, r0	; 63
     c82:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     c84:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
     c86:	81 e0       	ldi	r24, 0x01	; 1
}
     c88:	cf 91       	pop	r28
     c8a:	df 91       	pop	r29
     c8c:	08 95       	ret

00000c8e <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     c8e:	df 93       	push	r29
     c90:	cf 93       	push	r28
     c92:	cd b7       	in	r28, 0x3d	; 61
     c94:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
     c96:	cf 91       	pop	r28
     c98:	df 91       	pop	r29
     c9a:	08 95       	ret

00000c9c <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     c9c:	0f 92       	push	r0
     c9e:	0f b6       	in	r0, 0x3f	; 63
     ca0:	f8 94       	cli
     ca2:	0f 92       	push	r0
     ca4:	1f 92       	push	r1
     ca6:	11 24       	eor	r1, r1
     ca8:	2f 92       	push	r2
     caa:	3f 92       	push	r3
     cac:	4f 92       	push	r4
     cae:	5f 92       	push	r5
     cb0:	6f 92       	push	r6
     cb2:	7f 92       	push	r7
     cb4:	8f 92       	push	r8
     cb6:	9f 92       	push	r9
     cb8:	af 92       	push	r10
     cba:	bf 92       	push	r11
     cbc:	cf 92       	push	r12
     cbe:	df 92       	push	r13
     cc0:	ef 92       	push	r14
     cc2:	ff 92       	push	r15
     cc4:	0f 93       	push	r16
     cc6:	1f 93       	push	r17
     cc8:	2f 93       	push	r18
     cca:	3f 93       	push	r19
     ccc:	4f 93       	push	r20
     cce:	5f 93       	push	r21
     cd0:	6f 93       	push	r22
     cd2:	7f 93       	push	r23
     cd4:	8f 93       	push	r24
     cd6:	9f 93       	push	r25
     cd8:	af 93       	push	r26
     cda:	bf 93       	push	r27
     cdc:	cf 93       	push	r28
     cde:	df 93       	push	r29
     ce0:	ef 93       	push	r30
     ce2:	ff 93       	push	r31
     ce4:	a0 91 bc 00 	lds	r26, 0x00BC
     ce8:	b0 91 bd 00 	lds	r27, 0x00BD
     cec:	0d b6       	in	r0, 0x3d	; 61
     cee:	0d 92       	st	X+, r0
     cf0:	0e b6       	in	r0, 0x3e	; 62
     cf2:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     cf4:	0e 94 be 0f 	call	0x1f7c	; 0x1f7c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     cf8:	a0 91 bc 00 	lds	r26, 0x00BC
     cfc:	b0 91 bd 00 	lds	r27, 0x00BD
     d00:	cd 91       	ld	r28, X+
     d02:	cd bf       	out	0x3d, r28	; 61
     d04:	dd 91       	ld	r29, X+
     d06:	de bf       	out	0x3e, r29	; 62
     d08:	ff 91       	pop	r31
     d0a:	ef 91       	pop	r30
     d0c:	df 91       	pop	r29
     d0e:	cf 91       	pop	r28
     d10:	bf 91       	pop	r27
     d12:	af 91       	pop	r26
     d14:	9f 91       	pop	r25
     d16:	8f 91       	pop	r24
     d18:	7f 91       	pop	r23
     d1a:	6f 91       	pop	r22
     d1c:	5f 91       	pop	r21
     d1e:	4f 91       	pop	r20
     d20:	3f 91       	pop	r19
     d22:	2f 91       	pop	r18
     d24:	1f 91       	pop	r17
     d26:	0f 91       	pop	r16
     d28:	ff 90       	pop	r15
     d2a:	ef 90       	pop	r14
     d2c:	df 90       	pop	r13
     d2e:	cf 90       	pop	r12
     d30:	bf 90       	pop	r11
     d32:	af 90       	pop	r10
     d34:	9f 90       	pop	r9
     d36:	8f 90       	pop	r8
     d38:	7f 90       	pop	r7
     d3a:	6f 90       	pop	r6
     d3c:	5f 90       	pop	r5
     d3e:	4f 90       	pop	r4
     d40:	3f 90       	pop	r3
     d42:	2f 90       	pop	r2
     d44:	1f 90       	pop	r1
     d46:	0f 90       	pop	r0
     d48:	0f be       	out	0x3f, r0	; 63
     d4a:	0f 90       	pop	r0

	asm volatile ( "ret" );
     d4c:	08 95       	ret

00000d4e <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     d4e:	0f 92       	push	r0
     d50:	0f b6       	in	r0, 0x3f	; 63
     d52:	f8 94       	cli
     d54:	0f 92       	push	r0
     d56:	1f 92       	push	r1
     d58:	11 24       	eor	r1, r1
     d5a:	2f 92       	push	r2
     d5c:	3f 92       	push	r3
     d5e:	4f 92       	push	r4
     d60:	5f 92       	push	r5
     d62:	6f 92       	push	r6
     d64:	7f 92       	push	r7
     d66:	8f 92       	push	r8
     d68:	9f 92       	push	r9
     d6a:	af 92       	push	r10
     d6c:	bf 92       	push	r11
     d6e:	cf 92       	push	r12
     d70:	df 92       	push	r13
     d72:	ef 92       	push	r14
     d74:	ff 92       	push	r15
     d76:	0f 93       	push	r16
     d78:	1f 93       	push	r17
     d7a:	2f 93       	push	r18
     d7c:	3f 93       	push	r19
     d7e:	4f 93       	push	r20
     d80:	5f 93       	push	r21
     d82:	6f 93       	push	r22
     d84:	7f 93       	push	r23
     d86:	8f 93       	push	r24
     d88:	9f 93       	push	r25
     d8a:	af 93       	push	r26
     d8c:	bf 93       	push	r27
     d8e:	cf 93       	push	r28
     d90:	df 93       	push	r29
     d92:	ef 93       	push	r30
     d94:	ff 93       	push	r31
     d96:	a0 91 bc 00 	lds	r26, 0x00BC
     d9a:	b0 91 bd 00 	lds	r27, 0x00BD
     d9e:	0d b6       	in	r0, 0x3d	; 61
     da0:	0d 92       	st	X+, r0
     da2:	0e b6       	in	r0, 0x3e	; 62
     da4:	0d 92       	st	X+, r0
	vTaskIncrementTick();
     da6:	0e 94 e9 0e 	call	0x1dd2	; 0x1dd2 <vTaskIncrementTick>
	vTaskSwitchContext();
     daa:	0e 94 be 0f 	call	0x1f7c	; 0x1f7c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     dae:	a0 91 bc 00 	lds	r26, 0x00BC
     db2:	b0 91 bd 00 	lds	r27, 0x00BD
     db6:	cd 91       	ld	r28, X+
     db8:	cd bf       	out	0x3d, r28	; 61
     dba:	dd 91       	ld	r29, X+
     dbc:	de bf       	out	0x3e, r29	; 62
     dbe:	ff 91       	pop	r31
     dc0:	ef 91       	pop	r30
     dc2:	df 91       	pop	r29
     dc4:	cf 91       	pop	r28
     dc6:	bf 91       	pop	r27
     dc8:	af 91       	pop	r26
     dca:	9f 91       	pop	r25
     dcc:	8f 91       	pop	r24
     dce:	7f 91       	pop	r23
     dd0:	6f 91       	pop	r22
     dd2:	5f 91       	pop	r21
     dd4:	4f 91       	pop	r20
     dd6:	3f 91       	pop	r19
     dd8:	2f 91       	pop	r18
     dda:	1f 91       	pop	r17
     ddc:	0f 91       	pop	r16
     dde:	ff 90       	pop	r15
     de0:	ef 90       	pop	r14
     de2:	df 90       	pop	r13
     de4:	cf 90       	pop	r12
     de6:	bf 90       	pop	r11
     de8:	af 90       	pop	r10
     dea:	9f 90       	pop	r9
     dec:	8f 90       	pop	r8
     dee:	7f 90       	pop	r7
     df0:	6f 90       	pop	r6
     df2:	5f 90       	pop	r5
     df4:	4f 90       	pop	r4
     df6:	3f 90       	pop	r3
     df8:	2f 90       	pop	r2
     dfa:	1f 90       	pop	r1
     dfc:	0f 90       	pop	r0
     dfe:	0f be       	out	0x3f, r0	; 63
     e00:	0f 90       	pop	r0

	asm volatile ( "ret" );
     e02:	08 95       	ret

00000e04 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
     e04:	df 93       	push	r29
     e06:	cf 93       	push	r28
     e08:	00 d0       	rcall	.+0      	; 0xe0a <prvSetupTimerInterrupt+0x6>
     e0a:	00 d0       	rcall	.+0      	; 0xe0c <prvSetupTimerInterrupt+0x8>
     e0c:	00 d0       	rcall	.+0      	; 0xe0e <prvSetupTimerInterrupt+0xa>
     e0e:	cd b7       	in	r28, 0x3d	; 61
     e10:	de b7       	in	r29, 0x3e	; 62
unsigned char ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
     e12:	80 e4       	ldi	r24, 0x40	; 64
     e14:	9f e1       	ldi	r25, 0x1F	; 31
     e16:	a0 e0       	ldi	r26, 0x00	; 0
     e18:	b0 e0       	ldi	r27, 0x00	; 0
     e1a:	8b 83       	std	Y+3, r24	; 0x03
     e1c:	9c 83       	std	Y+4, r25	; 0x04
     e1e:	ad 83       	std	Y+5, r26	; 0x05
     e20:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
     e22:	8b 81       	ldd	r24, Y+3	; 0x03
     e24:	9c 81       	ldd	r25, Y+4	; 0x04
     e26:	ad 81       	ldd	r26, Y+5	; 0x05
     e28:	be 81       	ldd	r27, Y+6	; 0x06
     e2a:	68 94       	set
     e2c:	15 f8       	bld	r1, 5
     e2e:	b6 95       	lsr	r27
     e30:	a7 95       	ror	r26
     e32:	97 95       	ror	r25
     e34:	87 95       	ror	r24
     e36:	16 94       	lsr	r1
     e38:	d1 f7       	brne	.-12     	; 0xe2e <prvSetupTimerInterrupt+0x2a>
     e3a:	8b 83       	std	Y+3, r24	; 0x03
     e3c:	9c 83       	std	Y+4, r25	; 0x04
     e3e:	ad 83       	std	Y+5, r26	; 0x05
     e40:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( unsigned long ) 1;
     e42:	8b 81       	ldd	r24, Y+3	; 0x03
     e44:	9c 81       	ldd	r25, Y+4	; 0x04
     e46:	ad 81       	ldd	r26, Y+5	; 0x05
     e48:	be 81       	ldd	r27, Y+6	; 0x06
     e4a:	01 97       	sbiw	r24, 0x01	; 1
     e4c:	a1 09       	sbc	r26, r1
     e4e:	b1 09       	sbc	r27, r1
     e50:	8b 83       	std	Y+3, r24	; 0x03
     e52:	9c 83       	std	Y+4, r25	; 0x04
     e54:	ad 83       	std	Y+5, r26	; 0x05
     e56:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
     e58:	8b 81       	ldd	r24, Y+3	; 0x03
     e5a:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
     e5c:	8b 81       	ldd	r24, Y+3	; 0x03
     e5e:	9c 81       	ldd	r25, Y+4	; 0x04
     e60:	ad 81       	ldd	r26, Y+5	; 0x05
     e62:	be 81       	ldd	r27, Y+6	; 0x06
     e64:	89 2f       	mov	r24, r25
     e66:	9a 2f       	mov	r25, r26
     e68:	ab 2f       	mov	r26, r27
     e6a:	bb 27       	eor	r27, r27
     e6c:	8b 83       	std	Y+3, r24	; 0x03
     e6e:	9c 83       	std	Y+4, r25	; 0x04
     e70:	ad 83       	std	Y+5, r26	; 0x05
     e72:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
     e74:	8b 81       	ldd	r24, Y+3	; 0x03
     e76:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
     e78:	eb e4       	ldi	r30, 0x4B	; 75
     e7a:	f0 e0       	ldi	r31, 0x00	; 0
     e7c:	8a 81       	ldd	r24, Y+2	; 0x02
     e7e:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
     e80:	ea e4       	ldi	r30, 0x4A	; 74
     e82:	f0 e0       	ldi	r31, 0x00	; 0
     e84:	89 81       	ldd	r24, Y+1	; 0x01
     e86:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
     e88:	8b e0       	ldi	r24, 0x0B	; 11
     e8a:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
     e8c:	ee e4       	ldi	r30, 0x4E	; 78
     e8e:	f0 e0       	ldi	r31, 0x00	; 0
     e90:	89 81       	ldd	r24, Y+1	; 0x01
     e92:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
     e94:	e9 e5       	ldi	r30, 0x59	; 89
     e96:	f0 e0       	ldi	r31, 0x00	; 0
     e98:	80 81       	ld	r24, Z
     e9a:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     e9c:	89 81       	ldd	r24, Y+1	; 0x01
     e9e:	80 61       	ori	r24, 0x10	; 16
     ea0:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
     ea2:	e9 e5       	ldi	r30, 0x59	; 89
     ea4:	f0 e0       	ldi	r31, 0x00	; 0
     ea6:	89 81       	ldd	r24, Y+1	; 0x01
     ea8:	80 83       	st	Z, r24
}
     eaa:	26 96       	adiw	r28, 0x06	; 6
     eac:	0f b6       	in	r0, 0x3f	; 63
     eae:	f8 94       	cli
     eb0:	de bf       	out	0x3e, r29	; 62
     eb2:	0f be       	out	0x3f, r0	; 63
     eb4:	cd bf       	out	0x3d, r28	; 61
     eb6:	cf 91       	pop	r28
     eb8:	df 91       	pop	r29
     eba:	08 95       	ret

00000ebc <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
     ebc:	0e 94 a7 06 	call	0xd4e	; 0xd4e <vPortYieldFromTick>
		asm volatile ( "reti" );
     ec0:	18 95       	reti

00000ec2 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
     ec2:	df 93       	push	r29
     ec4:	cf 93       	push	r28
     ec6:	cd b7       	in	r28, 0x3d	; 61
     ec8:	de b7       	in	r29, 0x3e	; 62
     eca:	28 97       	sbiw	r28, 0x08	; 8
     ecc:	0f b6       	in	r0, 0x3f	; 63
     ece:	f8 94       	cli
     ed0:	de bf       	out	0x3e, r29	; 62
     ed2:	0f be       	out	0x3f, r0	; 63
     ed4:	cd bf       	out	0x3d, r28	; 61
     ed6:	8f 83       	std	Y+7, r24	; 0x07
     ed8:	68 87       	std	Y+8, r22	; 0x08
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
     eda:	1a 82       	std	Y+2, r1	; 0x02
     edc:	19 82       	std	Y+1, r1	; 0x01

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
     ede:	8f 81       	ldd	r24, Y+7	; 0x07
     ee0:	88 23       	and	r24, r24
     ee2:	09 f4       	brne	.+2      	; 0xee6 <xQueueCreate+0x24>
     ee4:	8c c0       	rjmp	.+280    	; 0xffe <xQueueCreate+0x13c>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
     ee6:	8f e1       	ldi	r24, 0x1F	; 31
     ee8:	90 e0       	ldi	r25, 0x00	; 0
     eea:	0e 94 21 03 	call	0x642	; 0x642 <pvPortMalloc>
     eee:	9e 83       	std	Y+6, r25	; 0x06
     ef0:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
     ef2:	8d 81       	ldd	r24, Y+5	; 0x05
     ef4:	9e 81       	ldd	r25, Y+6	; 0x06
     ef6:	00 97       	sbiw	r24, 0x00	; 0
     ef8:	09 f4       	brne	.+2      	; 0xefc <xQueueCreate+0x3a>
     efa:	81 c0       	rjmp	.+258    	; 0xffe <xQueueCreate+0x13c>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
     efc:	8f 81       	ldd	r24, Y+7	; 0x07
     efe:	28 2f       	mov	r18, r24
     f00:	30 e0       	ldi	r19, 0x00	; 0
     f02:	88 85       	ldd	r24, Y+8	; 0x08
     f04:	88 2f       	mov	r24, r24
     f06:	90 e0       	ldi	r25, 0x00	; 0
     f08:	ac 01       	movw	r20, r24
     f0a:	24 9f       	mul	r18, r20
     f0c:	c0 01       	movw	r24, r0
     f0e:	25 9f       	mul	r18, r21
     f10:	90 0d       	add	r25, r0
     f12:	34 9f       	mul	r19, r20
     f14:	90 0d       	add	r25, r0
     f16:	11 24       	eor	r1, r1
     f18:	01 96       	adiw	r24, 0x01	; 1
     f1a:	9c 83       	std	Y+4, r25	; 0x04
     f1c:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
     f1e:	8b 81       	ldd	r24, Y+3	; 0x03
     f20:	9c 81       	ldd	r25, Y+4	; 0x04
     f22:	0e 94 21 03 	call	0x642	; 0x642 <pvPortMalloc>
     f26:	ed 81       	ldd	r30, Y+5	; 0x05
     f28:	fe 81       	ldd	r31, Y+6	; 0x06
     f2a:	91 83       	std	Z+1, r25	; 0x01
     f2c:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
     f2e:	ed 81       	ldd	r30, Y+5	; 0x05
     f30:	fe 81       	ldd	r31, Y+6	; 0x06
     f32:	80 81       	ld	r24, Z
     f34:	91 81       	ldd	r25, Z+1	; 0x01
     f36:	00 97       	sbiw	r24, 0x00	; 0
     f38:	09 f4       	brne	.+2      	; 0xf3c <xQueueCreate+0x7a>
     f3a:	5d c0       	rjmp	.+186    	; 0xff6 <xQueueCreate+0x134>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
     f3c:	ed 81       	ldd	r30, Y+5	; 0x05
     f3e:	fe 81       	ldd	r31, Y+6	; 0x06
     f40:	40 81       	ld	r20, Z
     f42:	51 81       	ldd	r21, Z+1	; 0x01
     f44:	8f 81       	ldd	r24, Y+7	; 0x07
     f46:	28 2f       	mov	r18, r24
     f48:	30 e0       	ldi	r19, 0x00	; 0
     f4a:	88 85       	ldd	r24, Y+8	; 0x08
     f4c:	88 2f       	mov	r24, r24
     f4e:	90 e0       	ldi	r25, 0x00	; 0
     f50:	bc 01       	movw	r22, r24
     f52:	26 9f       	mul	r18, r22
     f54:	c0 01       	movw	r24, r0
     f56:	27 9f       	mul	r18, r23
     f58:	90 0d       	add	r25, r0
     f5a:	36 9f       	mul	r19, r22
     f5c:	90 0d       	add	r25, r0
     f5e:	11 24       	eor	r1, r1
     f60:	84 0f       	add	r24, r20
     f62:	95 1f       	adc	r25, r21
     f64:	ed 81       	ldd	r30, Y+5	; 0x05
     f66:	fe 81       	ldd	r31, Y+6	; 0x06
     f68:	93 83       	std	Z+3, r25	; 0x03
     f6a:	82 83       	std	Z+2, r24	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
     f6c:	ed 81       	ldd	r30, Y+5	; 0x05
     f6e:	fe 81       	ldd	r31, Y+6	; 0x06
     f70:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
     f72:	ed 81       	ldd	r30, Y+5	; 0x05
     f74:	fe 81       	ldd	r31, Y+6	; 0x06
     f76:	80 81       	ld	r24, Z
     f78:	91 81       	ldd	r25, Z+1	; 0x01
     f7a:	ed 81       	ldd	r30, Y+5	; 0x05
     f7c:	fe 81       	ldd	r31, Y+6	; 0x06
     f7e:	95 83       	std	Z+5, r25	; 0x05
     f80:	84 83       	std	Z+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
     f82:	ed 81       	ldd	r30, Y+5	; 0x05
     f84:	fe 81       	ldd	r31, Y+6	; 0x06
     f86:	40 81       	ld	r20, Z
     f88:	51 81       	ldd	r21, Z+1	; 0x01
     f8a:	8f 81       	ldd	r24, Y+7	; 0x07
     f8c:	88 2f       	mov	r24, r24
     f8e:	90 e0       	ldi	r25, 0x00	; 0
     f90:	9c 01       	movw	r18, r24
     f92:	21 50       	subi	r18, 0x01	; 1
     f94:	30 40       	sbci	r19, 0x00	; 0
     f96:	88 85       	ldd	r24, Y+8	; 0x08
     f98:	88 2f       	mov	r24, r24
     f9a:	90 e0       	ldi	r25, 0x00	; 0
     f9c:	bc 01       	movw	r22, r24
     f9e:	26 9f       	mul	r18, r22
     fa0:	c0 01       	movw	r24, r0
     fa2:	27 9f       	mul	r18, r23
     fa4:	90 0d       	add	r25, r0
     fa6:	36 9f       	mul	r19, r22
     fa8:	90 0d       	add	r25, r0
     faa:	11 24       	eor	r1, r1
     fac:	84 0f       	add	r24, r20
     fae:	95 1f       	adc	r25, r21
     fb0:	ed 81       	ldd	r30, Y+5	; 0x05
     fb2:	fe 81       	ldd	r31, Y+6	; 0x06
     fb4:	97 83       	std	Z+7, r25	; 0x07
     fb6:	86 83       	std	Z+6, r24	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
     fb8:	ed 81       	ldd	r30, Y+5	; 0x05
     fba:	fe 81       	ldd	r31, Y+6	; 0x06
     fbc:	8f 81       	ldd	r24, Y+7	; 0x07
     fbe:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
     fc0:	ed 81       	ldd	r30, Y+5	; 0x05
     fc2:	fe 81       	ldd	r31, Y+6	; 0x06
     fc4:	88 85       	ldd	r24, Y+8	; 0x08
     fc6:	84 8f       	std	Z+28, r24	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
     fc8:	ed 81       	ldd	r30, Y+5	; 0x05
     fca:	fe 81       	ldd	r31, Y+6	; 0x06
     fcc:	8f ef       	ldi	r24, 0xFF	; 255
     fce:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
     fd0:	ed 81       	ldd	r30, Y+5	; 0x05
     fd2:	fe 81       	ldd	r31, Y+6	; 0x06
     fd4:	8f ef       	ldi	r24, 0xFF	; 255
     fd6:	86 8f       	std	Z+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
     fd8:	8d 81       	ldd	r24, Y+5	; 0x05
     fda:	9e 81       	ldd	r25, Y+6	; 0x06
     fdc:	08 96       	adiw	r24, 0x08	; 8
     fde:	0e 94 54 03 	call	0x6a8	; 0x6a8 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
     fe2:	8d 81       	ldd	r24, Y+5	; 0x05
     fe4:	9e 81       	ldd	r25, Y+6	; 0x06
     fe6:	41 96       	adiw	r24, 0x11	; 17
     fe8:	0e 94 54 03 	call	0x6a8	; 0x6a8 <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
     fec:	8d 81       	ldd	r24, Y+5	; 0x05
     fee:	9e 81       	ldd	r25, Y+6	; 0x06
     ff0:	9a 83       	std	Y+2, r25	; 0x02
     ff2:	89 83       	std	Y+1, r24	; 0x01
     ff4:	04 c0       	rjmp	.+8      	; 0xffe <xQueueCreate+0x13c>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
     ff6:	8d 81       	ldd	r24, Y+5	; 0x05
     ff8:	9e 81       	ldd	r25, Y+6	; 0x06
     ffa:	0e 94 3c 03 	call	0x678	; 0x678 <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
     ffe:	89 81       	ldd	r24, Y+1	; 0x01
    1000:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1002:	28 96       	adiw	r28, 0x08	; 8
    1004:	0f b6       	in	r0, 0x3f	; 63
    1006:	f8 94       	cli
    1008:	de bf       	out	0x3e, r29	; 62
    100a:	0f be       	out	0x3f, r0	; 63
    100c:	cd bf       	out	0x3d, r28	; 61
    100e:	cf 91       	pop	r28
    1010:	df 91       	pop	r29
    1012:	08 95       	ret

00001014 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    1014:	df 93       	push	r29
    1016:	cf 93       	push	r28
    1018:	cd b7       	in	r28, 0x3d	; 61
    101a:	de b7       	in	r29, 0x3e	; 62
    101c:	2c 97       	sbiw	r28, 0x0c	; 12
    101e:	0f b6       	in	r0, 0x3f	; 63
    1020:	f8 94       	cli
    1022:	de bf       	out	0x3e, r29	; 62
    1024:	0f be       	out	0x3f, r0	; 63
    1026:	cd bf       	out	0x3d, r28	; 61
    1028:	9e 83       	std	Y+6, r25	; 0x06
    102a:	8d 83       	std	Y+5, r24	; 0x05
    102c:	78 87       	std	Y+8, r23	; 0x08
    102e:	6f 83       	std	Y+7, r22	; 0x07
    1030:	5a 87       	std	Y+10, r21	; 0x0a
    1032:	49 87       	std	Y+9, r20	; 0x09
    1034:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1036:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1038:	0f b6       	in	r0, 0x3f	; 63
    103a:	f8 94       	cli
    103c:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    103e:	ed 81       	ldd	r30, Y+5	; 0x05
    1040:	fe 81       	ldd	r31, Y+6	; 0x06
    1042:	92 8d       	ldd	r25, Z+26	; 0x1a
    1044:	ed 81       	ldd	r30, Y+5	; 0x05
    1046:	fe 81       	ldd	r31, Y+6	; 0x06
    1048:	83 8d       	ldd	r24, Z+27	; 0x1b
    104a:	98 17       	cp	r25, r24
    104c:	d8 f4       	brcc	.+54     	; 0x1084 <xQueueGenericSend+0x70>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    104e:	8d 81       	ldd	r24, Y+5	; 0x05
    1050:	9e 81       	ldd	r25, Y+6	; 0x06
    1052:	2f 81       	ldd	r18, Y+7	; 0x07
    1054:	38 85       	ldd	r19, Y+8	; 0x08
    1056:	b9 01       	movw	r22, r18
    1058:	4b 85       	ldd	r20, Y+11	; 0x0b
    105a:	0e 94 45 0a 	call	0x148a	; 0x148a <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    105e:	ed 81       	ldd	r30, Y+5	; 0x05
    1060:	fe 81       	ldd	r31, Y+6	; 0x06
    1062:	81 89       	ldd	r24, Z+17	; 0x11
    1064:	88 23       	and	r24, r24
    1066:	49 f0       	breq	.+18     	; 0x107a <xQueueGenericSend+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    1068:	8d 81       	ldd	r24, Y+5	; 0x05
    106a:	9e 81       	ldd	r25, Y+6	; 0x06
    106c:	41 96       	adiw	r24, 0x11	; 17
    106e:	0e 94 5a 10 	call	0x20b4	; 0x20b4 <xTaskRemoveFromEventList>
    1072:	81 30       	cpi	r24, 0x01	; 1
    1074:	11 f4       	brne	.+4      	; 0x107a <xQueueGenericSend+0x66>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    1076:	0e 94 4e 06 	call	0xc9c	; 0xc9c <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    107a:	0f 90       	pop	r0
    107c:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    107e:	81 e0       	ldi	r24, 0x01	; 1
    1080:	8c 87       	std	Y+12, r24	; 0x0c
    1082:	5c c0       	rjmp	.+184    	; 0x113c <xQueueGenericSend+0x128>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1084:	89 85       	ldd	r24, Y+9	; 0x09
    1086:	9a 85       	ldd	r25, Y+10	; 0x0a
    1088:	00 97       	sbiw	r24, 0x00	; 0
    108a:	21 f4       	brne	.+8      	; 0x1094 <xQueueGenericSend+0x80>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    108c:	0f 90       	pop	r0
    108e:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1090:	1c 86       	std	Y+12, r1	; 0x0c
    1092:	54 c0       	rjmp	.+168    	; 0x113c <xQueueGenericSend+0x128>
				}
				else if( xEntryTimeSet == pdFALSE )
    1094:	89 81       	ldd	r24, Y+1	; 0x01
    1096:	88 23       	and	r24, r24
    1098:	31 f4       	brne	.+12     	; 0x10a6 <xQueueGenericSend+0x92>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    109a:	ce 01       	movw	r24, r28
    109c:	02 96       	adiw	r24, 0x02	; 2
    109e:	0e 94 c2 10 	call	0x2184	; 0x2184 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    10a2:	81 e0       	ldi	r24, 0x01	; 1
    10a4:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    10a6:	0f 90       	pop	r0
    10a8:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    10aa:	0e 94 1e 0e 	call	0x1c3c	; 0x1c3c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    10ae:	0f b6       	in	r0, 0x3f	; 63
    10b0:	f8 94       	cli
    10b2:	0f 92       	push	r0
    10b4:	ed 81       	ldd	r30, Y+5	; 0x05
    10b6:	fe 81       	ldd	r31, Y+6	; 0x06
    10b8:	85 8d       	ldd	r24, Z+29	; 0x1d
    10ba:	8f 3f       	cpi	r24, 0xFF	; 255
    10bc:	19 f4       	brne	.+6      	; 0x10c4 <xQueueGenericSend+0xb0>
    10be:	ed 81       	ldd	r30, Y+5	; 0x05
    10c0:	fe 81       	ldd	r31, Y+6	; 0x06
    10c2:	15 8e       	std	Z+29, r1	; 0x1d
    10c4:	ed 81       	ldd	r30, Y+5	; 0x05
    10c6:	fe 81       	ldd	r31, Y+6	; 0x06
    10c8:	86 8d       	ldd	r24, Z+30	; 0x1e
    10ca:	8f 3f       	cpi	r24, 0xFF	; 255
    10cc:	19 f4       	brne	.+6      	; 0x10d4 <xQueueGenericSend+0xc0>
    10ce:	ed 81       	ldd	r30, Y+5	; 0x05
    10d0:	fe 81       	ldd	r31, Y+6	; 0x06
    10d2:	16 8e       	std	Z+30, r1	; 0x1e
    10d4:	0f 90       	pop	r0
    10d6:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    10d8:	ce 01       	movw	r24, r28
    10da:	02 96       	adiw	r24, 0x02	; 2
    10dc:	9e 01       	movw	r18, r28
    10de:	27 5f       	subi	r18, 0xF7	; 247
    10e0:	3f 4f       	sbci	r19, 0xFF	; 255
    10e2:	b9 01       	movw	r22, r18
    10e4:	0e 94 db 10 	call	0x21b6	; 0x21b6 <xTaskCheckForTimeOut>
    10e8:	88 23       	and	r24, r24
    10ea:	09 f5       	brne	.+66     	; 0x112e <xQueueGenericSend+0x11a>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    10ec:	8d 81       	ldd	r24, Y+5	; 0x05
    10ee:	9e 81       	ldd	r25, Y+6	; 0x06
    10f0:	0e 94 a9 0b 	call	0x1752	; 0x1752 <prvIsQueueFull>
    10f4:	88 23       	and	r24, r24
    10f6:	a1 f0       	breq	.+40     	; 0x1120 <xQueueGenericSend+0x10c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    10f8:	8d 81       	ldd	r24, Y+5	; 0x05
    10fa:	9e 81       	ldd	r25, Y+6	; 0x06
    10fc:	08 96       	adiw	r24, 0x08	; 8
    10fe:	29 85       	ldd	r18, Y+9	; 0x09
    1100:	3a 85       	ldd	r19, Y+10	; 0x0a
    1102:	b9 01       	movw	r22, r18
    1104:	0e 94 24 10 	call	0x2048	; 0x2048 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1108:	8d 81       	ldd	r24, Y+5	; 0x05
    110a:	9e 81       	ldd	r25, Y+6	; 0x06
    110c:	0e 94 22 0b 	call	0x1644	; 0x1644 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1110:	0e 94 2a 0e 	call	0x1c54	; 0x1c54 <xTaskResumeAll>
    1114:	88 23       	and	r24, r24
    1116:	09 f0       	breq	.+2      	; 0x111a <xQueueGenericSend+0x106>
    1118:	8f cf       	rjmp	.-226    	; 0x1038 <xQueueGenericSend+0x24>
				{
					portYIELD_WITHIN_API();
    111a:	0e 94 4e 06 	call	0xc9c	; 0xc9c <vPortYield>
    111e:	8c cf       	rjmp	.-232    	; 0x1038 <xQueueGenericSend+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1120:	8d 81       	ldd	r24, Y+5	; 0x05
    1122:	9e 81       	ldd	r25, Y+6	; 0x06
    1124:	0e 94 22 0b 	call	0x1644	; 0x1644 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1128:	0e 94 2a 0e 	call	0x1c54	; 0x1c54 <xTaskResumeAll>
    112c:	85 cf       	rjmp	.-246    	; 0x1038 <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    112e:	8d 81       	ldd	r24, Y+5	; 0x05
    1130:	9e 81       	ldd	r25, Y+6	; 0x06
    1132:	0e 94 22 0b 	call	0x1644	; 0x1644 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1136:	0e 94 2a 0e 	call	0x1c54	; 0x1c54 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    113a:	1c 86       	std	Y+12, r1	; 0x0c
    113c:	8c 85       	ldd	r24, Y+12	; 0x0c
		}
	}
}
    113e:	2c 96       	adiw	r28, 0x0c	; 12
    1140:	0f b6       	in	r0, 0x3f	; 63
    1142:	f8 94       	cli
    1144:	de bf       	out	0x3e, r29	; 62
    1146:	0f be       	out	0x3f, r0	; 63
    1148:	cd bf       	out	0x3d, r28	; 61
    114a:	cf 91       	pop	r28
    114c:	df 91       	pop	r29
    114e:	08 95       	ret

00001150 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    1150:	df 93       	push	r29
    1152:	cf 93       	push	r28
    1154:	cd b7       	in	r28, 0x3d	; 61
    1156:	de b7       	in	r29, 0x3e	; 62
    1158:	29 97       	sbiw	r28, 0x09	; 9
    115a:	0f b6       	in	r0, 0x3f	; 63
    115c:	f8 94       	cli
    115e:	de bf       	out	0x3e, r29	; 62
    1160:	0f be       	out	0x3f, r0	; 63
    1162:	cd bf       	out	0x3d, r28	; 61
    1164:	9c 83       	std	Y+4, r25	; 0x04
    1166:	8b 83       	std	Y+3, r24	; 0x03
    1168:	7e 83       	std	Y+6, r23	; 0x06
    116a:	6d 83       	std	Y+5, r22	; 0x05
    116c:	58 87       	std	Y+8, r21	; 0x08
    116e:	4f 83       	std	Y+7, r20	; 0x07
    1170:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1172:	19 82       	std	Y+1, r1	; 0x01
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1174:	eb 81       	ldd	r30, Y+3	; 0x03
    1176:	fc 81       	ldd	r31, Y+4	; 0x04
    1178:	92 8d       	ldd	r25, Z+26	; 0x1a
    117a:	eb 81       	ldd	r30, Y+3	; 0x03
    117c:	fc 81       	ldd	r31, Y+4	; 0x04
    117e:	83 8d       	ldd	r24, Z+27	; 0x1b
    1180:	98 17       	cp	r25, r24
    1182:	40 f5       	brcc	.+80     	; 0x11d4 <xQueueGenericSendFromISR+0x84>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1184:	8b 81       	ldd	r24, Y+3	; 0x03
    1186:	9c 81       	ldd	r25, Y+4	; 0x04
    1188:	2d 81       	ldd	r18, Y+5	; 0x05
    118a:	3e 81       	ldd	r19, Y+6	; 0x06
    118c:	b9 01       	movw	r22, r18
    118e:	49 85       	ldd	r20, Y+9	; 0x09
    1190:	0e 94 45 0a 	call	0x148a	; 0x148a <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1194:	eb 81       	ldd	r30, Y+3	; 0x03
    1196:	fc 81       	ldd	r31, Y+4	; 0x04
    1198:	86 8d       	ldd	r24, Z+30	; 0x1e
    119a:	8f 3f       	cpi	r24, 0xFF	; 255
    119c:	89 f4       	brne	.+34     	; 0x11c0 <xQueueGenericSendFromISR+0x70>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    119e:	eb 81       	ldd	r30, Y+3	; 0x03
    11a0:	fc 81       	ldd	r31, Y+4	; 0x04
    11a2:	81 89       	ldd	r24, Z+17	; 0x11
    11a4:	88 23       	and	r24, r24
    11a6:	99 f0       	breq	.+38     	; 0x11ce <xQueueGenericSendFromISR+0x7e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    11a8:	8b 81       	ldd	r24, Y+3	; 0x03
    11aa:	9c 81       	ldd	r25, Y+4	; 0x04
    11ac:	41 96       	adiw	r24, 0x11	; 17
    11ae:	0e 94 5a 10 	call	0x20b4	; 0x20b4 <xTaskRemoveFromEventList>
    11b2:	88 23       	and	r24, r24
    11b4:	61 f0       	breq	.+24     	; 0x11ce <xQueueGenericSendFromISR+0x7e>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    11b6:	ef 81       	ldd	r30, Y+7	; 0x07
    11b8:	f8 85       	ldd	r31, Y+8	; 0x08
    11ba:	81 e0       	ldi	r24, 0x01	; 1
    11bc:	80 83       	st	Z, r24
    11be:	07 c0       	rjmp	.+14     	; 0x11ce <xQueueGenericSendFromISR+0x7e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    11c0:	eb 81       	ldd	r30, Y+3	; 0x03
    11c2:	fc 81       	ldd	r31, Y+4	; 0x04
    11c4:	86 8d       	ldd	r24, Z+30	; 0x1e
    11c6:	8f 5f       	subi	r24, 0xFF	; 255
    11c8:	eb 81       	ldd	r30, Y+3	; 0x03
    11ca:	fc 81       	ldd	r31, Y+4	; 0x04
    11cc:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    11ce:	81 e0       	ldi	r24, 0x01	; 1
    11d0:	8a 83       	std	Y+2, r24	; 0x02
    11d2:	01 c0       	rjmp	.+2      	; 0x11d6 <xQueueGenericSendFromISR+0x86>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    11d4:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    11d6:	8a 81       	ldd	r24, Y+2	; 0x02
}
    11d8:	29 96       	adiw	r28, 0x09	; 9
    11da:	0f b6       	in	r0, 0x3f	; 63
    11dc:	f8 94       	cli
    11de:	de bf       	out	0x3e, r29	; 62
    11e0:	0f be       	out	0x3f, r0	; 63
    11e2:	cd bf       	out	0x3d, r28	; 61
    11e4:	cf 91       	pop	r28
    11e6:	df 91       	pop	r29
    11e8:	08 95       	ret

000011ea <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    11ea:	df 93       	push	r29
    11ec:	cf 93       	push	r28
    11ee:	cd b7       	in	r28, 0x3d	; 61
    11f0:	de b7       	in	r29, 0x3e	; 62
    11f2:	2e 97       	sbiw	r28, 0x0e	; 14
    11f4:	0f b6       	in	r0, 0x3f	; 63
    11f6:	f8 94       	cli
    11f8:	de bf       	out	0x3e, r29	; 62
    11fa:	0f be       	out	0x3f, r0	; 63
    11fc:	cd bf       	out	0x3d, r28	; 61
    11fe:	98 87       	std	Y+8, r25	; 0x08
    1200:	8f 83       	std	Y+7, r24	; 0x07
    1202:	7a 87       	std	Y+10, r23	; 0x0a
    1204:	69 87       	std	Y+9, r22	; 0x09
    1206:	5c 87       	std	Y+12, r21	; 0x0c
    1208:	4b 87       	std	Y+11, r20	; 0x0b
    120a:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    120c:	1b 82       	std	Y+3, r1	; 0x03
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    120e:	0f b6       	in	r0, 0x3f	; 63
    1210:	f8 94       	cli
    1212:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1214:	ef 81       	ldd	r30, Y+7	; 0x07
    1216:	f8 85       	ldd	r31, Y+8	; 0x08
    1218:	82 8d       	ldd	r24, Z+26	; 0x1a
    121a:	88 23       	and	r24, r24
    121c:	09 f4       	brne	.+2      	; 0x1220 <xQueueGenericReceive+0x36>
    121e:	3f c0       	rjmp	.+126    	; 0x129e <xQueueGenericReceive+0xb4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    1220:	ef 81       	ldd	r30, Y+7	; 0x07
    1222:	f8 85       	ldd	r31, Y+8	; 0x08
    1224:	86 81       	ldd	r24, Z+6	; 0x06
    1226:	97 81       	ldd	r25, Z+7	; 0x07
    1228:	9a 83       	std	Y+2, r25	; 0x02
    122a:	89 83       	std	Y+1, r24	; 0x01

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    122c:	8f 81       	ldd	r24, Y+7	; 0x07
    122e:	98 85       	ldd	r25, Y+8	; 0x08
    1230:	29 85       	ldd	r18, Y+9	; 0x09
    1232:	3a 85       	ldd	r19, Y+10	; 0x0a
    1234:	b9 01       	movw	r22, r18
    1236:	0e 94 da 0a 	call	0x15b4	; 0x15b4 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    123a:	8d 85       	ldd	r24, Y+13	; 0x0d
    123c:	88 23       	and	r24, r24
    123e:	b1 f4       	brne	.+44     	; 0x126c <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    1240:	ef 81       	ldd	r30, Y+7	; 0x07
    1242:	f8 85       	ldd	r31, Y+8	; 0x08
    1244:	82 8d       	ldd	r24, Z+26	; 0x1a
    1246:	81 50       	subi	r24, 0x01	; 1
    1248:	ef 81       	ldd	r30, Y+7	; 0x07
    124a:	f8 85       	ldd	r31, Y+8	; 0x08
    124c:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    124e:	ef 81       	ldd	r30, Y+7	; 0x07
    1250:	f8 85       	ldd	r31, Y+8	; 0x08
    1252:	80 85       	ldd	r24, Z+8	; 0x08
    1254:	88 23       	and	r24, r24
    1256:	f1 f0       	breq	.+60     	; 0x1294 <xQueueGenericReceive+0xaa>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1258:	8f 81       	ldd	r24, Y+7	; 0x07
    125a:	98 85       	ldd	r25, Y+8	; 0x08
    125c:	08 96       	adiw	r24, 0x08	; 8
    125e:	0e 94 5a 10 	call	0x20b4	; 0x20b4 <xTaskRemoveFromEventList>
    1262:	81 30       	cpi	r24, 0x01	; 1
    1264:	b9 f4       	brne	.+46     	; 0x1294 <xQueueGenericReceive+0xaa>
						{
							portYIELD_WITHIN_API();
    1266:	0e 94 4e 06 	call	0xc9c	; 0xc9c <vPortYield>
    126a:	14 c0       	rjmp	.+40     	; 0x1294 <xQueueGenericReceive+0xaa>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    126c:	ef 81       	ldd	r30, Y+7	; 0x07
    126e:	f8 85       	ldd	r31, Y+8	; 0x08
    1270:	89 81       	ldd	r24, Y+1	; 0x01
    1272:	9a 81       	ldd	r25, Y+2	; 0x02
    1274:	97 83       	std	Z+7, r25	; 0x07
    1276:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1278:	ef 81       	ldd	r30, Y+7	; 0x07
    127a:	f8 85       	ldd	r31, Y+8	; 0x08
    127c:	81 89       	ldd	r24, Z+17	; 0x11
    127e:	88 23       	and	r24, r24
    1280:	49 f0       	breq	.+18     	; 0x1294 <xQueueGenericReceive+0xaa>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1282:	8f 81       	ldd	r24, Y+7	; 0x07
    1284:	98 85       	ldd	r25, Y+8	; 0x08
    1286:	41 96       	adiw	r24, 0x11	; 17
    1288:	0e 94 5a 10 	call	0x20b4	; 0x20b4 <xTaskRemoveFromEventList>
    128c:	88 23       	and	r24, r24
    128e:	11 f0       	breq	.+4      	; 0x1294 <xQueueGenericReceive+0xaa>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    1290:	0e 94 4e 06 	call	0xc9c	; 0xc9c <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    1294:	0f 90       	pop	r0
    1296:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1298:	81 e0       	ldi	r24, 0x01	; 1
    129a:	8e 87       	std	Y+14, r24	; 0x0e
    129c:	5c c0       	rjmp	.+184    	; 0x1356 <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    129e:	8b 85       	ldd	r24, Y+11	; 0x0b
    12a0:	9c 85       	ldd	r25, Y+12	; 0x0c
    12a2:	00 97       	sbiw	r24, 0x00	; 0
    12a4:	21 f4       	brne	.+8      	; 0x12ae <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    12a6:	0f 90       	pop	r0
    12a8:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    12aa:	1e 86       	std	Y+14, r1	; 0x0e
    12ac:	54 c0       	rjmp	.+168    	; 0x1356 <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    12ae:	8b 81       	ldd	r24, Y+3	; 0x03
    12b0:	88 23       	and	r24, r24
    12b2:	31 f4       	brne	.+12     	; 0x12c0 <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    12b4:	ce 01       	movw	r24, r28
    12b6:	04 96       	adiw	r24, 0x04	; 4
    12b8:	0e 94 c2 10 	call	0x2184	; 0x2184 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    12bc:	81 e0       	ldi	r24, 0x01	; 1
    12be:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}
		taskEXIT_CRITICAL();
    12c0:	0f 90       	pop	r0
    12c2:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    12c4:	0e 94 1e 0e 	call	0x1c3c	; 0x1c3c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    12c8:	0f b6       	in	r0, 0x3f	; 63
    12ca:	f8 94       	cli
    12cc:	0f 92       	push	r0
    12ce:	ef 81       	ldd	r30, Y+7	; 0x07
    12d0:	f8 85       	ldd	r31, Y+8	; 0x08
    12d2:	85 8d       	ldd	r24, Z+29	; 0x1d
    12d4:	8f 3f       	cpi	r24, 0xFF	; 255
    12d6:	19 f4       	brne	.+6      	; 0x12de <xQueueGenericReceive+0xf4>
    12d8:	ef 81       	ldd	r30, Y+7	; 0x07
    12da:	f8 85       	ldd	r31, Y+8	; 0x08
    12dc:	15 8e       	std	Z+29, r1	; 0x1d
    12de:	ef 81       	ldd	r30, Y+7	; 0x07
    12e0:	f8 85       	ldd	r31, Y+8	; 0x08
    12e2:	86 8d       	ldd	r24, Z+30	; 0x1e
    12e4:	8f 3f       	cpi	r24, 0xFF	; 255
    12e6:	19 f4       	brne	.+6      	; 0x12ee <xQueueGenericReceive+0x104>
    12e8:	ef 81       	ldd	r30, Y+7	; 0x07
    12ea:	f8 85       	ldd	r31, Y+8	; 0x08
    12ec:	16 8e       	std	Z+30, r1	; 0x1e
    12ee:	0f 90       	pop	r0
    12f0:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    12f2:	ce 01       	movw	r24, r28
    12f4:	04 96       	adiw	r24, 0x04	; 4
    12f6:	9e 01       	movw	r18, r28
    12f8:	25 5f       	subi	r18, 0xF5	; 245
    12fa:	3f 4f       	sbci	r19, 0xFF	; 255
    12fc:	b9 01       	movw	r22, r18
    12fe:	0e 94 db 10 	call	0x21b6	; 0x21b6 <xTaskCheckForTimeOut>
    1302:	88 23       	and	r24, r24
    1304:	09 f5       	brne	.+66     	; 0x1348 <xQueueGenericReceive+0x15e>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1306:	8f 81       	ldd	r24, Y+7	; 0x07
    1308:	98 85       	ldd	r25, Y+8	; 0x08
    130a:	0e 94 76 0b 	call	0x16ec	; 0x16ec <prvIsQueueEmpty>
    130e:	88 23       	and	r24, r24
    1310:	a1 f0       	breq	.+40     	; 0x133a <xQueueGenericReceive+0x150>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1312:	8f 81       	ldd	r24, Y+7	; 0x07
    1314:	98 85       	ldd	r25, Y+8	; 0x08
    1316:	41 96       	adiw	r24, 0x11	; 17
    1318:	2b 85       	ldd	r18, Y+11	; 0x0b
    131a:	3c 85       	ldd	r19, Y+12	; 0x0c
    131c:	b9 01       	movw	r22, r18
    131e:	0e 94 24 10 	call	0x2048	; 0x2048 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1322:	8f 81       	ldd	r24, Y+7	; 0x07
    1324:	98 85       	ldd	r25, Y+8	; 0x08
    1326:	0e 94 22 0b 	call	0x1644	; 0x1644 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    132a:	0e 94 2a 0e 	call	0x1c54	; 0x1c54 <xTaskResumeAll>
    132e:	88 23       	and	r24, r24
    1330:	09 f0       	breq	.+2      	; 0x1334 <xQueueGenericReceive+0x14a>
    1332:	6d cf       	rjmp	.-294    	; 0x120e <xQueueGenericReceive+0x24>
				{
					portYIELD_WITHIN_API();
    1334:	0e 94 4e 06 	call	0xc9c	; 0xc9c <vPortYield>
    1338:	6a cf       	rjmp	.-300    	; 0x120e <xQueueGenericReceive+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    133a:	8f 81       	ldd	r24, Y+7	; 0x07
    133c:	98 85       	ldd	r25, Y+8	; 0x08
    133e:	0e 94 22 0b 	call	0x1644	; 0x1644 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1342:	0e 94 2a 0e 	call	0x1c54	; 0x1c54 <xTaskResumeAll>
    1346:	63 cf       	rjmp	.-314    	; 0x120e <xQueueGenericReceive+0x24>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1348:	8f 81       	ldd	r24, Y+7	; 0x07
    134a:	98 85       	ldd	r25, Y+8	; 0x08
    134c:	0e 94 22 0b 	call	0x1644	; 0x1644 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1350:	0e 94 2a 0e 	call	0x1c54	; 0x1c54 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1354:	1e 86       	std	Y+14, r1	; 0x0e
    1356:	8e 85       	ldd	r24, Y+14	; 0x0e
		}
	}
}
    1358:	2e 96       	adiw	r28, 0x0e	; 14
    135a:	0f b6       	in	r0, 0x3f	; 63
    135c:	f8 94       	cli
    135e:	de bf       	out	0x3e, r29	; 62
    1360:	0f be       	out	0x3f, r0	; 63
    1362:	cd bf       	out	0x3d, r28	; 61
    1364:	cf 91       	pop	r28
    1366:	df 91       	pop	r29
    1368:	08 95       	ret

0000136a <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    136a:	df 93       	push	r29
    136c:	cf 93       	push	r28
    136e:	cd b7       	in	r28, 0x3d	; 61
    1370:	de b7       	in	r29, 0x3e	; 62
    1372:	28 97       	sbiw	r28, 0x08	; 8
    1374:	0f b6       	in	r0, 0x3f	; 63
    1376:	f8 94       	cli
    1378:	de bf       	out	0x3e, r29	; 62
    137a:	0f be       	out	0x3f, r0	; 63
    137c:	cd bf       	out	0x3d, r28	; 61
    137e:	9c 83       	std	Y+4, r25	; 0x04
    1380:	8b 83       	std	Y+3, r24	; 0x03
    1382:	7e 83       	std	Y+6, r23	; 0x06
    1384:	6d 83       	std	Y+5, r22	; 0x05
    1386:	58 87       	std	Y+8, r21	; 0x08
    1388:	4f 83       	std	Y+7, r20	; 0x07

	configASSERT( pxQueue );
	configASSERT( pxTaskWoken );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    138a:	19 82       	std	Y+1, r1	; 0x01
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    138c:	eb 81       	ldd	r30, Y+3	; 0x03
    138e:	fc 81       	ldd	r31, Y+4	; 0x04
    1390:	82 8d       	ldd	r24, Z+26	; 0x1a
    1392:	88 23       	and	r24, r24
    1394:	71 f1       	breq	.+92     	; 0x13f2 <xQueueReceiveFromISR+0x88>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1396:	8b 81       	ldd	r24, Y+3	; 0x03
    1398:	9c 81       	ldd	r25, Y+4	; 0x04
    139a:	2d 81       	ldd	r18, Y+5	; 0x05
    139c:	3e 81       	ldd	r19, Y+6	; 0x06
    139e:	b9 01       	movw	r22, r18
    13a0:	0e 94 da 0a 	call	0x15b4	; 0x15b4 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    13a4:	eb 81       	ldd	r30, Y+3	; 0x03
    13a6:	fc 81       	ldd	r31, Y+4	; 0x04
    13a8:	82 8d       	ldd	r24, Z+26	; 0x1a
    13aa:	81 50       	subi	r24, 0x01	; 1
    13ac:	eb 81       	ldd	r30, Y+3	; 0x03
    13ae:	fc 81       	ldd	r31, Y+4	; 0x04
    13b0:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    13b2:	eb 81       	ldd	r30, Y+3	; 0x03
    13b4:	fc 81       	ldd	r31, Y+4	; 0x04
    13b6:	85 8d       	ldd	r24, Z+29	; 0x1d
    13b8:	8f 3f       	cpi	r24, 0xFF	; 255
    13ba:	89 f4       	brne	.+34     	; 0x13de <xQueueReceiveFromISR+0x74>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    13bc:	eb 81       	ldd	r30, Y+3	; 0x03
    13be:	fc 81       	ldd	r31, Y+4	; 0x04
    13c0:	80 85       	ldd	r24, Z+8	; 0x08
    13c2:	88 23       	and	r24, r24
    13c4:	99 f0       	breq	.+38     	; 0x13ec <xQueueReceiveFromISR+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    13c6:	8b 81       	ldd	r24, Y+3	; 0x03
    13c8:	9c 81       	ldd	r25, Y+4	; 0x04
    13ca:	08 96       	adiw	r24, 0x08	; 8
    13cc:	0e 94 5a 10 	call	0x20b4	; 0x20b4 <xTaskRemoveFromEventList>
    13d0:	88 23       	and	r24, r24
    13d2:	61 f0       	breq	.+24     	; 0x13ec <xQueueReceiveFromISR+0x82>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    13d4:	ef 81       	ldd	r30, Y+7	; 0x07
    13d6:	f8 85       	ldd	r31, Y+8	; 0x08
    13d8:	81 e0       	ldi	r24, 0x01	; 1
    13da:	80 83       	st	Z, r24
    13dc:	07 c0       	rjmp	.+14     	; 0x13ec <xQueueReceiveFromISR+0x82>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    13de:	eb 81       	ldd	r30, Y+3	; 0x03
    13e0:	fc 81       	ldd	r31, Y+4	; 0x04
    13e2:	85 8d       	ldd	r24, Z+29	; 0x1d
    13e4:	8f 5f       	subi	r24, 0xFF	; 255
    13e6:	eb 81       	ldd	r30, Y+3	; 0x03
    13e8:	fc 81       	ldd	r31, Y+4	; 0x04
    13ea:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    13ec:	81 e0       	ldi	r24, 0x01	; 1
    13ee:	8a 83       	std	Y+2, r24	; 0x02
    13f0:	01 c0       	rjmp	.+2      	; 0x13f4 <xQueueReceiveFromISR+0x8a>
		}
		else
		{
			xReturn = pdFAIL;
    13f2:	1a 82       	std	Y+2, r1	; 0x02
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    13f4:	8a 81       	ldd	r24, Y+2	; 0x02
}
    13f6:	28 96       	adiw	r28, 0x08	; 8
    13f8:	0f b6       	in	r0, 0x3f	; 63
    13fa:	f8 94       	cli
    13fc:	de bf       	out	0x3e, r29	; 62
    13fe:	0f be       	out	0x3f, r0	; 63
    1400:	cd bf       	out	0x3d, r28	; 61
    1402:	cf 91       	pop	r28
    1404:	df 91       	pop	r29
    1406:	08 95       	ret

00001408 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    1408:	df 93       	push	r29
    140a:	cf 93       	push	r28
    140c:	00 d0       	rcall	.+0      	; 0x140e <uxQueueMessagesWaiting+0x6>
    140e:	0f 92       	push	r0
    1410:	cd b7       	in	r28, 0x3d	; 61
    1412:	de b7       	in	r29, 0x3e	; 62
    1414:	9b 83       	std	Y+3, r25	; 0x03
    1416:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1418:	0f b6       	in	r0, 0x3f	; 63
    141a:	f8 94       	cli
    141c:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    141e:	ea 81       	ldd	r30, Y+2	; 0x02
    1420:	fb 81       	ldd	r31, Y+3	; 0x03
    1422:	82 8d       	ldd	r24, Z+26	; 0x1a
    1424:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    1426:	0f 90       	pop	r0
    1428:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    142a:	89 81       	ldd	r24, Y+1	; 0x01
}
    142c:	0f 90       	pop	r0
    142e:	0f 90       	pop	r0
    1430:	0f 90       	pop	r0
    1432:	cf 91       	pop	r28
    1434:	df 91       	pop	r29
    1436:	08 95       	ret

00001438 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    1438:	df 93       	push	r29
    143a:	cf 93       	push	r28
    143c:	00 d0       	rcall	.+0      	; 0x143e <uxQueueMessagesWaitingFromISR+0x6>
    143e:	0f 92       	push	r0
    1440:	cd b7       	in	r28, 0x3d	; 61
    1442:	de b7       	in	r29, 0x3e	; 62
    1444:	9b 83       	std	Y+3, r25	; 0x03
    1446:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    1448:	ea 81       	ldd	r30, Y+2	; 0x02
    144a:	fb 81       	ldd	r31, Y+3	; 0x03
    144c:	82 8d       	ldd	r24, Z+26	; 0x1a
    144e:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    1450:	89 81       	ldd	r24, Y+1	; 0x01
}
    1452:	0f 90       	pop	r0
    1454:	0f 90       	pop	r0
    1456:	0f 90       	pop	r0
    1458:	cf 91       	pop	r28
    145a:	df 91       	pop	r29
    145c:	08 95       	ret

0000145e <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    145e:	df 93       	push	r29
    1460:	cf 93       	push	r28
    1462:	00 d0       	rcall	.+0      	; 0x1464 <vQueueDelete+0x6>
    1464:	cd b7       	in	r28, 0x3d	; 61
    1466:	de b7       	in	r29, 0x3e	; 62
    1468:	9a 83       	std	Y+2, r25	; 0x02
    146a:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    146c:	e9 81       	ldd	r30, Y+1	; 0x01
    146e:	fa 81       	ldd	r31, Y+2	; 0x02
    1470:	80 81       	ld	r24, Z
    1472:	91 81       	ldd	r25, Z+1	; 0x01
    1474:	0e 94 3c 03 	call	0x678	; 0x678 <vPortFree>
	vPortFree( pxQueue );
    1478:	89 81       	ldd	r24, Y+1	; 0x01
    147a:	9a 81       	ldd	r25, Y+2	; 0x02
    147c:	0e 94 3c 03 	call	0x678	; 0x678 <vPortFree>
}
    1480:	0f 90       	pop	r0
    1482:	0f 90       	pop	r0
    1484:	cf 91       	pop	r28
    1486:	df 91       	pop	r29
    1488:	08 95       	ret

0000148a <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    148a:	df 93       	push	r29
    148c:	cf 93       	push	r28
    148e:	00 d0       	rcall	.+0      	; 0x1490 <prvCopyDataToQueue+0x6>
    1490:	00 d0       	rcall	.+0      	; 0x1492 <prvCopyDataToQueue+0x8>
    1492:	0f 92       	push	r0
    1494:	cd b7       	in	r28, 0x3d	; 61
    1496:	de b7       	in	r29, 0x3e	; 62
    1498:	9a 83       	std	Y+2, r25	; 0x02
    149a:	89 83       	std	Y+1, r24	; 0x01
    149c:	7c 83       	std	Y+4, r23	; 0x04
    149e:	6b 83       	std	Y+3, r22	; 0x03
    14a0:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    14a2:	e9 81       	ldd	r30, Y+1	; 0x01
    14a4:	fa 81       	ldd	r31, Y+2	; 0x02
    14a6:	84 8d       	ldd	r24, Z+28	; 0x1c
    14a8:	88 23       	and	r24, r24
    14aa:	09 f4       	brne	.+2      	; 0x14ae <prvCopyDataToQueue+0x24>
    14ac:	74 c0       	rjmp	.+232    	; 0x1596 <prvCopyDataToQueue+0x10c>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    14ae:	8d 81       	ldd	r24, Y+5	; 0x05
    14b0:	88 23       	and	r24, r24
    14b2:	99 f5       	brne	.+102    	; 0x151a <prvCopyDataToQueue+0x90>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    14b4:	e9 81       	ldd	r30, Y+1	; 0x01
    14b6:	fa 81       	ldd	r31, Y+2	; 0x02
    14b8:	64 81       	ldd	r22, Z+4	; 0x04
    14ba:	75 81       	ldd	r23, Z+5	; 0x05
    14bc:	e9 81       	ldd	r30, Y+1	; 0x01
    14be:	fa 81       	ldd	r31, Y+2	; 0x02
    14c0:	84 8d       	ldd	r24, Z+28	; 0x1c
    14c2:	48 2f       	mov	r20, r24
    14c4:	50 e0       	ldi	r21, 0x00	; 0
    14c6:	2b 81       	ldd	r18, Y+3	; 0x03
    14c8:	3c 81       	ldd	r19, Y+4	; 0x04
    14ca:	cb 01       	movw	r24, r22
    14cc:	b9 01       	movw	r22, r18
    14ce:	0e 94 73 17 	call	0x2ee6	; 0x2ee6 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    14d2:	e9 81       	ldd	r30, Y+1	; 0x01
    14d4:	fa 81       	ldd	r31, Y+2	; 0x02
    14d6:	24 81       	ldd	r18, Z+4	; 0x04
    14d8:	35 81       	ldd	r19, Z+5	; 0x05
    14da:	e9 81       	ldd	r30, Y+1	; 0x01
    14dc:	fa 81       	ldd	r31, Y+2	; 0x02
    14de:	84 8d       	ldd	r24, Z+28	; 0x1c
    14e0:	88 2f       	mov	r24, r24
    14e2:	90 e0       	ldi	r25, 0x00	; 0
    14e4:	82 0f       	add	r24, r18
    14e6:	93 1f       	adc	r25, r19
    14e8:	e9 81       	ldd	r30, Y+1	; 0x01
    14ea:	fa 81       	ldd	r31, Y+2	; 0x02
    14ec:	95 83       	std	Z+5, r25	; 0x05
    14ee:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    14f0:	e9 81       	ldd	r30, Y+1	; 0x01
    14f2:	fa 81       	ldd	r31, Y+2	; 0x02
    14f4:	24 81       	ldd	r18, Z+4	; 0x04
    14f6:	35 81       	ldd	r19, Z+5	; 0x05
    14f8:	e9 81       	ldd	r30, Y+1	; 0x01
    14fa:	fa 81       	ldd	r31, Y+2	; 0x02
    14fc:	82 81       	ldd	r24, Z+2	; 0x02
    14fe:	93 81       	ldd	r25, Z+3	; 0x03
    1500:	28 17       	cp	r18, r24
    1502:	39 07       	cpc	r19, r25
    1504:	08 f4       	brcc	.+2      	; 0x1508 <prvCopyDataToQueue+0x7e>
    1506:	47 c0       	rjmp	.+142    	; 0x1596 <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    1508:	e9 81       	ldd	r30, Y+1	; 0x01
    150a:	fa 81       	ldd	r31, Y+2	; 0x02
    150c:	80 81       	ld	r24, Z
    150e:	91 81       	ldd	r25, Z+1	; 0x01
    1510:	e9 81       	ldd	r30, Y+1	; 0x01
    1512:	fa 81       	ldd	r31, Y+2	; 0x02
    1514:	95 83       	std	Z+5, r25	; 0x05
    1516:	84 83       	std	Z+4, r24	; 0x04
    1518:	3e c0       	rjmp	.+124    	; 0x1596 <prvCopyDataToQueue+0x10c>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    151a:	e9 81       	ldd	r30, Y+1	; 0x01
    151c:	fa 81       	ldd	r31, Y+2	; 0x02
    151e:	66 81       	ldd	r22, Z+6	; 0x06
    1520:	77 81       	ldd	r23, Z+7	; 0x07
    1522:	e9 81       	ldd	r30, Y+1	; 0x01
    1524:	fa 81       	ldd	r31, Y+2	; 0x02
    1526:	84 8d       	ldd	r24, Z+28	; 0x1c
    1528:	48 2f       	mov	r20, r24
    152a:	50 e0       	ldi	r21, 0x00	; 0
    152c:	2b 81       	ldd	r18, Y+3	; 0x03
    152e:	3c 81       	ldd	r19, Y+4	; 0x04
    1530:	cb 01       	movw	r24, r22
    1532:	b9 01       	movw	r22, r18
    1534:	0e 94 73 17 	call	0x2ee6	; 0x2ee6 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    1538:	e9 81       	ldd	r30, Y+1	; 0x01
    153a:	fa 81       	ldd	r31, Y+2	; 0x02
    153c:	26 81       	ldd	r18, Z+6	; 0x06
    153e:	37 81       	ldd	r19, Z+7	; 0x07
    1540:	e9 81       	ldd	r30, Y+1	; 0x01
    1542:	fa 81       	ldd	r31, Y+2	; 0x02
    1544:	84 8d       	ldd	r24, Z+28	; 0x1c
    1546:	88 2f       	mov	r24, r24
    1548:	90 e0       	ldi	r25, 0x00	; 0
    154a:	90 95       	com	r25
    154c:	81 95       	neg	r24
    154e:	9f 4f       	sbci	r25, 0xFF	; 255
    1550:	82 0f       	add	r24, r18
    1552:	93 1f       	adc	r25, r19
    1554:	e9 81       	ldd	r30, Y+1	; 0x01
    1556:	fa 81       	ldd	r31, Y+2	; 0x02
    1558:	97 83       	std	Z+7, r25	; 0x07
    155a:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    155c:	e9 81       	ldd	r30, Y+1	; 0x01
    155e:	fa 81       	ldd	r31, Y+2	; 0x02
    1560:	26 81       	ldd	r18, Z+6	; 0x06
    1562:	37 81       	ldd	r19, Z+7	; 0x07
    1564:	e9 81       	ldd	r30, Y+1	; 0x01
    1566:	fa 81       	ldd	r31, Y+2	; 0x02
    1568:	80 81       	ld	r24, Z
    156a:	91 81       	ldd	r25, Z+1	; 0x01
    156c:	28 17       	cp	r18, r24
    156e:	39 07       	cpc	r19, r25
    1570:	90 f4       	brcc	.+36     	; 0x1596 <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    1572:	e9 81       	ldd	r30, Y+1	; 0x01
    1574:	fa 81       	ldd	r31, Y+2	; 0x02
    1576:	22 81       	ldd	r18, Z+2	; 0x02
    1578:	33 81       	ldd	r19, Z+3	; 0x03
    157a:	e9 81       	ldd	r30, Y+1	; 0x01
    157c:	fa 81       	ldd	r31, Y+2	; 0x02
    157e:	84 8d       	ldd	r24, Z+28	; 0x1c
    1580:	88 2f       	mov	r24, r24
    1582:	90 e0       	ldi	r25, 0x00	; 0
    1584:	90 95       	com	r25
    1586:	81 95       	neg	r24
    1588:	9f 4f       	sbci	r25, 0xFF	; 255
    158a:	82 0f       	add	r24, r18
    158c:	93 1f       	adc	r25, r19
    158e:	e9 81       	ldd	r30, Y+1	; 0x01
    1590:	fa 81       	ldd	r31, Y+2	; 0x02
    1592:	97 83       	std	Z+7, r25	; 0x07
    1594:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    1596:	e9 81       	ldd	r30, Y+1	; 0x01
    1598:	fa 81       	ldd	r31, Y+2	; 0x02
    159a:	82 8d       	ldd	r24, Z+26	; 0x1a
    159c:	8f 5f       	subi	r24, 0xFF	; 255
    159e:	e9 81       	ldd	r30, Y+1	; 0x01
    15a0:	fa 81       	ldd	r31, Y+2	; 0x02
    15a2:	82 8f       	std	Z+26, r24	; 0x1a
}
    15a4:	0f 90       	pop	r0
    15a6:	0f 90       	pop	r0
    15a8:	0f 90       	pop	r0
    15aa:	0f 90       	pop	r0
    15ac:	0f 90       	pop	r0
    15ae:	cf 91       	pop	r28
    15b0:	df 91       	pop	r29
    15b2:	08 95       	ret

000015b4 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    15b4:	df 93       	push	r29
    15b6:	cf 93       	push	r28
    15b8:	00 d0       	rcall	.+0      	; 0x15ba <prvCopyDataFromQueue+0x6>
    15ba:	00 d0       	rcall	.+0      	; 0x15bc <prvCopyDataFromQueue+0x8>
    15bc:	cd b7       	in	r28, 0x3d	; 61
    15be:	de b7       	in	r29, 0x3e	; 62
    15c0:	9a 83       	std	Y+2, r25	; 0x02
    15c2:	89 83       	std	Y+1, r24	; 0x01
    15c4:	7c 83       	std	Y+4, r23	; 0x04
    15c6:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    15c8:	e9 81       	ldd	r30, Y+1	; 0x01
    15ca:	fa 81       	ldd	r31, Y+2	; 0x02
    15cc:	80 81       	ld	r24, Z
    15ce:	91 81       	ldd	r25, Z+1	; 0x01
    15d0:	00 97       	sbiw	r24, 0x00	; 0
    15d2:	89 f1       	breq	.+98     	; 0x1636 <prvCopyDataFromQueue+0x82>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    15d4:	e9 81       	ldd	r30, Y+1	; 0x01
    15d6:	fa 81       	ldd	r31, Y+2	; 0x02
    15d8:	26 81       	ldd	r18, Z+6	; 0x06
    15da:	37 81       	ldd	r19, Z+7	; 0x07
    15dc:	e9 81       	ldd	r30, Y+1	; 0x01
    15de:	fa 81       	ldd	r31, Y+2	; 0x02
    15e0:	84 8d       	ldd	r24, Z+28	; 0x1c
    15e2:	88 2f       	mov	r24, r24
    15e4:	90 e0       	ldi	r25, 0x00	; 0
    15e6:	82 0f       	add	r24, r18
    15e8:	93 1f       	adc	r25, r19
    15ea:	e9 81       	ldd	r30, Y+1	; 0x01
    15ec:	fa 81       	ldd	r31, Y+2	; 0x02
    15ee:	97 83       	std	Z+7, r25	; 0x07
    15f0:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    15f2:	e9 81       	ldd	r30, Y+1	; 0x01
    15f4:	fa 81       	ldd	r31, Y+2	; 0x02
    15f6:	26 81       	ldd	r18, Z+6	; 0x06
    15f8:	37 81       	ldd	r19, Z+7	; 0x07
    15fa:	e9 81       	ldd	r30, Y+1	; 0x01
    15fc:	fa 81       	ldd	r31, Y+2	; 0x02
    15fe:	82 81       	ldd	r24, Z+2	; 0x02
    1600:	93 81       	ldd	r25, Z+3	; 0x03
    1602:	28 17       	cp	r18, r24
    1604:	39 07       	cpc	r19, r25
    1606:	40 f0       	brcs	.+16     	; 0x1618 <prvCopyDataFromQueue+0x64>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    1608:	e9 81       	ldd	r30, Y+1	; 0x01
    160a:	fa 81       	ldd	r31, Y+2	; 0x02
    160c:	80 81       	ld	r24, Z
    160e:	91 81       	ldd	r25, Z+1	; 0x01
    1610:	e9 81       	ldd	r30, Y+1	; 0x01
    1612:	fa 81       	ldd	r31, Y+2	; 0x02
    1614:	97 83       	std	Z+7, r25	; 0x07
    1616:	86 83       	std	Z+6, r24	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1618:	e9 81       	ldd	r30, Y+1	; 0x01
    161a:	fa 81       	ldd	r31, Y+2	; 0x02
    161c:	46 81       	ldd	r20, Z+6	; 0x06
    161e:	57 81       	ldd	r21, Z+7	; 0x07
    1620:	e9 81       	ldd	r30, Y+1	; 0x01
    1622:	fa 81       	ldd	r31, Y+2	; 0x02
    1624:	84 8d       	ldd	r24, Z+28	; 0x1c
    1626:	28 2f       	mov	r18, r24
    1628:	30 e0       	ldi	r19, 0x00	; 0
    162a:	8b 81       	ldd	r24, Y+3	; 0x03
    162c:	9c 81       	ldd	r25, Y+4	; 0x04
    162e:	ba 01       	movw	r22, r20
    1630:	a9 01       	movw	r20, r18
    1632:	0e 94 73 17 	call	0x2ee6	; 0x2ee6 <memcpy>
	}
}
    1636:	0f 90       	pop	r0
    1638:	0f 90       	pop	r0
    163a:	0f 90       	pop	r0
    163c:	0f 90       	pop	r0
    163e:	cf 91       	pop	r28
    1640:	df 91       	pop	r29
    1642:	08 95       	ret

00001644 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    1644:	df 93       	push	r29
    1646:	cf 93       	push	r28
    1648:	00 d0       	rcall	.+0      	; 0x164a <prvUnlockQueue+0x6>
    164a:	cd b7       	in	r28, 0x3d	; 61
    164c:	de b7       	in	r29, 0x3e	; 62
    164e:	9a 83       	std	Y+2, r25	; 0x02
    1650:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1652:	0f b6       	in	r0, 0x3f	; 63
    1654:	f8 94       	cli
    1656:	0f 92       	push	r0
    1658:	15 c0       	rjmp	.+42     	; 0x1684 <prvUnlockQueue+0x40>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    165a:	e9 81       	ldd	r30, Y+1	; 0x01
    165c:	fa 81       	ldd	r31, Y+2	; 0x02
    165e:	81 89       	ldd	r24, Z+17	; 0x11
    1660:	88 23       	and	r24, r24
    1662:	a9 f0       	breq	.+42     	; 0x168e <prvUnlockQueue+0x4a>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1664:	89 81       	ldd	r24, Y+1	; 0x01
    1666:	9a 81       	ldd	r25, Y+2	; 0x02
    1668:	41 96       	adiw	r24, 0x11	; 17
    166a:	0e 94 5a 10 	call	0x20b4	; 0x20b4 <xTaskRemoveFromEventList>
    166e:	88 23       	and	r24, r24
    1670:	11 f0       	breq	.+4      	; 0x1676 <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    1672:	0e 94 38 11 	call	0x2270	; 0x2270 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    1676:	e9 81       	ldd	r30, Y+1	; 0x01
    1678:	fa 81       	ldd	r31, Y+2	; 0x02
    167a:	86 8d       	ldd	r24, Z+30	; 0x1e
    167c:	81 50       	subi	r24, 0x01	; 1
    167e:	e9 81       	ldd	r30, Y+1	; 0x01
    1680:	fa 81       	ldd	r31, Y+2	; 0x02
    1682:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    1684:	e9 81       	ldd	r30, Y+1	; 0x01
    1686:	fa 81       	ldd	r31, Y+2	; 0x02
    1688:	86 8d       	ldd	r24, Z+30	; 0x1e
    168a:	18 16       	cp	r1, r24
    168c:	34 f3       	brlt	.-52     	; 0x165a <prvUnlockQueue+0x16>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    168e:	e9 81       	ldd	r30, Y+1	; 0x01
    1690:	fa 81       	ldd	r31, Y+2	; 0x02
    1692:	8f ef       	ldi	r24, 0xFF	; 255
    1694:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    1696:	0f 90       	pop	r0
    1698:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    169a:	0f b6       	in	r0, 0x3f	; 63
    169c:	f8 94       	cli
    169e:	0f 92       	push	r0
    16a0:	15 c0       	rjmp	.+42     	; 0x16cc <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    16a2:	e9 81       	ldd	r30, Y+1	; 0x01
    16a4:	fa 81       	ldd	r31, Y+2	; 0x02
    16a6:	80 85       	ldd	r24, Z+8	; 0x08
    16a8:	88 23       	and	r24, r24
    16aa:	a9 f0       	breq	.+42     	; 0x16d6 <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    16ac:	89 81       	ldd	r24, Y+1	; 0x01
    16ae:	9a 81       	ldd	r25, Y+2	; 0x02
    16b0:	08 96       	adiw	r24, 0x08	; 8
    16b2:	0e 94 5a 10 	call	0x20b4	; 0x20b4 <xTaskRemoveFromEventList>
    16b6:	88 23       	and	r24, r24
    16b8:	11 f0       	breq	.+4      	; 0x16be <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    16ba:	0e 94 38 11 	call	0x2270	; 0x2270 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    16be:	e9 81       	ldd	r30, Y+1	; 0x01
    16c0:	fa 81       	ldd	r31, Y+2	; 0x02
    16c2:	85 8d       	ldd	r24, Z+29	; 0x1d
    16c4:	81 50       	subi	r24, 0x01	; 1
    16c6:	e9 81       	ldd	r30, Y+1	; 0x01
    16c8:	fa 81       	ldd	r31, Y+2	; 0x02
    16ca:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    16cc:	e9 81       	ldd	r30, Y+1	; 0x01
    16ce:	fa 81       	ldd	r31, Y+2	; 0x02
    16d0:	85 8d       	ldd	r24, Z+29	; 0x1d
    16d2:	18 16       	cp	r1, r24
    16d4:	34 f3       	brlt	.-52     	; 0x16a2 <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    16d6:	e9 81       	ldd	r30, Y+1	; 0x01
    16d8:	fa 81       	ldd	r31, Y+2	; 0x02
    16da:	8f ef       	ldi	r24, 0xFF	; 255
    16dc:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    16de:	0f 90       	pop	r0
    16e0:	0f be       	out	0x3f, r0	; 63
}
    16e2:	0f 90       	pop	r0
    16e4:	0f 90       	pop	r0
    16e6:	cf 91       	pop	r28
    16e8:	df 91       	pop	r29
    16ea:	08 95       	ret

000016ec <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    16ec:	df 93       	push	r29
    16ee:	cf 93       	push	r28
    16f0:	00 d0       	rcall	.+0      	; 0x16f2 <prvIsQueueEmpty+0x6>
    16f2:	0f 92       	push	r0
    16f4:	cd b7       	in	r28, 0x3d	; 61
    16f6:	de b7       	in	r29, 0x3e	; 62
    16f8:	9b 83       	std	Y+3, r25	; 0x03
    16fa:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    16fc:	0f b6       	in	r0, 0x3f	; 63
    16fe:	f8 94       	cli
    1700:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    1702:	ea 81       	ldd	r30, Y+2	; 0x02
    1704:	fb 81       	ldd	r31, Y+3	; 0x03
    1706:	82 8d       	ldd	r24, Z+26	; 0x1a
    1708:	19 82       	std	Y+1, r1	; 0x01
    170a:	88 23       	and	r24, r24
    170c:	11 f4       	brne	.+4      	; 0x1712 <prvIsQueueEmpty+0x26>
    170e:	81 e0       	ldi	r24, 0x01	; 1
    1710:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    1712:	0f 90       	pop	r0
    1714:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    1716:	89 81       	ldd	r24, Y+1	; 0x01
}
    1718:	0f 90       	pop	r0
    171a:	0f 90       	pop	r0
    171c:	0f 90       	pop	r0
    171e:	cf 91       	pop	r28
    1720:	df 91       	pop	r29
    1722:	08 95       	ret

00001724 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    1724:	df 93       	push	r29
    1726:	cf 93       	push	r28
    1728:	00 d0       	rcall	.+0      	; 0x172a <xQueueIsQueueEmptyFromISR+0x6>
    172a:	0f 92       	push	r0
    172c:	cd b7       	in	r28, 0x3d	; 61
    172e:	de b7       	in	r29, 0x3e	; 62
    1730:	9b 83       	std	Y+3, r25	; 0x03
    1732:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    1734:	ea 81       	ldd	r30, Y+2	; 0x02
    1736:	fb 81       	ldd	r31, Y+3	; 0x03
    1738:	82 8d       	ldd	r24, Z+26	; 0x1a
    173a:	19 82       	std	Y+1, r1	; 0x01
    173c:	88 23       	and	r24, r24
    173e:	11 f4       	brne	.+4      	; 0x1744 <xQueueIsQueueEmptyFromISR+0x20>
    1740:	81 e0       	ldi	r24, 0x01	; 1
    1742:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    1744:	89 81       	ldd	r24, Y+1	; 0x01
}
    1746:	0f 90       	pop	r0
    1748:	0f 90       	pop	r0
    174a:	0f 90       	pop	r0
    174c:	cf 91       	pop	r28
    174e:	df 91       	pop	r29
    1750:	08 95       	ret

00001752 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    1752:	df 93       	push	r29
    1754:	cf 93       	push	r28
    1756:	00 d0       	rcall	.+0      	; 0x1758 <prvIsQueueFull+0x6>
    1758:	0f 92       	push	r0
    175a:	cd b7       	in	r28, 0x3d	; 61
    175c:	de b7       	in	r29, 0x3e	; 62
    175e:	9b 83       	std	Y+3, r25	; 0x03
    1760:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    1762:	0f b6       	in	r0, 0x3f	; 63
    1764:	f8 94       	cli
    1766:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    1768:	ea 81       	ldd	r30, Y+2	; 0x02
    176a:	fb 81       	ldd	r31, Y+3	; 0x03
    176c:	92 8d       	ldd	r25, Z+26	; 0x1a
    176e:	ea 81       	ldd	r30, Y+2	; 0x02
    1770:	fb 81       	ldd	r31, Y+3	; 0x03
    1772:	83 8d       	ldd	r24, Z+27	; 0x1b
    1774:	19 82       	std	Y+1, r1	; 0x01
    1776:	98 17       	cp	r25, r24
    1778:	11 f4       	brne	.+4      	; 0x177e <prvIsQueueFull+0x2c>
    177a:	81 e0       	ldi	r24, 0x01	; 1
    177c:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    177e:	0f 90       	pop	r0
    1780:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    1782:	89 81       	ldd	r24, Y+1	; 0x01
}
    1784:	0f 90       	pop	r0
    1786:	0f 90       	pop	r0
    1788:	0f 90       	pop	r0
    178a:	cf 91       	pop	r28
    178c:	df 91       	pop	r29
    178e:	08 95       	ret

00001790 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    1790:	df 93       	push	r29
    1792:	cf 93       	push	r28
    1794:	00 d0       	rcall	.+0      	; 0x1796 <xQueueIsQueueFullFromISR+0x6>
    1796:	0f 92       	push	r0
    1798:	cd b7       	in	r28, 0x3d	; 61
    179a:	de b7       	in	r29, 0x3e	; 62
    179c:	9b 83       	std	Y+3, r25	; 0x03
    179e:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    17a0:	ea 81       	ldd	r30, Y+2	; 0x02
    17a2:	fb 81       	ldd	r31, Y+3	; 0x03
    17a4:	92 8d       	ldd	r25, Z+26	; 0x1a
    17a6:	ea 81       	ldd	r30, Y+2	; 0x02
    17a8:	fb 81       	ldd	r31, Y+3	; 0x03
    17aa:	83 8d       	ldd	r24, Z+27	; 0x1b
    17ac:	19 82       	std	Y+1, r1	; 0x01
    17ae:	98 17       	cp	r25, r24
    17b0:	11 f4       	brne	.+4      	; 0x17b6 <xQueueIsQueueFullFromISR+0x26>
    17b2:	81 e0       	ldi	r24, 0x01	; 1
    17b4:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    17b6:	89 81       	ldd	r24, Y+1	; 0x01
}
    17b8:	0f 90       	pop	r0
    17ba:	0f 90       	pop	r0
    17bc:	0f 90       	pop	r0
    17be:	cf 91       	pop	r28
    17c0:	df 91       	pop	r29
    17c2:	08 95       	ret

000017c4 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    17c4:	af 92       	push	r10
    17c6:	bf 92       	push	r11
    17c8:	cf 92       	push	r12
    17ca:	df 92       	push	r13
    17cc:	ef 92       	push	r14
    17ce:	ff 92       	push	r15
    17d0:	0f 93       	push	r16
    17d2:	1f 93       	push	r17
    17d4:	df 93       	push	r29
    17d6:	cf 93       	push	r28
    17d8:	cd b7       	in	r28, 0x3d	; 61
    17da:	de b7       	in	r29, 0x3e	; 62
    17dc:	64 97       	sbiw	r28, 0x14	; 20
    17de:	0f b6       	in	r0, 0x3f	; 63
    17e0:	f8 94       	cli
    17e2:	de bf       	out	0x3e, r29	; 62
    17e4:	0f be       	out	0x3f, r0	; 63
    17e6:	cd bf       	out	0x3d, r28	; 61
    17e8:	9f 83       	std	Y+7, r25	; 0x07
    17ea:	8e 83       	std	Y+6, r24	; 0x06
    17ec:	79 87       	std	Y+9, r23	; 0x09
    17ee:	68 87       	std	Y+8, r22	; 0x08
    17f0:	5b 87       	std	Y+11, r21	; 0x0b
    17f2:	4a 87       	std	Y+10, r20	; 0x0a
    17f4:	3d 87       	std	Y+13, r19	; 0x0d
    17f6:	2c 87       	std	Y+12, r18	; 0x0c
    17f8:	0e 87       	std	Y+14, r16	; 0x0e
    17fa:	f8 8a       	std	Y+16, r15	; 0x10
    17fc:	ef 86       	std	Y+15, r14	; 0x0f
    17fe:	da 8a       	std	Y+18, r13	; 0x12
    1800:	c9 8a       	std	Y+17, r12	; 0x11
    1802:	bc 8a       	std	Y+20, r11	; 0x14
    1804:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    1806:	8a 85       	ldd	r24, Y+10	; 0x0a
    1808:	9b 85       	ldd	r25, Y+11	; 0x0b
    180a:	29 89       	ldd	r18, Y+17	; 0x11
    180c:	3a 89       	ldd	r19, Y+18	; 0x12
    180e:	b9 01       	movw	r22, r18
    1810:	0e 94 67 12 	call	0x24ce	; 0x24ce <prvAllocateTCBAndStack>
    1814:	9c 83       	std	Y+4, r25	; 0x04
    1816:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    1818:	8b 81       	ldd	r24, Y+3	; 0x03
    181a:	9c 81       	ldd	r25, Y+4	; 0x04
    181c:	00 97       	sbiw	r24, 0x00	; 0
    181e:	09 f4       	brne	.+2      	; 0x1822 <xTaskGenericCreate+0x5e>
    1820:	99 c0       	rjmp	.+306    	; 0x1954 <xTaskGenericCreate+0x190>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    1822:	eb 81       	ldd	r30, Y+3	; 0x03
    1824:	fc 81       	ldd	r31, Y+4	; 0x04
    1826:	27 89       	ldd	r18, Z+23	; 0x17
    1828:	30 8d       	ldd	r19, Z+24	; 0x18
    182a:	8a 85       	ldd	r24, Y+10	; 0x0a
    182c:	9b 85       	ldd	r25, Y+11	; 0x0b
    182e:	01 97       	sbiw	r24, 0x01	; 1
    1830:	82 0f       	add	r24, r18
    1832:	93 1f       	adc	r25, r19
    1834:	9a 83       	std	Y+2, r25	; 0x02
    1836:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    1838:	8b 81       	ldd	r24, Y+3	; 0x03
    183a:	9c 81       	ldd	r25, Y+4	; 0x04
    183c:	28 85       	ldd	r18, Y+8	; 0x08
    183e:	39 85       	ldd	r19, Y+9	; 0x09
    1840:	eb 89       	ldd	r30, Y+19	; 0x13
    1842:	fc 89       	ldd	r31, Y+20	; 0x14
    1844:	aa 85       	ldd	r26, Y+10	; 0x0a
    1846:	bb 85       	ldd	r27, Y+11	; 0x0b
    1848:	b9 01       	movw	r22, r18
    184a:	4e 85       	ldd	r20, Y+14	; 0x0e
    184c:	9f 01       	movw	r18, r30
    184e:	8d 01       	movw	r16, r26
    1850:	0e 94 4c 11 	call	0x2298	; 0x2298 <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    1854:	89 81       	ldd	r24, Y+1	; 0x01
    1856:	9a 81       	ldd	r25, Y+2	; 0x02
    1858:	2e 81       	ldd	r18, Y+6	; 0x06
    185a:	3f 81       	ldd	r19, Y+7	; 0x07
    185c:	4c 85       	ldd	r20, Y+12	; 0x0c
    185e:	5d 85       	ldd	r21, Y+13	; 0x0d
    1860:	b9 01       	movw	r22, r18
    1862:	0e 94 8f 04 	call	0x91e	; 0x91e <pxPortInitialiseStack>
    1866:	eb 81       	ldd	r30, Y+3	; 0x03
    1868:	fc 81       	ldd	r31, Y+4	; 0x04
    186a:	91 83       	std	Z+1, r25	; 0x01
    186c:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    186e:	8f 85       	ldd	r24, Y+15	; 0x0f
    1870:	98 89       	ldd	r25, Y+16	; 0x10
    1872:	00 97       	sbiw	r24, 0x00	; 0
    1874:	31 f0       	breq	.+12     	; 0x1882 <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    1876:	ef 85       	ldd	r30, Y+15	; 0x0f
    1878:	f8 89       	ldd	r31, Y+16	; 0x10
    187a:	8b 81       	ldd	r24, Y+3	; 0x03
    187c:	9c 81       	ldd	r25, Y+4	; 0x04
    187e:	91 83       	std	Z+1, r25	; 0x01
    1880:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    1882:	0f b6       	in	r0, 0x3f	; 63
    1884:	f8 94       	cli
    1886:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    1888:	80 91 bf 00 	lds	r24, 0x00BF
    188c:	8f 5f       	subi	r24, 0xFF	; 255
    188e:	80 93 bf 00 	sts	0x00BF, r24
			if( pxCurrentTCB == NULL )
    1892:	80 91 bc 00 	lds	r24, 0x00BC
    1896:	90 91 bd 00 	lds	r25, 0x00BD
    189a:	00 97       	sbiw	r24, 0x00	; 0
    189c:	69 f4       	brne	.+26     	; 0x18b8 <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    189e:	8b 81       	ldd	r24, Y+3	; 0x03
    18a0:	9c 81       	ldd	r25, Y+4	; 0x04
    18a2:	90 93 bd 00 	sts	0x00BD, r25
    18a6:	80 93 bc 00 	sts	0x00BC, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    18aa:	80 91 bf 00 	lds	r24, 0x00BF
    18ae:	81 30       	cpi	r24, 0x01	; 1
    18b0:	a9 f4       	brne	.+42     	; 0x18dc <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    18b2:	0e 94 a3 11 	call	0x2346	; 0x2346 <prvInitialiseTaskLists>
    18b6:	12 c0       	rjmp	.+36     	; 0x18dc <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    18b8:	80 91 c4 00 	lds	r24, 0x00C4
    18bc:	88 23       	and	r24, r24
    18be:	71 f4       	brne	.+28     	; 0x18dc <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    18c0:	e0 91 bc 00 	lds	r30, 0x00BC
    18c4:	f0 91 bd 00 	lds	r31, 0x00BD
    18c8:	96 89       	ldd	r25, Z+22	; 0x16
    18ca:	8e 85       	ldd	r24, Y+14	; 0x0e
    18cc:	89 17       	cp	r24, r25
    18ce:	30 f0       	brcs	.+12     	; 0x18dc <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    18d0:	8b 81       	ldd	r24, Y+3	; 0x03
    18d2:	9c 81       	ldd	r25, Y+4	; 0x04
    18d4:	90 93 bd 00 	sts	0x00BD, r25
    18d8:	80 93 bc 00 	sts	0x00BC, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    18dc:	eb 81       	ldd	r30, Y+3	; 0x03
    18de:	fc 81       	ldd	r31, Y+4	; 0x04
    18e0:	96 89       	ldd	r25, Z+22	; 0x16
    18e2:	80 91 c2 00 	lds	r24, 0x00C2
    18e6:	89 17       	cp	r24, r25
    18e8:	28 f4       	brcc	.+10     	; 0x18f4 <xTaskGenericCreate+0x130>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    18ea:	eb 81       	ldd	r30, Y+3	; 0x03
    18ec:	fc 81       	ldd	r31, Y+4	; 0x04
    18ee:	86 89       	ldd	r24, Z+22	; 0x16
    18f0:	80 93 c2 00 	sts	0x00C2, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    18f4:	80 91 c9 00 	lds	r24, 0x00C9
    18f8:	8f 5f       	subi	r24, 0xFF	; 255
    18fa:	80 93 c9 00 	sts	0x00C9, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    18fe:	eb 81       	ldd	r30, Y+3	; 0x03
    1900:	fc 81       	ldd	r31, Y+4	; 0x04
    1902:	96 89       	ldd	r25, Z+22	; 0x16
    1904:	80 91 c3 00 	lds	r24, 0x00C3
    1908:	89 17       	cp	r24, r25
    190a:	28 f4       	brcc	.+10     	; 0x1916 <xTaskGenericCreate+0x152>
    190c:	eb 81       	ldd	r30, Y+3	; 0x03
    190e:	fc 81       	ldd	r31, Y+4	; 0x04
    1910:	86 89       	ldd	r24, Z+22	; 0x16
    1912:	80 93 c3 00 	sts	0x00C3, r24
    1916:	eb 81       	ldd	r30, Y+3	; 0x03
    1918:	fc 81       	ldd	r31, Y+4	; 0x04
    191a:	86 89       	ldd	r24, Z+22	; 0x16
    191c:	28 2f       	mov	r18, r24
    191e:	30 e0       	ldi	r19, 0x00	; 0
    1920:	c9 01       	movw	r24, r18
    1922:	88 0f       	add	r24, r24
    1924:	99 1f       	adc	r25, r25
    1926:	88 0f       	add	r24, r24
    1928:	99 1f       	adc	r25, r25
    192a:	88 0f       	add	r24, r24
    192c:	99 1f       	adc	r25, r25
    192e:	82 0f       	add	r24, r18
    1930:	93 1f       	adc	r25, r19
    1932:	ac 01       	movw	r20, r24
    1934:	46 53       	subi	r20, 0x36	; 54
    1936:	5f 4f       	sbci	r21, 0xFF	; 255
    1938:	8b 81       	ldd	r24, Y+3	; 0x03
    193a:	9c 81       	ldd	r25, Y+4	; 0x04
    193c:	9c 01       	movw	r18, r24
    193e:	2e 5f       	subi	r18, 0xFE	; 254
    1940:	3f 4f       	sbci	r19, 0xFF	; 255
    1942:	ca 01       	movw	r24, r20
    1944:	b9 01       	movw	r22, r18
    1946:	0e 94 8e 03 	call	0x71c	; 0x71c <vListInsertEnd>

			xReturn = pdPASS;
    194a:	81 e0       	ldi	r24, 0x01	; 1
    194c:	8d 83       	std	Y+5, r24	; 0x05
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    194e:	0f 90       	pop	r0
    1950:	0f be       	out	0x3f, r0	; 63
    1952:	02 c0       	rjmp	.+4      	; 0x1958 <xTaskGenericCreate+0x194>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1954:	8f ef       	ldi	r24, 0xFF	; 255
    1956:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    1958:	8d 81       	ldd	r24, Y+5	; 0x05
    195a:	81 30       	cpi	r24, 0x01	; 1
    195c:	71 f4       	brne	.+28     	; 0x197a <xTaskGenericCreate+0x1b6>
	{
		if( xSchedulerRunning != pdFALSE )
    195e:	80 91 c4 00 	lds	r24, 0x00C4
    1962:	88 23       	and	r24, r24
    1964:	51 f0       	breq	.+20     	; 0x197a <xTaskGenericCreate+0x1b6>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    1966:	e0 91 bc 00 	lds	r30, 0x00BC
    196a:	f0 91 bd 00 	lds	r31, 0x00BD
    196e:	96 89       	ldd	r25, Z+22	; 0x16
    1970:	8e 85       	ldd	r24, Y+14	; 0x0e
    1972:	98 17       	cp	r25, r24
    1974:	10 f4       	brcc	.+4      	; 0x197a <xTaskGenericCreate+0x1b6>
			{
				portYIELD_WITHIN_API();
    1976:	0e 94 4e 06 	call	0xc9c	; 0xc9c <vPortYield>
			}
		}
	}

	return xReturn;
    197a:	8d 81       	ldd	r24, Y+5	; 0x05
}
    197c:	64 96       	adiw	r28, 0x14	; 20
    197e:	0f b6       	in	r0, 0x3f	; 63
    1980:	f8 94       	cli
    1982:	de bf       	out	0x3e, r29	; 62
    1984:	0f be       	out	0x3f, r0	; 63
    1986:	cd bf       	out	0x3d, r28	; 61
    1988:	cf 91       	pop	r28
    198a:	df 91       	pop	r29
    198c:	1f 91       	pop	r17
    198e:	0f 91       	pop	r16
    1990:	ff 90       	pop	r15
    1992:	ef 90       	pop	r14
    1994:	df 90       	pop	r13
    1996:	cf 90       	pop	r12
    1998:	bf 90       	pop	r11
    199a:	af 90       	pop	r10
    199c:	08 95       	ret

0000199e <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    199e:	df 93       	push	r29
    19a0:	cf 93       	push	r28
    19a2:	00 d0       	rcall	.+0      	; 0x19a4 <vTaskDelete+0x6>
    19a4:	00 d0       	rcall	.+0      	; 0x19a6 <vTaskDelete+0x8>
    19a6:	00 d0       	rcall	.+0      	; 0x19a8 <vTaskDelete+0xa>
    19a8:	cd b7       	in	r28, 0x3d	; 61
    19aa:	de b7       	in	r29, 0x3e	; 62
    19ac:	9c 83       	std	Y+4, r25	; 0x04
    19ae:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    19b0:	0f b6       	in	r0, 0x3f	; 63
    19b2:	f8 94       	cli
    19b4:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    19b6:	20 91 bc 00 	lds	r18, 0x00BC
    19ba:	30 91 bd 00 	lds	r19, 0x00BD
    19be:	8b 81       	ldd	r24, Y+3	; 0x03
    19c0:	9c 81       	ldd	r25, Y+4	; 0x04
    19c2:	82 17       	cp	r24, r18
    19c4:	93 07       	cpc	r25, r19
    19c6:	11 f4       	brne	.+4      	; 0x19cc <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
    19c8:	1c 82       	std	Y+4, r1	; 0x04
    19ca:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    19cc:	8b 81       	ldd	r24, Y+3	; 0x03
    19ce:	9c 81       	ldd	r25, Y+4	; 0x04
    19d0:	00 97       	sbiw	r24, 0x00	; 0
    19d2:	39 f4       	brne	.+14     	; 0x19e2 <vTaskDelete+0x44>
    19d4:	80 91 bc 00 	lds	r24, 0x00BC
    19d8:	90 91 bd 00 	lds	r25, 0x00BD
    19dc:	9e 83       	std	Y+6, r25	; 0x06
    19de:	8d 83       	std	Y+5, r24	; 0x05
    19e0:	04 c0       	rjmp	.+8      	; 0x19ea <vTaskDelete+0x4c>
    19e2:	8b 81       	ldd	r24, Y+3	; 0x03
    19e4:	9c 81       	ldd	r25, Y+4	; 0x04
    19e6:	9e 83       	std	Y+6, r25	; 0x06
    19e8:	8d 83       	std	Y+5, r24	; 0x05
    19ea:	8d 81       	ldd	r24, Y+5	; 0x05
    19ec:	9e 81       	ldd	r25, Y+6	; 0x06
    19ee:	9a 83       	std	Y+2, r25	; 0x02
    19f0:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    19f2:	89 81       	ldd	r24, Y+1	; 0x01
    19f4:	9a 81       	ldd	r25, Y+2	; 0x02
    19f6:	02 96       	adiw	r24, 0x02	; 2
    19f8:	0e 94 46 04 	call	0x88c	; 0x88c <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    19fc:	e9 81       	ldd	r30, Y+1	; 0x01
    19fe:	fa 81       	ldd	r31, Y+2	; 0x02
    1a00:	84 89       	ldd	r24, Z+20	; 0x14
    1a02:	95 89       	ldd	r25, Z+21	; 0x15
    1a04:	00 97       	sbiw	r24, 0x00	; 0
    1a06:	29 f0       	breq	.+10     	; 0x1a12 <vTaskDelete+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    1a08:	89 81       	ldd	r24, Y+1	; 0x01
    1a0a:	9a 81       	ldd	r25, Y+2	; 0x02
    1a0c:	0c 96       	adiw	r24, 0x0c	; 12
    1a0e:	0e 94 46 04 	call	0x88c	; 0x88c <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    1a12:	89 81       	ldd	r24, Y+1	; 0x01
    1a14:	9a 81       	ldd	r25, Y+2	; 0x02
    1a16:	9c 01       	movw	r18, r24
    1a18:	2e 5f       	subi	r18, 0xFE	; 254
    1a1a:	3f 4f       	sbci	r19, 0xFF	; 255
    1a1c:	8b ef       	ldi	r24, 0xFB	; 251
    1a1e:	90 e0       	ldi	r25, 0x00	; 0
    1a20:	b9 01       	movw	r22, r18
    1a22:	0e 94 8e 03 	call	0x71c	; 0x71c <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    1a26:	80 91 be 00 	lds	r24, 0x00BE
    1a2a:	8f 5f       	subi	r24, 0xFF	; 255
    1a2c:	80 93 be 00 	sts	0x00BE, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    1a30:	80 91 c9 00 	lds	r24, 0x00C9
    1a34:	8f 5f       	subi	r24, 0xFF	; 255
    1a36:	80 93 c9 00 	sts	0x00C9, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    1a3a:	0f 90       	pop	r0
    1a3c:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    1a3e:	80 91 c4 00 	lds	r24, 0x00C4
    1a42:	88 23       	and	r24, r24
    1a44:	31 f0       	breq	.+12     	; 0x1a52 <vTaskDelete+0xb4>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    1a46:	8b 81       	ldd	r24, Y+3	; 0x03
    1a48:	9c 81       	ldd	r25, Y+4	; 0x04
    1a4a:	00 97       	sbiw	r24, 0x00	; 0
    1a4c:	11 f4       	brne	.+4      	; 0x1a52 <vTaskDelete+0xb4>
			{
				portYIELD_WITHIN_API();
    1a4e:	0e 94 4e 06 	call	0xc9c	; 0xc9c <vPortYield>
			}
		}
	}
    1a52:	26 96       	adiw	r28, 0x06	; 6
    1a54:	0f b6       	in	r0, 0x3f	; 63
    1a56:	f8 94       	cli
    1a58:	de bf       	out	0x3e, r29	; 62
    1a5a:	0f be       	out	0x3f, r0	; 63
    1a5c:	cd bf       	out	0x3d, r28	; 61
    1a5e:	cf 91       	pop	r28
    1a60:	df 91       	pop	r29
    1a62:	08 95       	ret

00001a64 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    1a64:	df 93       	push	r29
    1a66:	cf 93       	push	r28
    1a68:	cd b7       	in	r28, 0x3d	; 61
    1a6a:	de b7       	in	r29, 0x3e	; 62
    1a6c:	28 97       	sbiw	r28, 0x08	; 8
    1a6e:	0f b6       	in	r0, 0x3f	; 63
    1a70:	f8 94       	cli
    1a72:	de bf       	out	0x3e, r29	; 62
    1a74:	0f be       	out	0x3f, r0	; 63
    1a76:	cd bf       	out	0x3d, r28	; 61
    1a78:	9e 83       	std	Y+6, r25	; 0x06
    1a7a:	8d 83       	std	Y+5, r24	; 0x05
    1a7c:	78 87       	std	Y+8, r23	; 0x08
    1a7e:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    1a80:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    1a82:	0e 94 1e 0e 	call	0x1c3c	; 0x1c3c <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    1a86:	ed 81       	ldd	r30, Y+5	; 0x05
    1a88:	fe 81       	ldd	r31, Y+6	; 0x06
    1a8a:	20 81       	ld	r18, Z
    1a8c:	31 81       	ldd	r19, Z+1	; 0x01
    1a8e:	8f 81       	ldd	r24, Y+7	; 0x07
    1a90:	98 85       	ldd	r25, Y+8	; 0x08
    1a92:	82 0f       	add	r24, r18
    1a94:	93 1f       	adc	r25, r19
    1a96:	9c 83       	std	Y+4, r25	; 0x04
    1a98:	8b 83       	std	Y+3, r24	; 0x03

			if( xTickCount < *pxPreviousWakeTime )
    1a9a:	ed 81       	ldd	r30, Y+5	; 0x05
    1a9c:	fe 81       	ldd	r31, Y+6	; 0x06
    1a9e:	20 81       	ld	r18, Z
    1aa0:	31 81       	ldd	r19, Z+1	; 0x01
    1aa2:	80 91 c0 00 	lds	r24, 0x00C0
    1aa6:	90 91 c1 00 	lds	r25, 0x00C1
    1aaa:	82 17       	cp	r24, r18
    1aac:	93 07       	cpc	r25, r19
    1aae:	a8 f4       	brcc	.+42     	; 0x1ada <vTaskDelayUntil+0x76>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    1ab0:	ed 81       	ldd	r30, Y+5	; 0x05
    1ab2:	fe 81       	ldd	r31, Y+6	; 0x06
    1ab4:	20 81       	ld	r18, Z
    1ab6:	31 81       	ldd	r19, Z+1	; 0x01
    1ab8:	8b 81       	ldd	r24, Y+3	; 0x03
    1aba:	9c 81       	ldd	r25, Y+4	; 0x04
    1abc:	82 17       	cp	r24, r18
    1abe:	93 07       	cpc	r25, r19
    1ac0:	00 f5       	brcc	.+64     	; 0x1b02 <vTaskDelayUntil+0x9e>
    1ac2:	20 91 c0 00 	lds	r18, 0x00C0
    1ac6:	30 91 c1 00 	lds	r19, 0x00C1
    1aca:	8b 81       	ldd	r24, Y+3	; 0x03
    1acc:	9c 81       	ldd	r25, Y+4	; 0x04
    1ace:	28 17       	cp	r18, r24
    1ad0:	39 07       	cpc	r19, r25
    1ad2:	b8 f4       	brcc	.+46     	; 0x1b02 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    1ad4:	81 e0       	ldi	r24, 0x01	; 1
    1ad6:	89 83       	std	Y+1, r24	; 0x01
    1ad8:	14 c0       	rjmp	.+40     	; 0x1b02 <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    1ada:	ed 81       	ldd	r30, Y+5	; 0x05
    1adc:	fe 81       	ldd	r31, Y+6	; 0x06
    1ade:	20 81       	ld	r18, Z
    1ae0:	31 81       	ldd	r19, Z+1	; 0x01
    1ae2:	8b 81       	ldd	r24, Y+3	; 0x03
    1ae4:	9c 81       	ldd	r25, Y+4	; 0x04
    1ae6:	82 17       	cp	r24, r18
    1ae8:	93 07       	cpc	r25, r19
    1aea:	48 f0       	brcs	.+18     	; 0x1afe <vTaskDelayUntil+0x9a>
    1aec:	20 91 c0 00 	lds	r18, 0x00C0
    1af0:	30 91 c1 00 	lds	r19, 0x00C1
    1af4:	8b 81       	ldd	r24, Y+3	; 0x03
    1af6:	9c 81       	ldd	r25, Y+4	; 0x04
    1af8:	28 17       	cp	r18, r24
    1afa:	39 07       	cpc	r19, r25
    1afc:	10 f4       	brcc	.+4      	; 0x1b02 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    1afe:	81 e0       	ldi	r24, 0x01	; 1
    1b00:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    1b02:	ed 81       	ldd	r30, Y+5	; 0x05
    1b04:	fe 81       	ldd	r31, Y+6	; 0x06
    1b06:	8b 81       	ldd	r24, Y+3	; 0x03
    1b08:	9c 81       	ldd	r25, Y+4	; 0x04
    1b0a:	91 83       	std	Z+1, r25	; 0x01
    1b0c:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    1b0e:	89 81       	ldd	r24, Y+1	; 0x01
    1b10:	88 23       	and	r24, r24
    1b12:	59 f0       	breq	.+22     	; 0x1b2a <vTaskDelayUntil+0xc6>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1b14:	80 91 bc 00 	lds	r24, 0x00BC
    1b18:	90 91 bd 00 	lds	r25, 0x00BD
    1b1c:	02 96       	adiw	r24, 0x02	; 2
    1b1e:	0e 94 46 04 	call	0x88c	; 0x88c <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1b22:	8b 81       	ldd	r24, Y+3	; 0x03
    1b24:	9c 81       	ldd	r25, Y+4	; 0x04
    1b26:	0e 94 1e 12 	call	0x243c	; 0x243c <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    1b2a:	0e 94 2a 0e 	call	0x1c54	; 0x1c54 <xTaskResumeAll>
    1b2e:	8a 83       	std	Y+2, r24	; 0x02

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1b30:	8a 81       	ldd	r24, Y+2	; 0x02
    1b32:	88 23       	and	r24, r24
    1b34:	11 f4       	brne	.+4      	; 0x1b3a <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    1b36:	0e 94 4e 06 	call	0xc9c	; 0xc9c <vPortYield>
		}
	}
    1b3a:	28 96       	adiw	r28, 0x08	; 8
    1b3c:	0f b6       	in	r0, 0x3f	; 63
    1b3e:	f8 94       	cli
    1b40:	de bf       	out	0x3e, r29	; 62
    1b42:	0f be       	out	0x3f, r0	; 63
    1b44:	cd bf       	out	0x3d, r28	; 61
    1b46:	cf 91       	pop	r28
    1b48:	df 91       	pop	r29
    1b4a:	08 95       	ret

00001b4c <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    1b4c:	df 93       	push	r29
    1b4e:	cf 93       	push	r28
    1b50:	00 d0       	rcall	.+0      	; 0x1b52 <vTaskDelay+0x6>
    1b52:	00 d0       	rcall	.+0      	; 0x1b54 <vTaskDelay+0x8>
    1b54:	0f 92       	push	r0
    1b56:	cd b7       	in	r28, 0x3d	; 61
    1b58:	de b7       	in	r29, 0x3e	; 62
    1b5a:	9d 83       	std	Y+5, r25	; 0x05
    1b5c:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    1b5e:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    1b60:	8c 81       	ldd	r24, Y+4	; 0x04
    1b62:	9d 81       	ldd	r25, Y+5	; 0x05
    1b64:	00 97       	sbiw	r24, 0x00	; 0
    1b66:	d1 f0       	breq	.+52     	; 0x1b9c <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
    1b68:	0e 94 1e 0e 	call	0x1c3c	; 0x1c3c <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    1b6c:	20 91 c0 00 	lds	r18, 0x00C0
    1b70:	30 91 c1 00 	lds	r19, 0x00C1
    1b74:	8c 81       	ldd	r24, Y+4	; 0x04
    1b76:	9d 81       	ldd	r25, Y+5	; 0x05
    1b78:	82 0f       	add	r24, r18
    1b7a:	93 1f       	adc	r25, r19
    1b7c:	9b 83       	std	Y+3, r25	; 0x03
    1b7e:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1b80:	80 91 bc 00 	lds	r24, 0x00BC
    1b84:	90 91 bd 00 	lds	r25, 0x00BD
    1b88:	02 96       	adiw	r24, 0x02	; 2
    1b8a:	0e 94 46 04 	call	0x88c	; 0x88c <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1b8e:	8a 81       	ldd	r24, Y+2	; 0x02
    1b90:	9b 81       	ldd	r25, Y+3	; 0x03
    1b92:	0e 94 1e 12 	call	0x243c	; 0x243c <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    1b96:	0e 94 2a 0e 	call	0x1c54	; 0x1c54 <xTaskResumeAll>
    1b9a:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1b9c:	89 81       	ldd	r24, Y+1	; 0x01
    1b9e:	88 23       	and	r24, r24
    1ba0:	11 f4       	brne	.+4      	; 0x1ba6 <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    1ba2:	0e 94 4e 06 	call	0xc9c	; 0xc9c <vPortYield>
		}
	}
    1ba6:	0f 90       	pop	r0
    1ba8:	0f 90       	pop	r0
    1baa:	0f 90       	pop	r0
    1bac:	0f 90       	pop	r0
    1bae:	0f 90       	pop	r0
    1bb0:	cf 91       	pop	r28
    1bb2:	df 91       	pop	r29
    1bb4:	08 95       	ret

00001bb6 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    1bb6:	af 92       	push	r10
    1bb8:	bf 92       	push	r11
    1bba:	cf 92       	push	r12
    1bbc:	df 92       	push	r13
    1bbe:	ef 92       	push	r14
    1bc0:	ff 92       	push	r15
    1bc2:	0f 93       	push	r16
    1bc4:	df 93       	push	r29
    1bc6:	cf 93       	push	r28
    1bc8:	0f 92       	push	r0
    1bca:	cd b7       	in	r28, 0x3d	; 61
    1bcc:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    1bce:	20 e6       	ldi	r18, 0x60	; 96
    1bd0:	30 e0       	ldi	r19, 0x00	; 0
    1bd2:	82 e4       	ldi	r24, 0x42	; 66
    1bd4:	91 e1       	ldi	r25, 0x11	; 17
    1bd6:	b9 01       	movw	r22, r18
    1bd8:	45 e5       	ldi	r20, 0x55	; 85
    1bda:	50 e0       	ldi	r21, 0x00	; 0
    1bdc:	20 e0       	ldi	r18, 0x00	; 0
    1bde:	30 e0       	ldi	r19, 0x00	; 0
    1be0:	00 e0       	ldi	r16, 0x00	; 0
    1be2:	ee 24       	eor	r14, r14
    1be4:	ff 24       	eor	r15, r15
    1be6:	cc 24       	eor	r12, r12
    1be8:	dd 24       	eor	r13, r13
    1bea:	aa 24       	eor	r10, r10
    1bec:	bb 24       	eor	r11, r11
    1bee:	0e 94 e2 0b 	call	0x17c4	; 0x17c4 <xTaskGenericCreate>
    1bf2:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    1bf4:	89 81       	ldd	r24, Y+1	; 0x01
    1bf6:	81 30       	cpi	r24, 0x01	; 1
    1bf8:	51 f4       	brne	.+20     	; 0x1c0e <vTaskStartScheduler+0x58>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    1bfa:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    1bfc:	81 e0       	ldi	r24, 0x01	; 1
    1bfe:	80 93 c4 00 	sts	0x00C4, r24
		xTickCount = ( portTickType ) 0U;
    1c02:	10 92 c1 00 	sts	0x00C1, r1
    1c06:	10 92 c0 00 	sts	0x00C0, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    1c0a:	0e 94 12 06 	call	0xc24	; 0xc24 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    1c0e:	0f 90       	pop	r0
    1c10:	cf 91       	pop	r28
    1c12:	df 91       	pop	r29
    1c14:	0f 91       	pop	r16
    1c16:	ff 90       	pop	r15
    1c18:	ef 90       	pop	r14
    1c1a:	df 90       	pop	r13
    1c1c:	cf 90       	pop	r12
    1c1e:	bf 90       	pop	r11
    1c20:	af 90       	pop	r10
    1c22:	08 95       	ret

00001c24 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    1c24:	df 93       	push	r29
    1c26:	cf 93       	push	r28
    1c28:	cd b7       	in	r28, 0x3d	; 61
    1c2a:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    1c2c:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    1c2e:	10 92 c4 00 	sts	0x00C4, r1
	vPortEndScheduler();
    1c32:	0e 94 47 06 	call	0xc8e	; 0xc8e <vPortEndScheduler>
}
    1c36:	cf 91       	pop	r28
    1c38:	df 91       	pop	r29
    1c3a:	08 95       	ret

00001c3c <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    1c3c:	df 93       	push	r29
    1c3e:	cf 93       	push	r28
    1c40:	cd b7       	in	r28, 0x3d	; 61
    1c42:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    1c44:	80 91 c5 00 	lds	r24, 0x00C5
    1c48:	8f 5f       	subi	r24, 0xFF	; 255
    1c4a:	80 93 c5 00 	sts	0x00C5, r24
}
    1c4e:	cf 91       	pop	r28
    1c50:	df 91       	pop	r29
    1c52:	08 95       	ret

00001c54 <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    1c54:	df 93       	push	r29
    1c56:	cf 93       	push	r28
    1c58:	00 d0       	rcall	.+0      	; 0x1c5a <xTaskResumeAll+0x6>
    1c5a:	00 d0       	rcall	.+0      	; 0x1c5c <xTaskResumeAll+0x8>
    1c5c:	cd b7       	in	r28, 0x3d	; 61
    1c5e:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    1c60:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    1c62:	0f b6       	in	r0, 0x3f	; 63
    1c64:	f8 94       	cli
    1c66:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    1c68:	80 91 c5 00 	lds	r24, 0x00C5
    1c6c:	81 50       	subi	r24, 0x01	; 1
    1c6e:	80 93 c5 00 	sts	0x00C5, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1c72:	80 91 c5 00 	lds	r24, 0x00C5
    1c76:	88 23       	and	r24, r24
    1c78:	09 f0       	breq	.+2      	; 0x1c7c <xTaskResumeAll+0x28>
    1c7a:	6c c0       	rjmp	.+216    	; 0x1d54 <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    1c7c:	80 91 bf 00 	lds	r24, 0x00BF
    1c80:	88 23       	and	r24, r24
    1c82:	09 f4       	brne	.+2      	; 0x1c86 <xTaskResumeAll+0x32>
    1c84:	67 c0       	rjmp	.+206    	; 0x1d54 <xTaskResumeAll+0x100>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
    1c86:	19 82       	std	Y+1, r1	; 0x01
    1c88:	41 c0       	rjmp	.+130    	; 0x1d0c <xTaskResumeAll+0xb8>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    1c8a:	e0 91 f7 00 	lds	r30, 0x00F7
    1c8e:	f0 91 f8 00 	lds	r31, 0x00F8
    1c92:	86 81       	ldd	r24, Z+6	; 0x06
    1c94:	97 81       	ldd	r25, Z+7	; 0x07
    1c96:	9c 83       	std	Y+4, r25	; 0x04
    1c98:	8b 83       	std	Y+3, r24	; 0x03
					vListRemove( &( pxTCB->xEventListItem ) );
    1c9a:	8b 81       	ldd	r24, Y+3	; 0x03
    1c9c:	9c 81       	ldd	r25, Y+4	; 0x04
    1c9e:	0c 96       	adiw	r24, 0x0c	; 12
    1ca0:	0e 94 46 04 	call	0x88c	; 0x88c <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    1ca4:	8b 81       	ldd	r24, Y+3	; 0x03
    1ca6:	9c 81       	ldd	r25, Y+4	; 0x04
    1ca8:	02 96       	adiw	r24, 0x02	; 2
    1caa:	0e 94 46 04 	call	0x88c	; 0x88c <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    1cae:	eb 81       	ldd	r30, Y+3	; 0x03
    1cb0:	fc 81       	ldd	r31, Y+4	; 0x04
    1cb2:	96 89       	ldd	r25, Z+22	; 0x16
    1cb4:	80 91 c3 00 	lds	r24, 0x00C3
    1cb8:	89 17       	cp	r24, r25
    1cba:	28 f4       	brcc	.+10     	; 0x1cc6 <xTaskResumeAll+0x72>
    1cbc:	eb 81       	ldd	r30, Y+3	; 0x03
    1cbe:	fc 81       	ldd	r31, Y+4	; 0x04
    1cc0:	86 89       	ldd	r24, Z+22	; 0x16
    1cc2:	80 93 c3 00 	sts	0x00C3, r24
    1cc6:	eb 81       	ldd	r30, Y+3	; 0x03
    1cc8:	fc 81       	ldd	r31, Y+4	; 0x04
    1cca:	86 89       	ldd	r24, Z+22	; 0x16
    1ccc:	28 2f       	mov	r18, r24
    1cce:	30 e0       	ldi	r19, 0x00	; 0
    1cd0:	c9 01       	movw	r24, r18
    1cd2:	88 0f       	add	r24, r24
    1cd4:	99 1f       	adc	r25, r25
    1cd6:	88 0f       	add	r24, r24
    1cd8:	99 1f       	adc	r25, r25
    1cda:	88 0f       	add	r24, r24
    1cdc:	99 1f       	adc	r25, r25
    1cde:	82 0f       	add	r24, r18
    1ce0:	93 1f       	adc	r25, r19
    1ce2:	86 53       	subi	r24, 0x36	; 54
    1ce4:	9f 4f       	sbci	r25, 0xFF	; 255
    1ce6:	2b 81       	ldd	r18, Y+3	; 0x03
    1ce8:	3c 81       	ldd	r19, Y+4	; 0x04
    1cea:	2e 5f       	subi	r18, 0xFE	; 254
    1cec:	3f 4f       	sbci	r19, 0xFF	; 255
    1cee:	b9 01       	movw	r22, r18
    1cf0:	0e 94 8e 03 	call	0x71c	; 0x71c <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1cf4:	eb 81       	ldd	r30, Y+3	; 0x03
    1cf6:	fc 81       	ldd	r31, Y+4	; 0x04
    1cf8:	96 89       	ldd	r25, Z+22	; 0x16
    1cfa:	e0 91 bc 00 	lds	r30, 0x00BC
    1cfe:	f0 91 bd 00 	lds	r31, 0x00BD
    1d02:	86 89       	ldd	r24, Z+22	; 0x16
    1d04:	98 17       	cp	r25, r24
    1d06:	10 f0       	brcs	.+4      	; 0x1d0c <xTaskResumeAll+0xb8>
					{
						xYieldRequired = pdTRUE;
    1d08:	81 e0       	ldi	r24, 0x01	; 1
    1d0a:	89 83       	std	Y+1, r24	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    1d0c:	80 91 f2 00 	lds	r24, 0x00F2
    1d10:	88 23       	and	r24, r24
    1d12:	09 f0       	breq	.+2      	; 0x1d16 <xTaskResumeAll+0xc2>
    1d14:	ba cf       	rjmp	.-140    	; 0x1c8a <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1d16:	80 91 c6 00 	lds	r24, 0x00C6
    1d1a:	88 23       	and	r24, r24
    1d1c:	71 f0       	breq	.+28     	; 0x1d3a <xTaskResumeAll+0xe6>
    1d1e:	07 c0       	rjmp	.+14     	; 0x1d2e <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
    1d20:	0e 94 e9 0e 	call	0x1dd2	; 0x1dd2 <vTaskIncrementTick>
						--uxMissedTicks;
    1d24:	80 91 c6 00 	lds	r24, 0x00C6
    1d28:	81 50       	subi	r24, 0x01	; 1
    1d2a:	80 93 c6 00 	sts	0x00C6, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1d2e:	80 91 c6 00 	lds	r24, 0x00C6
    1d32:	88 23       	and	r24, r24
    1d34:	a9 f7       	brne	.-22     	; 0x1d20 <xTaskResumeAll+0xcc>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
    1d36:	81 e0       	ldi	r24, 0x01	; 1
    1d38:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    1d3a:	89 81       	ldd	r24, Y+1	; 0x01
    1d3c:	81 30       	cpi	r24, 0x01	; 1
    1d3e:	21 f0       	breq	.+8      	; 0x1d48 <xTaskResumeAll+0xf4>
    1d40:	80 91 c7 00 	lds	r24, 0x00C7
    1d44:	81 30       	cpi	r24, 0x01	; 1
    1d46:	31 f4       	brne	.+12     	; 0x1d54 <xTaskResumeAll+0x100>
				{
					xAlreadyYielded = pdTRUE;
    1d48:	81 e0       	ldi	r24, 0x01	; 1
    1d4a:	8a 83       	std	Y+2, r24	; 0x02
					xMissedYield = pdFALSE;
    1d4c:	10 92 c7 00 	sts	0x00C7, r1
					portYIELD_WITHIN_API();
    1d50:	0e 94 4e 06 	call	0xc9c	; 0xc9c <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    1d54:	0f 90       	pop	r0
    1d56:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    1d58:	8a 81       	ldd	r24, Y+2	; 0x02
}
    1d5a:	0f 90       	pop	r0
    1d5c:	0f 90       	pop	r0
    1d5e:	0f 90       	pop	r0
    1d60:	0f 90       	pop	r0
    1d62:	cf 91       	pop	r28
    1d64:	df 91       	pop	r29
    1d66:	08 95       	ret

00001d68 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
    1d68:	df 93       	push	r29
    1d6a:	cf 93       	push	r28
    1d6c:	00 d0       	rcall	.+0      	; 0x1d6e <xTaskGetTickCount+0x6>
    1d6e:	cd b7       	in	r28, 0x3d	; 61
    1d70:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    1d72:	0f b6       	in	r0, 0x3f	; 63
    1d74:	f8 94       	cli
    1d76:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    1d78:	80 91 c0 00 	lds	r24, 0x00C0
    1d7c:	90 91 c1 00 	lds	r25, 0x00C1
    1d80:	9a 83       	std	Y+2, r25	; 0x02
    1d82:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    1d84:	0f 90       	pop	r0
    1d86:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    1d88:	89 81       	ldd	r24, Y+1	; 0x01
    1d8a:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1d8c:	0f 90       	pop	r0
    1d8e:	0f 90       	pop	r0
    1d90:	cf 91       	pop	r28
    1d92:	df 91       	pop	r29
    1d94:	08 95       	ret

00001d96 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
    1d96:	df 93       	push	r29
    1d98:	cf 93       	push	r28
    1d9a:	00 d0       	rcall	.+0      	; 0x1d9c <xTaskGetTickCountFromISR+0x6>
    1d9c:	0f 92       	push	r0
    1d9e:	cd b7       	in	r28, 0x3d	; 61
    1da0:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1da2:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
    1da4:	80 91 c0 00 	lds	r24, 0x00C0
    1da8:	90 91 c1 00 	lds	r25, 0x00C1
    1dac:	9b 83       	std	Y+3, r25	; 0x03
    1dae:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1db0:	8a 81       	ldd	r24, Y+2	; 0x02
    1db2:	9b 81       	ldd	r25, Y+3	; 0x03
}
    1db4:	0f 90       	pop	r0
    1db6:	0f 90       	pop	r0
    1db8:	0f 90       	pop	r0
    1dba:	cf 91       	pop	r28
    1dbc:	df 91       	pop	r29
    1dbe:	08 95       	ret

00001dc0 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
    1dc0:	df 93       	push	r29
    1dc2:	cf 93       	push	r28
    1dc4:	cd b7       	in	r28, 0x3d	; 61
    1dc6:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    1dc8:	80 91 bf 00 	lds	r24, 0x00BF
}
    1dcc:	cf 91       	pop	r28
    1dce:	df 91       	pop	r29
    1dd0:	08 95       	ret

00001dd2 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    1dd2:	df 93       	push	r29
    1dd4:	cf 93       	push	r28
    1dd6:	00 d0       	rcall	.+0      	; 0x1dd8 <vTaskIncrementTick+0x6>
    1dd8:	00 d0       	rcall	.+0      	; 0x1dda <vTaskIncrementTick+0x8>
    1dda:	00 d0       	rcall	.+0      	; 0x1ddc <vTaskIncrementTick+0xa>
    1ddc:	cd b7       	in	r28, 0x3d	; 61
    1dde:	de b7       	in	r29, 0x3e	; 62
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1de0:	80 91 c5 00 	lds	r24, 0x00C5
    1de4:	88 23       	and	r24, r24
    1de6:	09 f0       	breq	.+2      	; 0x1dea <vTaskIncrementTick+0x18>
    1de8:	bb c0       	rjmp	.+374    	; 0x1f60 <vTaskIncrementTick+0x18e>
	{
		++xTickCount;
    1dea:	80 91 c0 00 	lds	r24, 0x00C0
    1dee:	90 91 c1 00 	lds	r25, 0x00C1
    1df2:	01 96       	adiw	r24, 0x01	; 1
    1df4:	90 93 c1 00 	sts	0x00C1, r25
    1df8:	80 93 c0 00 	sts	0x00C0, r24
		if( xTickCount == ( portTickType ) 0U )
    1dfc:	80 91 c0 00 	lds	r24, 0x00C0
    1e00:	90 91 c1 00 	lds	r25, 0x00C1
    1e04:	00 97       	sbiw	r24, 0x00	; 0
    1e06:	d1 f5       	brne	.+116    	; 0x1e7c <vTaskIncrementTick+0xaa>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    1e08:	80 91 ee 00 	lds	r24, 0x00EE
    1e0c:	90 91 ef 00 	lds	r25, 0x00EF
    1e10:	9c 83       	std	Y+4, r25	; 0x04
    1e12:	8b 83       	std	Y+3, r24	; 0x03
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    1e14:	80 91 f0 00 	lds	r24, 0x00F0
    1e18:	90 91 f1 00 	lds	r25, 0x00F1
    1e1c:	90 93 ef 00 	sts	0x00EF, r25
    1e20:	80 93 ee 00 	sts	0x00EE, r24
			pxOverflowDelayedTaskList = pxTemp;
    1e24:	8b 81       	ldd	r24, Y+3	; 0x03
    1e26:	9c 81       	ldd	r25, Y+4	; 0x04
    1e28:	90 93 f1 00 	sts	0x00F1, r25
    1e2c:	80 93 f0 00 	sts	0x00F0, r24
			xNumOfOverflows++;
    1e30:	80 91 c8 00 	lds	r24, 0x00C8
    1e34:	8f 5f       	subi	r24, 0xFF	; 255
    1e36:	80 93 c8 00 	sts	0x00C8, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1e3a:	e0 91 ee 00 	lds	r30, 0x00EE
    1e3e:	f0 91 ef 00 	lds	r31, 0x00EF
    1e42:	80 81       	ld	r24, Z
    1e44:	88 23       	and	r24, r24
    1e46:	39 f4       	brne	.+14     	; 0x1e56 <vTaskIncrementTick+0x84>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    1e48:	8f ef       	ldi	r24, 0xFF	; 255
    1e4a:	9f ef       	ldi	r25, 0xFF	; 255
    1e4c:	90 93 81 00 	sts	0x0081, r25
    1e50:	80 93 80 00 	sts	0x0080, r24
    1e54:	13 c0       	rjmp	.+38     	; 0x1e7c <vTaskIncrementTick+0xaa>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    1e56:	e0 91 ee 00 	lds	r30, 0x00EE
    1e5a:	f0 91 ef 00 	lds	r31, 0x00EF
    1e5e:	05 80       	ldd	r0, Z+5	; 0x05
    1e60:	f6 81       	ldd	r31, Z+6	; 0x06
    1e62:	e0 2d       	mov	r30, r0
    1e64:	86 81       	ldd	r24, Z+6	; 0x06
    1e66:	97 81       	ldd	r25, Z+7	; 0x07
    1e68:	9e 83       	std	Y+6, r25	; 0x06
    1e6a:	8d 83       	std	Y+5, r24	; 0x05
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    1e6c:	ed 81       	ldd	r30, Y+5	; 0x05
    1e6e:	fe 81       	ldd	r31, Y+6	; 0x06
    1e70:	82 81       	ldd	r24, Z+2	; 0x02
    1e72:	93 81       	ldd	r25, Z+3	; 0x03
    1e74:	90 93 81 00 	sts	0x0081, r25
    1e78:	80 93 80 00 	sts	0x0080, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    1e7c:	20 91 c0 00 	lds	r18, 0x00C0
    1e80:	30 91 c1 00 	lds	r19, 0x00C1
    1e84:	80 91 80 00 	lds	r24, 0x0080
    1e88:	90 91 81 00 	lds	r25, 0x0081
    1e8c:	28 17       	cp	r18, r24
    1e8e:	39 07       	cpc	r19, r25
    1e90:	08 f4       	brcc	.+2      	; 0x1e94 <vTaskIncrementTick+0xc2>
    1e92:	6b c0       	rjmp	.+214    	; 0x1f6a <vTaskIncrementTick+0x198>
    1e94:	e0 91 ee 00 	lds	r30, 0x00EE
    1e98:	f0 91 ef 00 	lds	r31, 0x00EF
    1e9c:	80 81       	ld	r24, Z
    1e9e:	88 23       	and	r24, r24
    1ea0:	39 f4       	brne	.+14     	; 0x1eb0 <vTaskIncrementTick+0xde>
    1ea2:	8f ef       	ldi	r24, 0xFF	; 255
    1ea4:	9f ef       	ldi	r25, 0xFF	; 255
    1ea6:	90 93 81 00 	sts	0x0081, r25
    1eaa:	80 93 80 00 	sts	0x0080, r24
    1eae:	5d c0       	rjmp	.+186    	; 0x1f6a <vTaskIncrementTick+0x198>
    1eb0:	e0 91 ee 00 	lds	r30, 0x00EE
    1eb4:	f0 91 ef 00 	lds	r31, 0x00EF
    1eb8:	05 80       	ldd	r0, Z+5	; 0x05
    1eba:	f6 81       	ldd	r31, Z+6	; 0x06
    1ebc:	e0 2d       	mov	r30, r0
    1ebe:	86 81       	ldd	r24, Z+6	; 0x06
    1ec0:	97 81       	ldd	r25, Z+7	; 0x07
    1ec2:	9e 83       	std	Y+6, r25	; 0x06
    1ec4:	8d 83       	std	Y+5, r24	; 0x05
    1ec6:	ed 81       	ldd	r30, Y+5	; 0x05
    1ec8:	fe 81       	ldd	r31, Y+6	; 0x06
    1eca:	82 81       	ldd	r24, Z+2	; 0x02
    1ecc:	93 81       	ldd	r25, Z+3	; 0x03
    1ece:	9a 83       	std	Y+2, r25	; 0x02
    1ed0:	89 83       	std	Y+1, r24	; 0x01
    1ed2:	20 91 c0 00 	lds	r18, 0x00C0
    1ed6:	30 91 c1 00 	lds	r19, 0x00C1
    1eda:	89 81       	ldd	r24, Y+1	; 0x01
    1edc:	9a 81       	ldd	r25, Y+2	; 0x02
    1ede:	28 17       	cp	r18, r24
    1ee0:	39 07       	cpc	r19, r25
    1ee2:	38 f4       	brcc	.+14     	; 0x1ef2 <vTaskIncrementTick+0x120>
    1ee4:	89 81       	ldd	r24, Y+1	; 0x01
    1ee6:	9a 81       	ldd	r25, Y+2	; 0x02
    1ee8:	90 93 81 00 	sts	0x0081, r25
    1eec:	80 93 80 00 	sts	0x0080, r24
    1ef0:	3c c0       	rjmp	.+120    	; 0x1f6a <vTaskIncrementTick+0x198>
    1ef2:	8d 81       	ldd	r24, Y+5	; 0x05
    1ef4:	9e 81       	ldd	r25, Y+6	; 0x06
    1ef6:	02 96       	adiw	r24, 0x02	; 2
    1ef8:	0e 94 46 04 	call	0x88c	; 0x88c <vListRemove>
    1efc:	ed 81       	ldd	r30, Y+5	; 0x05
    1efe:	fe 81       	ldd	r31, Y+6	; 0x06
    1f00:	84 89       	ldd	r24, Z+20	; 0x14
    1f02:	95 89       	ldd	r25, Z+21	; 0x15
    1f04:	00 97       	sbiw	r24, 0x00	; 0
    1f06:	29 f0       	breq	.+10     	; 0x1f12 <vTaskIncrementTick+0x140>
    1f08:	8d 81       	ldd	r24, Y+5	; 0x05
    1f0a:	9e 81       	ldd	r25, Y+6	; 0x06
    1f0c:	0c 96       	adiw	r24, 0x0c	; 12
    1f0e:	0e 94 46 04 	call	0x88c	; 0x88c <vListRemove>
    1f12:	ed 81       	ldd	r30, Y+5	; 0x05
    1f14:	fe 81       	ldd	r31, Y+6	; 0x06
    1f16:	96 89       	ldd	r25, Z+22	; 0x16
    1f18:	80 91 c3 00 	lds	r24, 0x00C3
    1f1c:	89 17       	cp	r24, r25
    1f1e:	28 f4       	brcc	.+10     	; 0x1f2a <vTaskIncrementTick+0x158>
    1f20:	ed 81       	ldd	r30, Y+5	; 0x05
    1f22:	fe 81       	ldd	r31, Y+6	; 0x06
    1f24:	86 89       	ldd	r24, Z+22	; 0x16
    1f26:	80 93 c3 00 	sts	0x00C3, r24
    1f2a:	ed 81       	ldd	r30, Y+5	; 0x05
    1f2c:	fe 81       	ldd	r31, Y+6	; 0x06
    1f2e:	86 89       	ldd	r24, Z+22	; 0x16
    1f30:	28 2f       	mov	r18, r24
    1f32:	30 e0       	ldi	r19, 0x00	; 0
    1f34:	c9 01       	movw	r24, r18
    1f36:	88 0f       	add	r24, r24
    1f38:	99 1f       	adc	r25, r25
    1f3a:	88 0f       	add	r24, r24
    1f3c:	99 1f       	adc	r25, r25
    1f3e:	88 0f       	add	r24, r24
    1f40:	99 1f       	adc	r25, r25
    1f42:	82 0f       	add	r24, r18
    1f44:	93 1f       	adc	r25, r19
    1f46:	ac 01       	movw	r20, r24
    1f48:	46 53       	subi	r20, 0x36	; 54
    1f4a:	5f 4f       	sbci	r21, 0xFF	; 255
    1f4c:	8d 81       	ldd	r24, Y+5	; 0x05
    1f4e:	9e 81       	ldd	r25, Y+6	; 0x06
    1f50:	9c 01       	movw	r18, r24
    1f52:	2e 5f       	subi	r18, 0xFE	; 254
    1f54:	3f 4f       	sbci	r19, 0xFF	; 255
    1f56:	ca 01       	movw	r24, r20
    1f58:	b9 01       	movw	r22, r18
    1f5a:	0e 94 8e 03 	call	0x71c	; 0x71c <vListInsertEnd>
    1f5e:	9a cf       	rjmp	.-204    	; 0x1e94 <vTaskIncrementTick+0xc2>
	}
	else
	{
		++uxMissedTicks;
    1f60:	80 91 c6 00 	lds	r24, 0x00C6
    1f64:	8f 5f       	subi	r24, 0xFF	; 255
    1f66:	80 93 c6 00 	sts	0x00C6, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    1f6a:	26 96       	adiw	r28, 0x06	; 6
    1f6c:	0f b6       	in	r0, 0x3f	; 63
    1f6e:	f8 94       	cli
    1f70:	de bf       	out	0x3e, r29	; 62
    1f72:	0f be       	out	0x3f, r0	; 63
    1f74:	cd bf       	out	0x3d, r28	; 61
    1f76:	cf 91       	pop	r28
    1f78:	df 91       	pop	r29
    1f7a:	08 95       	ret

00001f7c <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    1f7c:	df 93       	push	r29
    1f7e:	cf 93       	push	r28
    1f80:	00 d0       	rcall	.+0      	; 0x1f82 <vTaskSwitchContext+0x6>
    1f82:	cd b7       	in	r28, 0x3d	; 61
    1f84:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    1f86:	80 91 c5 00 	lds	r24, 0x00C5
    1f8a:	88 23       	and	r24, r24
    1f8c:	49 f0       	breq	.+18     	; 0x1fa0 <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    1f8e:	81 e0       	ldi	r24, 0x01	; 1
    1f90:	80 93 c7 00 	sts	0x00C7, r24
    1f94:	54 c0       	rjmp	.+168    	; 0x203e <vTaskSwitchContext+0xc2>
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    1f96:	80 91 c3 00 	lds	r24, 0x00C3
    1f9a:	81 50       	subi	r24, 0x01	; 1
    1f9c:	80 93 c3 00 	sts	0x00C3, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    1fa0:	80 91 c3 00 	lds	r24, 0x00C3
    1fa4:	28 2f       	mov	r18, r24
    1fa6:	30 e0       	ldi	r19, 0x00	; 0
    1fa8:	c9 01       	movw	r24, r18
    1faa:	88 0f       	add	r24, r24
    1fac:	99 1f       	adc	r25, r25
    1fae:	88 0f       	add	r24, r24
    1fb0:	99 1f       	adc	r25, r25
    1fb2:	88 0f       	add	r24, r24
    1fb4:	99 1f       	adc	r25, r25
    1fb6:	82 0f       	add	r24, r18
    1fb8:	93 1f       	adc	r25, r19
    1fba:	fc 01       	movw	r30, r24
    1fbc:	e6 53       	subi	r30, 0x36	; 54
    1fbe:	ff 4f       	sbci	r31, 0xFF	; 255
    1fc0:	80 81       	ld	r24, Z
    1fc2:	88 23       	and	r24, r24
    1fc4:	41 f3       	breq	.-48     	; 0x1f96 <vTaskSwitchContext+0x1a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    1fc6:	80 91 c3 00 	lds	r24, 0x00C3
    1fca:	28 2f       	mov	r18, r24
    1fcc:	30 e0       	ldi	r19, 0x00	; 0
    1fce:	c9 01       	movw	r24, r18
    1fd0:	88 0f       	add	r24, r24
    1fd2:	99 1f       	adc	r25, r25
    1fd4:	88 0f       	add	r24, r24
    1fd6:	99 1f       	adc	r25, r25
    1fd8:	88 0f       	add	r24, r24
    1fda:	99 1f       	adc	r25, r25
    1fdc:	82 0f       	add	r24, r18
    1fde:	93 1f       	adc	r25, r19
    1fe0:	86 53       	subi	r24, 0x36	; 54
    1fe2:	9f 4f       	sbci	r25, 0xFF	; 255
    1fe4:	9a 83       	std	Y+2, r25	; 0x02
    1fe6:	89 83       	std	Y+1, r24	; 0x01
    1fe8:	e9 81       	ldd	r30, Y+1	; 0x01
    1fea:	fa 81       	ldd	r31, Y+2	; 0x02
    1fec:	01 80       	ldd	r0, Z+1	; 0x01
    1fee:	f2 81       	ldd	r31, Z+2	; 0x02
    1ff0:	e0 2d       	mov	r30, r0
    1ff2:	82 81       	ldd	r24, Z+2	; 0x02
    1ff4:	93 81       	ldd	r25, Z+3	; 0x03
    1ff6:	e9 81       	ldd	r30, Y+1	; 0x01
    1ff8:	fa 81       	ldd	r31, Y+2	; 0x02
    1ffa:	92 83       	std	Z+2, r25	; 0x02
    1ffc:	81 83       	std	Z+1, r24	; 0x01
    1ffe:	e9 81       	ldd	r30, Y+1	; 0x01
    2000:	fa 81       	ldd	r31, Y+2	; 0x02
    2002:	21 81       	ldd	r18, Z+1	; 0x01
    2004:	32 81       	ldd	r19, Z+2	; 0x02
    2006:	89 81       	ldd	r24, Y+1	; 0x01
    2008:	9a 81       	ldd	r25, Y+2	; 0x02
    200a:	03 96       	adiw	r24, 0x03	; 3
    200c:	28 17       	cp	r18, r24
    200e:	39 07       	cpc	r19, r25
    2010:	59 f4       	brne	.+22     	; 0x2028 <vTaskSwitchContext+0xac>
    2012:	e9 81       	ldd	r30, Y+1	; 0x01
    2014:	fa 81       	ldd	r31, Y+2	; 0x02
    2016:	01 80       	ldd	r0, Z+1	; 0x01
    2018:	f2 81       	ldd	r31, Z+2	; 0x02
    201a:	e0 2d       	mov	r30, r0
    201c:	82 81       	ldd	r24, Z+2	; 0x02
    201e:	93 81       	ldd	r25, Z+3	; 0x03
    2020:	e9 81       	ldd	r30, Y+1	; 0x01
    2022:	fa 81       	ldd	r31, Y+2	; 0x02
    2024:	92 83       	std	Z+2, r25	; 0x02
    2026:	81 83       	std	Z+1, r24	; 0x01
    2028:	e9 81       	ldd	r30, Y+1	; 0x01
    202a:	fa 81       	ldd	r31, Y+2	; 0x02
    202c:	01 80       	ldd	r0, Z+1	; 0x01
    202e:	f2 81       	ldd	r31, Z+2	; 0x02
    2030:	e0 2d       	mov	r30, r0
    2032:	86 81       	ldd	r24, Z+6	; 0x06
    2034:	97 81       	ldd	r25, Z+7	; 0x07
    2036:	90 93 bd 00 	sts	0x00BD, r25
    203a:	80 93 bc 00 	sts	0x00BC, r24
	
		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
    203e:	0f 90       	pop	r0
    2040:	0f 90       	pop	r0
    2042:	cf 91       	pop	r28
    2044:	df 91       	pop	r29
    2046:	08 95       	ret

00002048 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    2048:	df 93       	push	r29
    204a:	cf 93       	push	r28
    204c:	00 d0       	rcall	.+0      	; 0x204e <vTaskPlaceOnEventList+0x6>
    204e:	00 d0       	rcall	.+0      	; 0x2050 <vTaskPlaceOnEventList+0x8>
    2050:	00 d0       	rcall	.+0      	; 0x2052 <vTaskPlaceOnEventList+0xa>
    2052:	cd b7       	in	r28, 0x3d	; 61
    2054:	de b7       	in	r29, 0x3e	; 62
    2056:	9c 83       	std	Y+4, r25	; 0x04
    2058:	8b 83       	std	Y+3, r24	; 0x03
    205a:	7e 83       	std	Y+6, r23	; 0x06
    205c:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    205e:	4b 81       	ldd	r20, Y+3	; 0x03
    2060:	5c 81       	ldd	r21, Y+4	; 0x04
    2062:	80 91 bc 00 	lds	r24, 0x00BC
    2066:	90 91 bd 00 	lds	r25, 0x00BD
    206a:	9c 01       	movw	r18, r24
    206c:	24 5f       	subi	r18, 0xF4	; 244
    206e:	3f 4f       	sbci	r19, 0xFF	; 255
    2070:	ca 01       	movw	r24, r20
    2072:	b9 01       	movw	r22, r18
    2074:	0e 94 da 03 	call	0x7b4	; 0x7b4 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2078:	80 91 bc 00 	lds	r24, 0x00BC
    207c:	90 91 bd 00 	lds	r25, 0x00BD
    2080:	02 96       	adiw	r24, 0x02	; 2
    2082:	0e 94 46 04 	call	0x88c	; 0x88c <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    2086:	20 91 c0 00 	lds	r18, 0x00C0
    208a:	30 91 c1 00 	lds	r19, 0x00C1
    208e:	8d 81       	ldd	r24, Y+5	; 0x05
    2090:	9e 81       	ldd	r25, Y+6	; 0x06
    2092:	82 0f       	add	r24, r18
    2094:	93 1f       	adc	r25, r19
    2096:	9a 83       	std	Y+2, r25	; 0x02
    2098:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    209a:	89 81       	ldd	r24, Y+1	; 0x01
    209c:	9a 81       	ldd	r25, Y+2	; 0x02
    209e:	0e 94 1e 12 	call	0x243c	; 0x243c <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    20a2:	26 96       	adiw	r28, 0x06	; 6
    20a4:	0f b6       	in	r0, 0x3f	; 63
    20a6:	f8 94       	cli
    20a8:	de bf       	out	0x3e, r29	; 62
    20aa:	0f be       	out	0x3f, r0	; 63
    20ac:	cd bf       	out	0x3d, r28	; 61
    20ae:	cf 91       	pop	r28
    20b0:	df 91       	pop	r29
    20b2:	08 95       	ret

000020b4 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    20b4:	df 93       	push	r29
    20b6:	cf 93       	push	r28
    20b8:	00 d0       	rcall	.+0      	; 0x20ba <xTaskRemoveFromEventList+0x6>
    20ba:	00 d0       	rcall	.+0      	; 0x20bc <xTaskRemoveFromEventList+0x8>
    20bc:	0f 92       	push	r0
    20be:	cd b7       	in	r28, 0x3d	; 61
    20c0:	de b7       	in	r29, 0x3e	; 62
    20c2:	9d 83       	std	Y+5, r25	; 0x05
    20c4:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    20c6:	ec 81       	ldd	r30, Y+4	; 0x04
    20c8:	fd 81       	ldd	r31, Y+5	; 0x05
    20ca:	05 80       	ldd	r0, Z+5	; 0x05
    20cc:	f6 81       	ldd	r31, Z+6	; 0x06
    20ce:	e0 2d       	mov	r30, r0
    20d0:	86 81       	ldd	r24, Z+6	; 0x06
    20d2:	97 81       	ldd	r25, Z+7	; 0x07
    20d4:	9b 83       	std	Y+3, r25	; 0x03
    20d6:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    20d8:	8a 81       	ldd	r24, Y+2	; 0x02
    20da:	9b 81       	ldd	r25, Y+3	; 0x03
    20dc:	0c 96       	adiw	r24, 0x0c	; 12
    20de:	0e 94 46 04 	call	0x88c	; 0x88c <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    20e2:	80 91 c5 00 	lds	r24, 0x00C5
    20e6:	88 23       	and	r24, r24
    20e8:	61 f5       	brne	.+88     	; 0x2142 <xTaskRemoveFromEventList+0x8e>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    20ea:	8a 81       	ldd	r24, Y+2	; 0x02
    20ec:	9b 81       	ldd	r25, Y+3	; 0x03
    20ee:	02 96       	adiw	r24, 0x02	; 2
    20f0:	0e 94 46 04 	call	0x88c	; 0x88c <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    20f4:	ea 81       	ldd	r30, Y+2	; 0x02
    20f6:	fb 81       	ldd	r31, Y+3	; 0x03
    20f8:	96 89       	ldd	r25, Z+22	; 0x16
    20fa:	80 91 c3 00 	lds	r24, 0x00C3
    20fe:	89 17       	cp	r24, r25
    2100:	28 f4       	brcc	.+10     	; 0x210c <xTaskRemoveFromEventList+0x58>
    2102:	ea 81       	ldd	r30, Y+2	; 0x02
    2104:	fb 81       	ldd	r31, Y+3	; 0x03
    2106:	86 89       	ldd	r24, Z+22	; 0x16
    2108:	80 93 c3 00 	sts	0x00C3, r24
    210c:	ea 81       	ldd	r30, Y+2	; 0x02
    210e:	fb 81       	ldd	r31, Y+3	; 0x03
    2110:	86 89       	ldd	r24, Z+22	; 0x16
    2112:	28 2f       	mov	r18, r24
    2114:	30 e0       	ldi	r19, 0x00	; 0
    2116:	c9 01       	movw	r24, r18
    2118:	88 0f       	add	r24, r24
    211a:	99 1f       	adc	r25, r25
    211c:	88 0f       	add	r24, r24
    211e:	99 1f       	adc	r25, r25
    2120:	88 0f       	add	r24, r24
    2122:	99 1f       	adc	r25, r25
    2124:	82 0f       	add	r24, r18
    2126:	93 1f       	adc	r25, r19
    2128:	ac 01       	movw	r20, r24
    212a:	46 53       	subi	r20, 0x36	; 54
    212c:	5f 4f       	sbci	r21, 0xFF	; 255
    212e:	8a 81       	ldd	r24, Y+2	; 0x02
    2130:	9b 81       	ldd	r25, Y+3	; 0x03
    2132:	9c 01       	movw	r18, r24
    2134:	2e 5f       	subi	r18, 0xFE	; 254
    2136:	3f 4f       	sbci	r19, 0xFF	; 255
    2138:	ca 01       	movw	r24, r20
    213a:	b9 01       	movw	r22, r18
    213c:	0e 94 8e 03 	call	0x71c	; 0x71c <vListInsertEnd>
    2140:	0a c0       	rjmp	.+20     	; 0x2156 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2142:	8a 81       	ldd	r24, Y+2	; 0x02
    2144:	9b 81       	ldd	r25, Y+3	; 0x03
    2146:	9c 01       	movw	r18, r24
    2148:	24 5f       	subi	r18, 0xF4	; 244
    214a:	3f 4f       	sbci	r19, 0xFF	; 255
    214c:	82 ef       	ldi	r24, 0xF2	; 242
    214e:	90 e0       	ldi	r25, 0x00	; 0
    2150:	b9 01       	movw	r22, r18
    2152:	0e 94 8e 03 	call	0x71c	; 0x71c <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2156:	ea 81       	ldd	r30, Y+2	; 0x02
    2158:	fb 81       	ldd	r31, Y+3	; 0x03
    215a:	96 89       	ldd	r25, Z+22	; 0x16
    215c:	e0 91 bc 00 	lds	r30, 0x00BC
    2160:	f0 91 bd 00 	lds	r31, 0x00BD
    2164:	86 89       	ldd	r24, Z+22	; 0x16
    2166:	98 17       	cp	r25, r24
    2168:	18 f0       	brcs	.+6      	; 0x2170 <xTaskRemoveFromEventList+0xbc>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    216a:	81 e0       	ldi	r24, 0x01	; 1
    216c:	89 83       	std	Y+1, r24	; 0x01
    216e:	01 c0       	rjmp	.+2      	; 0x2172 <xTaskRemoveFromEventList+0xbe>
	}
	else
	{
		xReturn = pdFALSE;
    2170:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2172:	89 81       	ldd	r24, Y+1	; 0x01
}
    2174:	0f 90       	pop	r0
    2176:	0f 90       	pop	r0
    2178:	0f 90       	pop	r0
    217a:	0f 90       	pop	r0
    217c:	0f 90       	pop	r0
    217e:	cf 91       	pop	r28
    2180:	df 91       	pop	r29
    2182:	08 95       	ret

00002184 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    2184:	df 93       	push	r29
    2186:	cf 93       	push	r28
    2188:	00 d0       	rcall	.+0      	; 0x218a <vTaskSetTimeOutState+0x6>
    218a:	cd b7       	in	r28, 0x3d	; 61
    218c:	de b7       	in	r29, 0x3e	; 62
    218e:	9a 83       	std	Y+2, r25	; 0x02
    2190:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2192:	80 91 c8 00 	lds	r24, 0x00C8
    2196:	e9 81       	ldd	r30, Y+1	; 0x01
    2198:	fa 81       	ldd	r31, Y+2	; 0x02
    219a:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    219c:	80 91 c0 00 	lds	r24, 0x00C0
    21a0:	90 91 c1 00 	lds	r25, 0x00C1
    21a4:	e9 81       	ldd	r30, Y+1	; 0x01
    21a6:	fa 81       	ldd	r31, Y+2	; 0x02
    21a8:	92 83       	std	Z+2, r25	; 0x02
    21aa:	81 83       	std	Z+1, r24	; 0x01
}
    21ac:	0f 90       	pop	r0
    21ae:	0f 90       	pop	r0
    21b0:	cf 91       	pop	r28
    21b2:	df 91       	pop	r29
    21b4:	08 95       	ret

000021b6 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    21b6:	df 93       	push	r29
    21b8:	cf 93       	push	r28
    21ba:	00 d0       	rcall	.+0      	; 0x21bc <xTaskCheckForTimeOut+0x6>
    21bc:	00 d0       	rcall	.+0      	; 0x21be <xTaskCheckForTimeOut+0x8>
    21be:	0f 92       	push	r0
    21c0:	cd b7       	in	r28, 0x3d	; 61
    21c2:	de b7       	in	r29, 0x3e	; 62
    21c4:	9b 83       	std	Y+3, r25	; 0x03
    21c6:	8a 83       	std	Y+2, r24	; 0x02
    21c8:	7d 83       	std	Y+5, r23	; 0x05
    21ca:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    21cc:	0f b6       	in	r0, 0x3f	; 63
    21ce:	f8 94       	cli
    21d0:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    21d2:	ea 81       	ldd	r30, Y+2	; 0x02
    21d4:	fb 81       	ldd	r31, Y+3	; 0x03
    21d6:	90 81       	ld	r25, Z
    21d8:	80 91 c8 00 	lds	r24, 0x00C8
    21dc:	98 17       	cp	r25, r24
    21de:	71 f0       	breq	.+28     	; 0x21fc <xTaskCheckForTimeOut+0x46>
    21e0:	ea 81       	ldd	r30, Y+2	; 0x02
    21e2:	fb 81       	ldd	r31, Y+3	; 0x03
    21e4:	21 81       	ldd	r18, Z+1	; 0x01
    21e6:	32 81       	ldd	r19, Z+2	; 0x02
    21e8:	80 91 c0 00 	lds	r24, 0x00C0
    21ec:	90 91 c1 00 	lds	r25, 0x00C1
    21f0:	82 17       	cp	r24, r18
    21f2:	93 07       	cpc	r25, r19
    21f4:	18 f0       	brcs	.+6      	; 0x21fc <xTaskCheckForTimeOut+0x46>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    21f6:	81 e0       	ldi	r24, 0x01	; 1
    21f8:	89 83       	std	Y+1, r24	; 0x01
    21fa:	2f c0       	rjmp	.+94     	; 0x225a <xTaskCheckForTimeOut+0xa4>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    21fc:	20 91 c0 00 	lds	r18, 0x00C0
    2200:	30 91 c1 00 	lds	r19, 0x00C1
    2204:	ea 81       	ldd	r30, Y+2	; 0x02
    2206:	fb 81       	ldd	r31, Y+3	; 0x03
    2208:	81 81       	ldd	r24, Z+1	; 0x01
    220a:	92 81       	ldd	r25, Z+2	; 0x02
    220c:	28 1b       	sub	r18, r24
    220e:	39 0b       	sbc	r19, r25
    2210:	ec 81       	ldd	r30, Y+4	; 0x04
    2212:	fd 81       	ldd	r31, Y+5	; 0x05
    2214:	80 81       	ld	r24, Z
    2216:	91 81       	ldd	r25, Z+1	; 0x01
    2218:	28 17       	cp	r18, r24
    221a:	39 07       	cpc	r19, r25
    221c:	e0 f4       	brcc	.+56     	; 0x2256 <xTaskCheckForTimeOut+0xa0>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    221e:	ec 81       	ldd	r30, Y+4	; 0x04
    2220:	fd 81       	ldd	r31, Y+5	; 0x05
    2222:	40 81       	ld	r20, Z
    2224:	51 81       	ldd	r21, Z+1	; 0x01
    2226:	ea 81       	ldd	r30, Y+2	; 0x02
    2228:	fb 81       	ldd	r31, Y+3	; 0x03
    222a:	21 81       	ldd	r18, Z+1	; 0x01
    222c:	32 81       	ldd	r19, Z+2	; 0x02
    222e:	80 91 c0 00 	lds	r24, 0x00C0
    2232:	90 91 c1 00 	lds	r25, 0x00C1
    2236:	b9 01       	movw	r22, r18
    2238:	68 1b       	sub	r22, r24
    223a:	79 0b       	sbc	r23, r25
    223c:	cb 01       	movw	r24, r22
    223e:	84 0f       	add	r24, r20
    2240:	95 1f       	adc	r25, r21
    2242:	ec 81       	ldd	r30, Y+4	; 0x04
    2244:	fd 81       	ldd	r31, Y+5	; 0x05
    2246:	91 83       	std	Z+1, r25	; 0x01
    2248:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    224a:	8a 81       	ldd	r24, Y+2	; 0x02
    224c:	9b 81       	ldd	r25, Y+3	; 0x03
    224e:	0e 94 c2 10 	call	0x2184	; 0x2184 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    2252:	19 82       	std	Y+1, r1	; 0x01
    2254:	02 c0       	rjmp	.+4      	; 0x225a <xTaskCheckForTimeOut+0xa4>
		}
		else
		{
			xReturn = pdTRUE;
    2256:	81 e0       	ldi	r24, 0x01	; 1
    2258:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    225a:	0f 90       	pop	r0
    225c:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    225e:	89 81       	ldd	r24, Y+1	; 0x01
}
    2260:	0f 90       	pop	r0
    2262:	0f 90       	pop	r0
    2264:	0f 90       	pop	r0
    2266:	0f 90       	pop	r0
    2268:	0f 90       	pop	r0
    226a:	cf 91       	pop	r28
    226c:	df 91       	pop	r29
    226e:	08 95       	ret

00002270 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    2270:	df 93       	push	r29
    2272:	cf 93       	push	r28
    2274:	cd b7       	in	r28, 0x3d	; 61
    2276:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    2278:	81 e0       	ldi	r24, 0x01	; 1
    227a:	80 93 c7 00 	sts	0x00C7, r24
}
    227e:	cf 91       	pop	r28
    2280:	df 91       	pop	r29
    2282:	08 95       	ret

00002284 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    2284:	df 93       	push	r29
    2286:	cf 93       	push	r28
    2288:	00 d0       	rcall	.+0      	; 0x228a <prvIdleTask+0x6>
    228a:	cd b7       	in	r28, 0x3d	; 61
    228c:	de b7       	in	r29, 0x3e	; 62
    228e:	9a 83       	std	Y+2, r25	; 0x02
    2290:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    2292:	0e 94 e0 11 	call	0x23c0	; 0x23c0 <prvCheckTasksWaitingTermination>
    2296:	fd cf       	rjmp	.-6      	; 0x2292 <prvIdleTask+0xe>

00002298 <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    2298:	0f 93       	push	r16
    229a:	1f 93       	push	r17
    229c:	df 93       	push	r29
    229e:	cf 93       	push	r28
    22a0:	cd b7       	in	r28, 0x3d	; 61
    22a2:	de b7       	in	r29, 0x3e	; 62
    22a4:	29 97       	sbiw	r28, 0x09	; 9
    22a6:	0f b6       	in	r0, 0x3f	; 63
    22a8:	f8 94       	cli
    22aa:	de bf       	out	0x3e, r29	; 62
    22ac:	0f be       	out	0x3f, r0	; 63
    22ae:	cd bf       	out	0x3d, r28	; 61
    22b0:	9a 83       	std	Y+2, r25	; 0x02
    22b2:	89 83       	std	Y+1, r24	; 0x01
    22b4:	7c 83       	std	Y+4, r23	; 0x04
    22b6:	6b 83       	std	Y+3, r22	; 0x03
    22b8:	4d 83       	std	Y+5, r20	; 0x05
    22ba:	3f 83       	std	Y+7, r19	; 0x07
    22bc:	2e 83       	std	Y+6, r18	; 0x06
    22be:	19 87       	std	Y+9, r17	; 0x09
    22c0:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    22c2:	89 81       	ldd	r24, Y+1	; 0x01
    22c4:	9a 81       	ldd	r25, Y+2	; 0x02
    22c6:	49 96       	adiw	r24, 0x19	; 25
    22c8:	2b 81       	ldd	r18, Y+3	; 0x03
    22ca:	3c 81       	ldd	r19, Y+4	; 0x04
    22cc:	b9 01       	movw	r22, r18
    22ce:	48 e0       	ldi	r20, 0x08	; 8
    22d0:	50 e0       	ldi	r21, 0x00	; 0
    22d2:	0e 94 83 17 	call	0x2f06	; 0x2f06 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    22d6:	e9 81       	ldd	r30, Y+1	; 0x01
    22d8:	fa 81       	ldd	r31, Y+2	; 0x02
    22da:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    22dc:	8d 81       	ldd	r24, Y+5	; 0x05
    22de:	82 30       	cpi	r24, 0x02	; 2
    22e0:	10 f0       	brcs	.+4      	; 0x22e6 <prvInitialiseTCBVariables+0x4e>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    22e2:	81 e0       	ldi	r24, 0x01	; 1
    22e4:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    22e6:	e9 81       	ldd	r30, Y+1	; 0x01
    22e8:	fa 81       	ldd	r31, Y+2	; 0x02
    22ea:	8d 81       	ldd	r24, Y+5	; 0x05
    22ec:	86 8b       	std	Z+22, r24	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    22ee:	89 81       	ldd	r24, Y+1	; 0x01
    22f0:	9a 81       	ldd	r25, Y+2	; 0x02
    22f2:	02 96       	adiw	r24, 0x02	; 2
    22f4:	0e 94 7e 03 	call	0x6fc	; 0x6fc <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    22f8:	89 81       	ldd	r24, Y+1	; 0x01
    22fa:	9a 81       	ldd	r25, Y+2	; 0x02
    22fc:	0c 96       	adiw	r24, 0x0c	; 12
    22fe:	0e 94 7e 03 	call	0x6fc	; 0x6fc <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    2302:	e9 81       	ldd	r30, Y+1	; 0x01
    2304:	fa 81       	ldd	r31, Y+2	; 0x02
    2306:	89 81       	ldd	r24, Y+1	; 0x01
    2308:	9a 81       	ldd	r25, Y+2	; 0x02
    230a:	91 87       	std	Z+9, r25	; 0x09
    230c:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    230e:	8d 81       	ldd	r24, Y+5	; 0x05
    2310:	28 2f       	mov	r18, r24
    2312:	30 e0       	ldi	r19, 0x00	; 0
    2314:	82 e0       	ldi	r24, 0x02	; 2
    2316:	90 e0       	ldi	r25, 0x00	; 0
    2318:	82 1b       	sub	r24, r18
    231a:	93 0b       	sbc	r25, r19
    231c:	e9 81       	ldd	r30, Y+1	; 0x01
    231e:	fa 81       	ldd	r31, Y+2	; 0x02
    2320:	95 87       	std	Z+13, r25	; 0x0d
    2322:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    2324:	e9 81       	ldd	r30, Y+1	; 0x01
    2326:	fa 81       	ldd	r31, Y+2	; 0x02
    2328:	89 81       	ldd	r24, Y+1	; 0x01
    232a:	9a 81       	ldd	r25, Y+2	; 0x02
    232c:	93 8b       	std	Z+19, r25	; 0x13
    232e:	82 8b       	std	Z+18, r24	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    2330:	29 96       	adiw	r28, 0x09	; 9
    2332:	0f b6       	in	r0, 0x3f	; 63
    2334:	f8 94       	cli
    2336:	de bf       	out	0x3e, r29	; 62
    2338:	0f be       	out	0x3f, r0	; 63
    233a:	cd bf       	out	0x3d, r28	; 61
    233c:	cf 91       	pop	r28
    233e:	df 91       	pop	r29
    2340:	1f 91       	pop	r17
    2342:	0f 91       	pop	r16
    2344:	08 95       	ret

00002346 <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    2346:	df 93       	push	r29
    2348:	cf 93       	push	r28
    234a:	0f 92       	push	r0
    234c:	cd b7       	in	r28, 0x3d	; 61
    234e:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    2350:	19 82       	std	Y+1, r1	; 0x01
    2352:	13 c0       	rjmp	.+38     	; 0x237a <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    2354:	89 81       	ldd	r24, Y+1	; 0x01
    2356:	28 2f       	mov	r18, r24
    2358:	30 e0       	ldi	r19, 0x00	; 0
    235a:	c9 01       	movw	r24, r18
    235c:	88 0f       	add	r24, r24
    235e:	99 1f       	adc	r25, r25
    2360:	88 0f       	add	r24, r24
    2362:	99 1f       	adc	r25, r25
    2364:	88 0f       	add	r24, r24
    2366:	99 1f       	adc	r25, r25
    2368:	82 0f       	add	r24, r18
    236a:	93 1f       	adc	r25, r19
    236c:	86 53       	subi	r24, 0x36	; 54
    236e:	9f 4f       	sbci	r25, 0xFF	; 255
    2370:	0e 94 54 03 	call	0x6a8	; 0x6a8 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    2374:	89 81       	ldd	r24, Y+1	; 0x01
    2376:	8f 5f       	subi	r24, 0xFF	; 255
    2378:	89 83       	std	Y+1, r24	; 0x01
    237a:	89 81       	ldd	r24, Y+1	; 0x01
    237c:	82 30       	cpi	r24, 0x02	; 2
    237e:	50 f3       	brcs	.-44     	; 0x2354 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    2380:	8c ed       	ldi	r24, 0xDC	; 220
    2382:	90 e0       	ldi	r25, 0x00	; 0
    2384:	0e 94 54 03 	call	0x6a8	; 0x6a8 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    2388:	85 ee       	ldi	r24, 0xE5	; 229
    238a:	90 e0       	ldi	r25, 0x00	; 0
    238c:	0e 94 54 03 	call	0x6a8	; 0x6a8 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    2390:	82 ef       	ldi	r24, 0xF2	; 242
    2392:	90 e0       	ldi	r25, 0x00	; 0
    2394:	0e 94 54 03 	call	0x6a8	; 0x6a8 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    2398:	8b ef       	ldi	r24, 0xFB	; 251
    239a:	90 e0       	ldi	r25, 0x00	; 0
    239c:	0e 94 54 03 	call	0x6a8	; 0x6a8 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    23a0:	8c ed       	ldi	r24, 0xDC	; 220
    23a2:	90 e0       	ldi	r25, 0x00	; 0
    23a4:	90 93 ef 00 	sts	0x00EF, r25
    23a8:	80 93 ee 00 	sts	0x00EE, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    23ac:	85 ee       	ldi	r24, 0xE5	; 229
    23ae:	90 e0       	ldi	r25, 0x00	; 0
    23b0:	90 93 f1 00 	sts	0x00F1, r25
    23b4:	80 93 f0 00 	sts	0x00F0, r24
}
    23b8:	0f 90       	pop	r0
    23ba:	cf 91       	pop	r28
    23bc:	df 91       	pop	r29
    23be:	08 95       	ret

000023c0 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    23c0:	df 93       	push	r29
    23c2:	cf 93       	push	r28
    23c4:	00 d0       	rcall	.+0      	; 0x23c6 <prvCheckTasksWaitingTermination+0x6>
    23c6:	0f 92       	push	r0
    23c8:	cd b7       	in	r28, 0x3d	; 61
    23ca:	de b7       	in	r29, 0x3e	; 62
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    23cc:	80 91 be 00 	lds	r24, 0x00BE
    23d0:	88 23       	and	r24, r24
    23d2:	71 f1       	breq	.+92     	; 0x2430 <prvCheckTasksWaitingTermination+0x70>
		{
			vTaskSuspendAll();
    23d4:	0e 94 1e 0e 	call	0x1c3c	; 0x1c3c <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    23d8:	80 91 fb 00 	lds	r24, 0x00FB
    23dc:	1b 82       	std	Y+3, r1	; 0x03
    23de:	88 23       	and	r24, r24
    23e0:	11 f4       	brne	.+4      	; 0x23e6 <prvCheckTasksWaitingTermination+0x26>
    23e2:	81 e0       	ldi	r24, 0x01	; 1
    23e4:	8b 83       	std	Y+3, r24	; 0x03
			xTaskResumeAll();
    23e6:	0e 94 2a 0e 	call	0x1c54	; 0x1c54 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    23ea:	8b 81       	ldd	r24, Y+3	; 0x03
    23ec:	88 23       	and	r24, r24
    23ee:	01 f5       	brne	.+64     	; 0x2430 <prvCheckTasksWaitingTermination+0x70>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    23f0:	0f b6       	in	r0, 0x3f	; 63
    23f2:	f8 94       	cli
    23f4:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    23f6:	e0 91 00 01 	lds	r30, 0x0100
    23fa:	f0 91 01 01 	lds	r31, 0x0101
    23fe:	86 81       	ldd	r24, Z+6	; 0x06
    2400:	97 81       	ldd	r25, Z+7	; 0x07
    2402:	9a 83       	std	Y+2, r25	; 0x02
    2404:	89 83       	std	Y+1, r24	; 0x01
					vListRemove( &( pxTCB->xGenericListItem ) );
    2406:	89 81       	ldd	r24, Y+1	; 0x01
    2408:	9a 81       	ldd	r25, Y+2	; 0x02
    240a:	02 96       	adiw	r24, 0x02	; 2
    240c:	0e 94 46 04 	call	0x88c	; 0x88c <vListRemove>
					--uxCurrentNumberOfTasks;
    2410:	80 91 bf 00 	lds	r24, 0x00BF
    2414:	81 50       	subi	r24, 0x01	; 1
    2416:	80 93 bf 00 	sts	0x00BF, r24
					--uxTasksDeleted;
    241a:	80 91 be 00 	lds	r24, 0x00BE
    241e:	81 50       	subi	r24, 0x01	; 1
    2420:	80 93 be 00 	sts	0x00BE, r24
				}
				taskEXIT_CRITICAL();
    2424:	0f 90       	pop	r0
    2426:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    2428:	89 81       	ldd	r24, Y+1	; 0x01
    242a:	9a 81       	ldd	r25, Y+2	; 0x02
    242c:	0e 94 b7 12 	call	0x256e	; 0x256e <prvDeleteTCB>
			}
		}
	}
	#endif
}
    2430:	0f 90       	pop	r0
    2432:	0f 90       	pop	r0
    2434:	0f 90       	pop	r0
    2436:	cf 91       	pop	r28
    2438:	df 91       	pop	r29
    243a:	08 95       	ret

0000243c <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    243c:	df 93       	push	r29
    243e:	cf 93       	push	r28
    2440:	00 d0       	rcall	.+0      	; 0x2442 <prvAddCurrentTaskToDelayedList+0x6>
    2442:	cd b7       	in	r28, 0x3d	; 61
    2444:	de b7       	in	r29, 0x3e	; 62
    2446:	9a 83       	std	Y+2, r25	; 0x02
    2448:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    244a:	e0 91 bc 00 	lds	r30, 0x00BC
    244e:	f0 91 bd 00 	lds	r31, 0x00BD
    2452:	89 81       	ldd	r24, Y+1	; 0x01
    2454:	9a 81       	ldd	r25, Y+2	; 0x02
    2456:	93 83       	std	Z+3, r25	; 0x03
    2458:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    245a:	20 91 c0 00 	lds	r18, 0x00C0
    245e:	30 91 c1 00 	lds	r19, 0x00C1
    2462:	89 81       	ldd	r24, Y+1	; 0x01
    2464:	9a 81       	ldd	r25, Y+2	; 0x02
    2466:	82 17       	cp	r24, r18
    2468:	93 07       	cpc	r25, r19
    246a:	70 f4       	brcc	.+28     	; 0x2488 <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    246c:	80 91 f0 00 	lds	r24, 0x00F0
    2470:	90 91 f1 00 	lds	r25, 0x00F1
    2474:	20 91 bc 00 	lds	r18, 0x00BC
    2478:	30 91 bd 00 	lds	r19, 0x00BD
    247c:	2e 5f       	subi	r18, 0xFE	; 254
    247e:	3f 4f       	sbci	r19, 0xFF	; 255
    2480:	b9 01       	movw	r22, r18
    2482:	0e 94 da 03 	call	0x7b4	; 0x7b4 <vListInsert>
    2486:	1e c0       	rjmp	.+60     	; 0x24c4 <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2488:	40 91 ee 00 	lds	r20, 0x00EE
    248c:	50 91 ef 00 	lds	r21, 0x00EF
    2490:	80 91 bc 00 	lds	r24, 0x00BC
    2494:	90 91 bd 00 	lds	r25, 0x00BD
    2498:	9c 01       	movw	r18, r24
    249a:	2e 5f       	subi	r18, 0xFE	; 254
    249c:	3f 4f       	sbci	r19, 0xFF	; 255
    249e:	ca 01       	movw	r24, r20
    24a0:	b9 01       	movw	r22, r18
    24a2:	0e 94 da 03 	call	0x7b4	; 0x7b4 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    24a6:	20 91 80 00 	lds	r18, 0x0080
    24aa:	30 91 81 00 	lds	r19, 0x0081
    24ae:	89 81       	ldd	r24, Y+1	; 0x01
    24b0:	9a 81       	ldd	r25, Y+2	; 0x02
    24b2:	82 17       	cp	r24, r18
    24b4:	93 07       	cpc	r25, r19
    24b6:	30 f4       	brcc	.+12     	; 0x24c4 <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    24b8:	89 81       	ldd	r24, Y+1	; 0x01
    24ba:	9a 81       	ldd	r25, Y+2	; 0x02
    24bc:	90 93 81 00 	sts	0x0081, r25
    24c0:	80 93 80 00 	sts	0x0080, r24
		}
	}
}
    24c4:	0f 90       	pop	r0
    24c6:	0f 90       	pop	r0
    24c8:	cf 91       	pop	r28
    24ca:	df 91       	pop	r29
    24cc:	08 95       	ret

000024ce <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    24ce:	df 93       	push	r29
    24d0:	cf 93       	push	r28
    24d2:	cd b7       	in	r28, 0x3d	; 61
    24d4:	de b7       	in	r29, 0x3e	; 62
    24d6:	28 97       	sbiw	r28, 0x08	; 8
    24d8:	0f b6       	in	r0, 0x3f	; 63
    24da:	f8 94       	cli
    24dc:	de bf       	out	0x3e, r29	; 62
    24de:	0f be       	out	0x3f, r0	; 63
    24e0:	cd bf       	out	0x3d, r28	; 61
    24e2:	9c 83       	std	Y+4, r25	; 0x04
    24e4:	8b 83       	std	Y+3, r24	; 0x03
    24e6:	7e 83       	std	Y+6, r23	; 0x06
    24e8:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    24ea:	81 e2       	ldi	r24, 0x21	; 33
    24ec:	90 e0       	ldi	r25, 0x00	; 0
    24ee:	0e 94 21 03 	call	0x642	; 0x642 <pvPortMalloc>
    24f2:	9a 83       	std	Y+2, r25	; 0x02
    24f4:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    24f6:	89 81       	ldd	r24, Y+1	; 0x01
    24f8:	9a 81       	ldd	r25, Y+2	; 0x02
    24fa:	00 97       	sbiw	r24, 0x00	; 0
    24fc:	69 f1       	breq	.+90     	; 0x2558 <prvAllocateTCBAndStack+0x8a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    24fe:	8d 81       	ldd	r24, Y+5	; 0x05
    2500:	9e 81       	ldd	r25, Y+6	; 0x06
    2502:	00 97       	sbiw	r24, 0x00	; 0
    2504:	39 f4       	brne	.+14     	; 0x2514 <prvAllocateTCBAndStack+0x46>
    2506:	8b 81       	ldd	r24, Y+3	; 0x03
    2508:	9c 81       	ldd	r25, Y+4	; 0x04
    250a:	0e 94 21 03 	call	0x642	; 0x642 <pvPortMalloc>
    250e:	98 87       	std	Y+8, r25	; 0x08
    2510:	8f 83       	std	Y+7, r24	; 0x07
    2512:	04 c0       	rjmp	.+8      	; 0x251c <prvAllocateTCBAndStack+0x4e>
    2514:	8d 81       	ldd	r24, Y+5	; 0x05
    2516:	9e 81       	ldd	r25, Y+6	; 0x06
    2518:	98 87       	std	Y+8, r25	; 0x08
    251a:	8f 83       	std	Y+7, r24	; 0x07
    251c:	e9 81       	ldd	r30, Y+1	; 0x01
    251e:	fa 81       	ldd	r31, Y+2	; 0x02
    2520:	8f 81       	ldd	r24, Y+7	; 0x07
    2522:	98 85       	ldd	r25, Y+8	; 0x08
    2524:	90 8f       	std	Z+24, r25	; 0x18
    2526:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    2528:	e9 81       	ldd	r30, Y+1	; 0x01
    252a:	fa 81       	ldd	r31, Y+2	; 0x02
    252c:	87 89       	ldd	r24, Z+23	; 0x17
    252e:	90 8d       	ldd	r25, Z+24	; 0x18
    2530:	00 97       	sbiw	r24, 0x00	; 0
    2532:	39 f4       	brne	.+14     	; 0x2542 <prvAllocateTCBAndStack+0x74>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    2534:	89 81       	ldd	r24, Y+1	; 0x01
    2536:	9a 81       	ldd	r25, Y+2	; 0x02
    2538:	0e 94 3c 03 	call	0x678	; 0x678 <vPortFree>
			pxNewTCB = NULL;
    253c:	1a 82       	std	Y+2, r1	; 0x02
    253e:	19 82       	std	Y+1, r1	; 0x01
    2540:	0b c0       	rjmp	.+22     	; 0x2558 <prvAllocateTCBAndStack+0x8a>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    2542:	e9 81       	ldd	r30, Y+1	; 0x01
    2544:	fa 81       	ldd	r31, Y+2	; 0x02
    2546:	87 89       	ldd	r24, Z+23	; 0x17
    2548:	90 8d       	ldd	r25, Z+24	; 0x18
    254a:	2b 81       	ldd	r18, Y+3	; 0x03
    254c:	3c 81       	ldd	r19, Y+4	; 0x04
    254e:	65 ea       	ldi	r22, 0xA5	; 165
    2550:	70 e0       	ldi	r23, 0x00	; 0
    2552:	a9 01       	movw	r20, r18
    2554:	0e 94 7c 17 	call	0x2ef8	; 0x2ef8 <memset>
		}
	}

	return pxNewTCB;
    2558:	89 81       	ldd	r24, Y+1	; 0x01
    255a:	9a 81       	ldd	r25, Y+2	; 0x02
}
    255c:	28 96       	adiw	r28, 0x08	; 8
    255e:	0f b6       	in	r0, 0x3f	; 63
    2560:	f8 94       	cli
    2562:	de bf       	out	0x3e, r29	; 62
    2564:	0f be       	out	0x3f, r0	; 63
    2566:	cd bf       	out	0x3d, r28	; 61
    2568:	cf 91       	pop	r28
    256a:	df 91       	pop	r29
    256c:	08 95       	ret

0000256e <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
    256e:	df 93       	push	r29
    2570:	cf 93       	push	r28
    2572:	00 d0       	rcall	.+0      	; 0x2574 <prvDeleteTCB+0x6>
    2574:	cd b7       	in	r28, 0x3d	; 61
    2576:	de b7       	in	r29, 0x3e	; 62
    2578:	9a 83       	std	Y+2, r25	; 0x02
    257a:	89 83       	std	Y+1, r24	; 0x01
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    257c:	e9 81       	ldd	r30, Y+1	; 0x01
    257e:	fa 81       	ldd	r31, Y+2	; 0x02
    2580:	87 89       	ldd	r24, Z+23	; 0x17
    2582:	90 8d       	ldd	r25, Z+24	; 0x18
    2584:	0e 94 3c 03 	call	0x678	; 0x678 <vPortFree>
		vPortFree( pxTCB );
    2588:	89 81       	ldd	r24, Y+1	; 0x01
    258a:	9a 81       	ldd	r25, Y+2	; 0x02
    258c:	0e 94 3c 03 	call	0x678	; 0x678 <vPortFree>
	}
    2590:	0f 90       	pop	r0
    2592:	0f 90       	pop	r0
    2594:	cf 91       	pop	r28
    2596:	df 91       	pop	r29
    2598:	08 95       	ret

0000259a <DIO_SetPinValue>:
#include "DIO_reg.h"


/* IO Pins */
void DIO_SetPinValue(u8 u8PortIdCopy , u8 u8PinIdCopy, u8 u8PinValCopy)
{
    259a:	df 93       	push	r29
    259c:	cf 93       	push	r28
    259e:	cd b7       	in	r28, 0x3d	; 61
    25a0:	de b7       	in	r29, 0x3e	; 62
    25a2:	27 97       	sbiw	r28, 0x07	; 7
    25a4:	0f b6       	in	r0, 0x3f	; 63
    25a6:	f8 94       	cli
    25a8:	de bf       	out	0x3e, r29	; 62
    25aa:	0f be       	out	0x3f, r0	; 63
    25ac:	cd bf       	out	0x3d, r28	; 61
    25ae:	89 83       	std	Y+1, r24	; 0x01
    25b0:	6a 83       	std	Y+2, r22	; 0x02
    25b2:	4b 83       	std	Y+3, r20	; 0x03
	/* Make sure that the Port ID and Pin ID are in the valid range */
	if ((u8PortIdCopy <= PORTD_DIO) && (u8PinIdCopy <= PIN7))
    25b4:	89 81       	ldd	r24, Y+1	; 0x01
    25b6:	84 30       	cpi	r24, 0x04	; 4
    25b8:	08 f0       	brcs	.+2      	; 0x25bc <DIO_SetPinValue+0x22>
    25ba:	ee c0       	rjmp	.+476    	; 0x2798 <DIO_SetPinValue+0x1fe>
    25bc:	8a 81       	ldd	r24, Y+2	; 0x02
    25be:	88 30       	cpi	r24, 0x08	; 8
    25c0:	08 f0       	brcs	.+2      	; 0x25c4 <DIO_SetPinValue+0x2a>
    25c2:	ea c0       	rjmp	.+468    	; 0x2798 <DIO_SetPinValue+0x1fe>
	{
		if (u8PinValCopy == HIGH)
    25c4:	8b 81       	ldd	r24, Y+3	; 0x03
    25c6:	81 30       	cpi	r24, 0x01	; 1
    25c8:	09 f0       	breq	.+2      	; 0x25cc <DIO_SetPinValue+0x32>
    25ca:	6f c0       	rjmp	.+222    	; 0x26aa <DIO_SetPinValue+0x110>
		{
			/* Check on the Required PORT Number */
			switch (u8PortIdCopy)
    25cc:	89 81       	ldd	r24, Y+1	; 0x01
    25ce:	28 2f       	mov	r18, r24
    25d0:	30 e0       	ldi	r19, 0x00	; 0
    25d2:	3f 83       	std	Y+7, r19	; 0x07
    25d4:	2e 83       	std	Y+6, r18	; 0x06
    25d6:	8e 81       	ldd	r24, Y+6	; 0x06
    25d8:	9f 81       	ldd	r25, Y+7	; 0x07
    25da:	81 30       	cpi	r24, 0x01	; 1
    25dc:	91 05       	cpc	r25, r1
    25de:	49 f1       	breq	.+82     	; 0x2632 <DIO_SetPinValue+0x98>
    25e0:	2e 81       	ldd	r18, Y+6	; 0x06
    25e2:	3f 81       	ldd	r19, Y+7	; 0x07
    25e4:	22 30       	cpi	r18, 0x02	; 2
    25e6:	31 05       	cpc	r19, r1
    25e8:	2c f4       	brge	.+10     	; 0x25f4 <DIO_SetPinValue+0x5a>
    25ea:	8e 81       	ldd	r24, Y+6	; 0x06
    25ec:	9f 81       	ldd	r25, Y+7	; 0x07
    25ee:	00 97       	sbiw	r24, 0x00	; 0
    25f0:	61 f0       	breq	.+24     	; 0x260a <DIO_SetPinValue+0x70>
    25f2:	d2 c0       	rjmp	.+420    	; 0x2798 <DIO_SetPinValue+0x1fe>
    25f4:	2e 81       	ldd	r18, Y+6	; 0x06
    25f6:	3f 81       	ldd	r19, Y+7	; 0x07
    25f8:	22 30       	cpi	r18, 0x02	; 2
    25fa:	31 05       	cpc	r19, r1
    25fc:	71 f1       	breq	.+92     	; 0x265a <DIO_SetPinValue+0xc0>
    25fe:	8e 81       	ldd	r24, Y+6	; 0x06
    2600:	9f 81       	ldd	r25, Y+7	; 0x07
    2602:	83 30       	cpi	r24, 0x03	; 3
    2604:	91 05       	cpc	r25, r1
    2606:	e9 f1       	breq	.+122    	; 0x2682 <DIO_SetPinValue+0xe8>
    2608:	c7 c0       	rjmp	.+398    	; 0x2798 <DIO_SetPinValue+0x1fe>
			{
				case PORTA_DIO: SET_BIT(PORTA_Register,u8PinIdCopy); break;
    260a:	ab e3       	ldi	r26, 0x3B	; 59
    260c:	b0 e0       	ldi	r27, 0x00	; 0
    260e:	eb e3       	ldi	r30, 0x3B	; 59
    2610:	f0 e0       	ldi	r31, 0x00	; 0
    2612:	80 81       	ld	r24, Z
    2614:	48 2f       	mov	r20, r24
    2616:	8a 81       	ldd	r24, Y+2	; 0x02
    2618:	28 2f       	mov	r18, r24
    261a:	30 e0       	ldi	r19, 0x00	; 0
    261c:	81 e0       	ldi	r24, 0x01	; 1
    261e:	90 e0       	ldi	r25, 0x00	; 0
    2620:	02 2e       	mov	r0, r18
    2622:	02 c0       	rjmp	.+4      	; 0x2628 <DIO_SetPinValue+0x8e>
    2624:	88 0f       	add	r24, r24
    2626:	99 1f       	adc	r25, r25
    2628:	0a 94       	dec	r0
    262a:	e2 f7       	brpl	.-8      	; 0x2624 <DIO_SetPinValue+0x8a>
    262c:	84 2b       	or	r24, r20
    262e:	8c 93       	st	X, r24
    2630:	b3 c0       	rjmp	.+358    	; 0x2798 <DIO_SetPinValue+0x1fe>
				case PORTB_DIO: SET_BIT(PORTB_Register,u8PinIdCopy); break;
    2632:	a8 e3       	ldi	r26, 0x38	; 56
    2634:	b0 e0       	ldi	r27, 0x00	; 0
    2636:	e8 e3       	ldi	r30, 0x38	; 56
    2638:	f0 e0       	ldi	r31, 0x00	; 0
    263a:	80 81       	ld	r24, Z
    263c:	48 2f       	mov	r20, r24
    263e:	8a 81       	ldd	r24, Y+2	; 0x02
    2640:	28 2f       	mov	r18, r24
    2642:	30 e0       	ldi	r19, 0x00	; 0
    2644:	81 e0       	ldi	r24, 0x01	; 1
    2646:	90 e0       	ldi	r25, 0x00	; 0
    2648:	02 2e       	mov	r0, r18
    264a:	02 c0       	rjmp	.+4      	; 0x2650 <DIO_SetPinValue+0xb6>
    264c:	88 0f       	add	r24, r24
    264e:	99 1f       	adc	r25, r25
    2650:	0a 94       	dec	r0
    2652:	e2 f7       	brpl	.-8      	; 0x264c <DIO_SetPinValue+0xb2>
    2654:	84 2b       	or	r24, r20
    2656:	8c 93       	st	X, r24
    2658:	9f c0       	rjmp	.+318    	; 0x2798 <DIO_SetPinValue+0x1fe>
				case PORTC_DIO: SET_BIT(PORTC_Register,u8PinIdCopy); break;
    265a:	a5 e3       	ldi	r26, 0x35	; 53
    265c:	b0 e0       	ldi	r27, 0x00	; 0
    265e:	e5 e3       	ldi	r30, 0x35	; 53
    2660:	f0 e0       	ldi	r31, 0x00	; 0
    2662:	80 81       	ld	r24, Z
    2664:	48 2f       	mov	r20, r24
    2666:	8a 81       	ldd	r24, Y+2	; 0x02
    2668:	28 2f       	mov	r18, r24
    266a:	30 e0       	ldi	r19, 0x00	; 0
    266c:	81 e0       	ldi	r24, 0x01	; 1
    266e:	90 e0       	ldi	r25, 0x00	; 0
    2670:	02 2e       	mov	r0, r18
    2672:	02 c0       	rjmp	.+4      	; 0x2678 <DIO_SetPinValue+0xde>
    2674:	88 0f       	add	r24, r24
    2676:	99 1f       	adc	r25, r25
    2678:	0a 94       	dec	r0
    267a:	e2 f7       	brpl	.-8      	; 0x2674 <DIO_SetPinValue+0xda>
    267c:	84 2b       	or	r24, r20
    267e:	8c 93       	st	X, r24
    2680:	8b c0       	rjmp	.+278    	; 0x2798 <DIO_SetPinValue+0x1fe>
				case PORTD_DIO: SET_BIT(PORTD_Register,u8PinIdCopy); break;
    2682:	a2 e3       	ldi	r26, 0x32	; 50
    2684:	b0 e0       	ldi	r27, 0x00	; 0
    2686:	e2 e3       	ldi	r30, 0x32	; 50
    2688:	f0 e0       	ldi	r31, 0x00	; 0
    268a:	80 81       	ld	r24, Z
    268c:	48 2f       	mov	r20, r24
    268e:	8a 81       	ldd	r24, Y+2	; 0x02
    2690:	28 2f       	mov	r18, r24
    2692:	30 e0       	ldi	r19, 0x00	; 0
    2694:	81 e0       	ldi	r24, 0x01	; 1
    2696:	90 e0       	ldi	r25, 0x00	; 0
    2698:	02 2e       	mov	r0, r18
    269a:	02 c0       	rjmp	.+4      	; 0x26a0 <DIO_SetPinValue+0x106>
    269c:	88 0f       	add	r24, r24
    269e:	99 1f       	adc	r25, r25
    26a0:	0a 94       	dec	r0
    26a2:	e2 f7       	brpl	.-8      	; 0x269c <DIO_SetPinValue+0x102>
    26a4:	84 2b       	or	r24, r20
    26a6:	8c 93       	st	X, r24
    26a8:	77 c0       	rjmp	.+238    	; 0x2798 <DIO_SetPinValue+0x1fe>
			}
		
		}
		
		else if (u8PinValCopy == LOW)
    26aa:	8b 81       	ldd	r24, Y+3	; 0x03
    26ac:	88 23       	and	r24, r24
    26ae:	09 f0       	breq	.+2      	; 0x26b2 <DIO_SetPinValue+0x118>
    26b0:	73 c0       	rjmp	.+230    	; 0x2798 <DIO_SetPinValue+0x1fe>
		{
			/* Check on the Required PORT Number */
			switch (u8PortIdCopy)
    26b2:	89 81       	ldd	r24, Y+1	; 0x01
    26b4:	28 2f       	mov	r18, r24
    26b6:	30 e0       	ldi	r19, 0x00	; 0
    26b8:	3d 83       	std	Y+5, r19	; 0x05
    26ba:	2c 83       	std	Y+4, r18	; 0x04
    26bc:	8c 81       	ldd	r24, Y+4	; 0x04
    26be:	9d 81       	ldd	r25, Y+5	; 0x05
    26c0:	81 30       	cpi	r24, 0x01	; 1
    26c2:	91 05       	cpc	r25, r1
    26c4:	59 f1       	breq	.+86     	; 0x271c <DIO_SetPinValue+0x182>
    26c6:	2c 81       	ldd	r18, Y+4	; 0x04
    26c8:	3d 81       	ldd	r19, Y+5	; 0x05
    26ca:	22 30       	cpi	r18, 0x02	; 2
    26cc:	31 05       	cpc	r19, r1
    26ce:	2c f4       	brge	.+10     	; 0x26da <DIO_SetPinValue+0x140>
    26d0:	8c 81       	ldd	r24, Y+4	; 0x04
    26d2:	9d 81       	ldd	r25, Y+5	; 0x05
    26d4:	00 97       	sbiw	r24, 0x00	; 0
    26d6:	69 f0       	breq	.+26     	; 0x26f2 <DIO_SetPinValue+0x158>
    26d8:	5f c0       	rjmp	.+190    	; 0x2798 <DIO_SetPinValue+0x1fe>
    26da:	2c 81       	ldd	r18, Y+4	; 0x04
    26dc:	3d 81       	ldd	r19, Y+5	; 0x05
    26de:	22 30       	cpi	r18, 0x02	; 2
    26e0:	31 05       	cpc	r19, r1
    26e2:	89 f1       	breq	.+98     	; 0x2746 <DIO_SetPinValue+0x1ac>
    26e4:	8c 81       	ldd	r24, Y+4	; 0x04
    26e6:	9d 81       	ldd	r25, Y+5	; 0x05
    26e8:	83 30       	cpi	r24, 0x03	; 3
    26ea:	91 05       	cpc	r25, r1
    26ec:	09 f4       	brne	.+2      	; 0x26f0 <DIO_SetPinValue+0x156>
    26ee:	40 c0       	rjmp	.+128    	; 0x2770 <DIO_SetPinValue+0x1d6>
    26f0:	53 c0       	rjmp	.+166    	; 0x2798 <DIO_SetPinValue+0x1fe>
			{
				case PORTA_DIO: CLR_BIT(PORTA_Register,u8PinIdCopy); break;
    26f2:	ab e3       	ldi	r26, 0x3B	; 59
    26f4:	b0 e0       	ldi	r27, 0x00	; 0
    26f6:	eb e3       	ldi	r30, 0x3B	; 59
    26f8:	f0 e0       	ldi	r31, 0x00	; 0
    26fa:	80 81       	ld	r24, Z
    26fc:	48 2f       	mov	r20, r24
    26fe:	8a 81       	ldd	r24, Y+2	; 0x02
    2700:	28 2f       	mov	r18, r24
    2702:	30 e0       	ldi	r19, 0x00	; 0
    2704:	81 e0       	ldi	r24, 0x01	; 1
    2706:	90 e0       	ldi	r25, 0x00	; 0
    2708:	02 2e       	mov	r0, r18
    270a:	02 c0       	rjmp	.+4      	; 0x2710 <DIO_SetPinValue+0x176>
    270c:	88 0f       	add	r24, r24
    270e:	99 1f       	adc	r25, r25
    2710:	0a 94       	dec	r0
    2712:	e2 f7       	brpl	.-8      	; 0x270c <DIO_SetPinValue+0x172>
    2714:	80 95       	com	r24
    2716:	84 23       	and	r24, r20
    2718:	8c 93       	st	X, r24
    271a:	3e c0       	rjmp	.+124    	; 0x2798 <DIO_SetPinValue+0x1fe>
				case PORTB_DIO: CLR_BIT(PORTB_Register,u8PinIdCopy); break;
    271c:	a8 e3       	ldi	r26, 0x38	; 56
    271e:	b0 e0       	ldi	r27, 0x00	; 0
    2720:	e8 e3       	ldi	r30, 0x38	; 56
    2722:	f0 e0       	ldi	r31, 0x00	; 0
    2724:	80 81       	ld	r24, Z
    2726:	48 2f       	mov	r20, r24
    2728:	8a 81       	ldd	r24, Y+2	; 0x02
    272a:	28 2f       	mov	r18, r24
    272c:	30 e0       	ldi	r19, 0x00	; 0
    272e:	81 e0       	ldi	r24, 0x01	; 1
    2730:	90 e0       	ldi	r25, 0x00	; 0
    2732:	02 2e       	mov	r0, r18
    2734:	02 c0       	rjmp	.+4      	; 0x273a <DIO_SetPinValue+0x1a0>
    2736:	88 0f       	add	r24, r24
    2738:	99 1f       	adc	r25, r25
    273a:	0a 94       	dec	r0
    273c:	e2 f7       	brpl	.-8      	; 0x2736 <DIO_SetPinValue+0x19c>
    273e:	80 95       	com	r24
    2740:	84 23       	and	r24, r20
    2742:	8c 93       	st	X, r24
    2744:	29 c0       	rjmp	.+82     	; 0x2798 <DIO_SetPinValue+0x1fe>
				case PORTC_DIO: CLR_BIT(PORTC_Register,u8PinIdCopy); break;
    2746:	a5 e3       	ldi	r26, 0x35	; 53
    2748:	b0 e0       	ldi	r27, 0x00	; 0
    274a:	e5 e3       	ldi	r30, 0x35	; 53
    274c:	f0 e0       	ldi	r31, 0x00	; 0
    274e:	80 81       	ld	r24, Z
    2750:	48 2f       	mov	r20, r24
    2752:	8a 81       	ldd	r24, Y+2	; 0x02
    2754:	28 2f       	mov	r18, r24
    2756:	30 e0       	ldi	r19, 0x00	; 0
    2758:	81 e0       	ldi	r24, 0x01	; 1
    275a:	90 e0       	ldi	r25, 0x00	; 0
    275c:	02 2e       	mov	r0, r18
    275e:	02 c0       	rjmp	.+4      	; 0x2764 <DIO_SetPinValue+0x1ca>
    2760:	88 0f       	add	r24, r24
    2762:	99 1f       	adc	r25, r25
    2764:	0a 94       	dec	r0
    2766:	e2 f7       	brpl	.-8      	; 0x2760 <DIO_SetPinValue+0x1c6>
    2768:	80 95       	com	r24
    276a:	84 23       	and	r24, r20
    276c:	8c 93       	st	X, r24
    276e:	14 c0       	rjmp	.+40     	; 0x2798 <DIO_SetPinValue+0x1fe>
				case PORTD_DIO: CLR_BIT(PORTD_Register,u8PinIdCopy); break;
    2770:	a2 e3       	ldi	r26, 0x32	; 50
    2772:	b0 e0       	ldi	r27, 0x00	; 0
    2774:	e2 e3       	ldi	r30, 0x32	; 50
    2776:	f0 e0       	ldi	r31, 0x00	; 0
    2778:	80 81       	ld	r24, Z
    277a:	48 2f       	mov	r20, r24
    277c:	8a 81       	ldd	r24, Y+2	; 0x02
    277e:	28 2f       	mov	r18, r24
    2780:	30 e0       	ldi	r19, 0x00	; 0
    2782:	81 e0       	ldi	r24, 0x01	; 1
    2784:	90 e0       	ldi	r25, 0x00	; 0
    2786:	02 2e       	mov	r0, r18
    2788:	02 c0       	rjmp	.+4      	; 0x278e <DIO_SetPinValue+0x1f4>
    278a:	88 0f       	add	r24, r24
    278c:	99 1f       	adc	r25, r25
    278e:	0a 94       	dec	r0
    2790:	e2 f7       	brpl	.-8      	; 0x278a <DIO_SetPinValue+0x1f0>
    2792:	80 95       	com	r24
    2794:	84 23       	and	r24, r20
    2796:	8c 93       	st	X, r24
	
	else
	{
		/* Do nothing, Error in the Pin ID or PORT ID */
	}
}
    2798:	27 96       	adiw	r28, 0x07	; 7
    279a:	0f b6       	in	r0, 0x3f	; 63
    279c:	f8 94       	cli
    279e:	de bf       	out	0x3e, r29	; 62
    27a0:	0f be       	out	0x3f, r0	; 63
    27a2:	cd bf       	out	0x3d, r28	; 61
    27a4:	cf 91       	pop	r28
    27a6:	df 91       	pop	r29
    27a8:	08 95       	ret

000027aa <DIO_GetPinValue>:

u8 DIO_GetPinValue(u8 u8PortIdCopy, u8 u8PinIdCopy)
{
    27aa:	df 93       	push	r29
    27ac:	cf 93       	push	r28
    27ae:	00 d0       	rcall	.+0      	; 0x27b0 <DIO_GetPinValue+0x6>
    27b0:	00 d0       	rcall	.+0      	; 0x27b2 <DIO_GetPinValue+0x8>
    27b2:	0f 92       	push	r0
    27b4:	cd b7       	in	r28, 0x3d	; 61
    27b6:	de b7       	in	r29, 0x3e	; 62
    27b8:	8a 83       	std	Y+2, r24	; 0x02
    27ba:	6b 83       	std	Y+3, r22	; 0x03
	/* Define Local Variable to get the BIT Value */
	u8 u8ResultLocal;
	/* Make sure that the Port ID and Pin ID are in the valid range */
	if ((u8PortIdCopy <= PORTD_DIO) && (u8PinIdCopy <= PIN7))
    27bc:	8a 81       	ldd	r24, Y+2	; 0x02
    27be:	84 30       	cpi	r24, 0x04	; 4
    27c0:	08 f0       	brcs	.+2      	; 0x27c4 <DIO_GetPinValue+0x1a>
    27c2:	6c c0       	rjmp	.+216    	; 0x289c <DIO_GetPinValue+0xf2>
    27c4:	8b 81       	ldd	r24, Y+3	; 0x03
    27c6:	88 30       	cpi	r24, 0x08	; 8
    27c8:	08 f0       	brcs	.+2      	; 0x27cc <DIO_GetPinValue+0x22>
    27ca:	68 c0       	rjmp	.+208    	; 0x289c <DIO_GetPinValue+0xf2>
	{
		/* Check on the Required PORT Number */
		switch (u8PortIdCopy)
    27cc:	8a 81       	ldd	r24, Y+2	; 0x02
    27ce:	28 2f       	mov	r18, r24
    27d0:	30 e0       	ldi	r19, 0x00	; 0
    27d2:	3d 83       	std	Y+5, r19	; 0x05
    27d4:	2c 83       	std	Y+4, r18	; 0x04
    27d6:	4c 81       	ldd	r20, Y+4	; 0x04
    27d8:	5d 81       	ldd	r21, Y+5	; 0x05
    27da:	41 30       	cpi	r20, 0x01	; 1
    27dc:	51 05       	cpc	r21, r1
    27de:	41 f1       	breq	.+80     	; 0x2830 <DIO_GetPinValue+0x86>
    27e0:	8c 81       	ldd	r24, Y+4	; 0x04
    27e2:	9d 81       	ldd	r25, Y+5	; 0x05
    27e4:	82 30       	cpi	r24, 0x02	; 2
    27e6:	91 05       	cpc	r25, r1
    27e8:	34 f4       	brge	.+12     	; 0x27f6 <DIO_GetPinValue+0x4c>
    27ea:	2c 81       	ldd	r18, Y+4	; 0x04
    27ec:	3d 81       	ldd	r19, Y+5	; 0x05
    27ee:	21 15       	cp	r18, r1
    27f0:	31 05       	cpc	r19, r1
    27f2:	61 f0       	breq	.+24     	; 0x280c <DIO_GetPinValue+0x62>
    27f4:	55 c0       	rjmp	.+170    	; 0x28a0 <DIO_GetPinValue+0xf6>
    27f6:	4c 81       	ldd	r20, Y+4	; 0x04
    27f8:	5d 81       	ldd	r21, Y+5	; 0x05
    27fa:	42 30       	cpi	r20, 0x02	; 2
    27fc:	51 05       	cpc	r21, r1
    27fe:	51 f1       	breq	.+84     	; 0x2854 <DIO_GetPinValue+0xaa>
    2800:	8c 81       	ldd	r24, Y+4	; 0x04
    2802:	9d 81       	ldd	r25, Y+5	; 0x05
    2804:	83 30       	cpi	r24, 0x03	; 3
    2806:	91 05       	cpc	r25, r1
    2808:	b9 f1       	breq	.+110    	; 0x2878 <DIO_GetPinValue+0xce>
    280a:	4a c0       	rjmp	.+148    	; 0x28a0 <DIO_GetPinValue+0xf6>
		{
			case PORTA_DIO: u8ResultLocal= GET_BIT(PINA_Register,u8PinIdCopy); break;
    280c:	e9 e3       	ldi	r30, 0x39	; 57
    280e:	f0 e0       	ldi	r31, 0x00	; 0
    2810:	80 81       	ld	r24, Z
    2812:	28 2f       	mov	r18, r24
    2814:	30 e0       	ldi	r19, 0x00	; 0
    2816:	8b 81       	ldd	r24, Y+3	; 0x03
    2818:	88 2f       	mov	r24, r24
    281a:	90 e0       	ldi	r25, 0x00	; 0
    281c:	a9 01       	movw	r20, r18
    281e:	02 c0       	rjmp	.+4      	; 0x2824 <DIO_GetPinValue+0x7a>
    2820:	55 95       	asr	r21
    2822:	47 95       	ror	r20
    2824:	8a 95       	dec	r24
    2826:	e2 f7       	brpl	.-8      	; 0x2820 <DIO_GetPinValue+0x76>
    2828:	ca 01       	movw	r24, r20
    282a:	81 70       	andi	r24, 0x01	; 1
    282c:	89 83       	std	Y+1, r24	; 0x01
    282e:	38 c0       	rjmp	.+112    	; 0x28a0 <DIO_GetPinValue+0xf6>
			case PORTB_DIO: u8ResultLocal= GET_BIT(PINB_Register,u8PinIdCopy); break;
    2830:	e6 e3       	ldi	r30, 0x36	; 54
    2832:	f0 e0       	ldi	r31, 0x00	; 0
    2834:	80 81       	ld	r24, Z
    2836:	28 2f       	mov	r18, r24
    2838:	30 e0       	ldi	r19, 0x00	; 0
    283a:	8b 81       	ldd	r24, Y+3	; 0x03
    283c:	88 2f       	mov	r24, r24
    283e:	90 e0       	ldi	r25, 0x00	; 0
    2840:	a9 01       	movw	r20, r18
    2842:	02 c0       	rjmp	.+4      	; 0x2848 <DIO_GetPinValue+0x9e>
    2844:	55 95       	asr	r21
    2846:	47 95       	ror	r20
    2848:	8a 95       	dec	r24
    284a:	e2 f7       	brpl	.-8      	; 0x2844 <DIO_GetPinValue+0x9a>
    284c:	ca 01       	movw	r24, r20
    284e:	81 70       	andi	r24, 0x01	; 1
    2850:	89 83       	std	Y+1, r24	; 0x01
    2852:	26 c0       	rjmp	.+76     	; 0x28a0 <DIO_GetPinValue+0xf6>
			case PORTC_DIO: u8ResultLocal= GET_BIT(PINC_Register,u8PinIdCopy); break;
    2854:	e3 e3       	ldi	r30, 0x33	; 51
    2856:	f0 e0       	ldi	r31, 0x00	; 0
    2858:	80 81       	ld	r24, Z
    285a:	28 2f       	mov	r18, r24
    285c:	30 e0       	ldi	r19, 0x00	; 0
    285e:	8b 81       	ldd	r24, Y+3	; 0x03
    2860:	88 2f       	mov	r24, r24
    2862:	90 e0       	ldi	r25, 0x00	; 0
    2864:	a9 01       	movw	r20, r18
    2866:	02 c0       	rjmp	.+4      	; 0x286c <DIO_GetPinValue+0xc2>
    2868:	55 95       	asr	r21
    286a:	47 95       	ror	r20
    286c:	8a 95       	dec	r24
    286e:	e2 f7       	brpl	.-8      	; 0x2868 <DIO_GetPinValue+0xbe>
    2870:	ca 01       	movw	r24, r20
    2872:	81 70       	andi	r24, 0x01	; 1
    2874:	89 83       	std	Y+1, r24	; 0x01
    2876:	14 c0       	rjmp	.+40     	; 0x28a0 <DIO_GetPinValue+0xf6>
			case PORTD_DIO: u8ResultLocal= GET_BIT(PIND_Register,u8PinIdCopy); break;
    2878:	e0 e3       	ldi	r30, 0x30	; 48
    287a:	f0 e0       	ldi	r31, 0x00	; 0
    287c:	80 81       	ld	r24, Z
    287e:	28 2f       	mov	r18, r24
    2880:	30 e0       	ldi	r19, 0x00	; 0
    2882:	8b 81       	ldd	r24, Y+3	; 0x03
    2884:	88 2f       	mov	r24, r24
    2886:	90 e0       	ldi	r25, 0x00	; 0
    2888:	a9 01       	movw	r20, r18
    288a:	02 c0       	rjmp	.+4      	; 0x2890 <DIO_GetPinValue+0xe6>
    288c:	55 95       	asr	r21
    288e:	47 95       	ror	r20
    2890:	8a 95       	dec	r24
    2892:	e2 f7       	brpl	.-8      	; 0x288c <DIO_GetPinValue+0xe2>
    2894:	ca 01       	movw	r24, r20
    2896:	81 70       	andi	r24, 0x01	; 1
    2898:	89 83       	std	Y+1, r24	; 0x01
    289a:	02 c0       	rjmp	.+4      	; 0x28a0 <DIO_GetPinValue+0xf6>
	}
	
	else
	{
		/* return 0xff in case of error in the Pin ID or PORT ID */
		u8ResultLocal = 0xFF;
    289c:	8f ef       	ldi	r24, 0xFF	; 255
    289e:	89 83       	std	Y+1, r24	; 0x01
	}
	
	return u8ResultLocal;
    28a0:	89 81       	ldd	r24, Y+1	; 0x01
}
    28a2:	0f 90       	pop	r0
    28a4:	0f 90       	pop	r0
    28a6:	0f 90       	pop	r0
    28a8:	0f 90       	pop	r0
    28aa:	0f 90       	pop	r0
    28ac:	cf 91       	pop	r28
    28ae:	df 91       	pop	r29
    28b0:	08 95       	ret

000028b2 <DIO_SetPinDirection>:

void DIO_SetPinDirection (u8 u8PortIdCopy, u8 u8PinIdCopy, u8 u8PinDirCopy)
{
    28b2:	df 93       	push	r29
    28b4:	cf 93       	push	r28
    28b6:	cd b7       	in	r28, 0x3d	; 61
    28b8:	de b7       	in	r29, 0x3e	; 62
    28ba:	27 97       	sbiw	r28, 0x07	; 7
    28bc:	0f b6       	in	r0, 0x3f	; 63
    28be:	f8 94       	cli
    28c0:	de bf       	out	0x3e, r29	; 62
    28c2:	0f be       	out	0x3f, r0	; 63
    28c4:	cd bf       	out	0x3d, r28	; 61
    28c6:	89 83       	std	Y+1, r24	; 0x01
    28c8:	6a 83       	std	Y+2, r22	; 0x02
    28ca:	4b 83       	std	Y+3, r20	; 0x03
	/* Make sure that the Port ID and Pin ID are in the valid range */
	if ((u8PortIdCopy <= PORTD_DIO) && (u8PinIdCopy <= PIN7))
    28cc:	89 81       	ldd	r24, Y+1	; 0x01
    28ce:	84 30       	cpi	r24, 0x04	; 4
    28d0:	08 f0       	brcs	.+2      	; 0x28d4 <DIO_SetPinDirection+0x22>
    28d2:	ee c0       	rjmp	.+476    	; 0x2ab0 <DIO_SetPinDirection+0x1fe>
    28d4:	8a 81       	ldd	r24, Y+2	; 0x02
    28d6:	88 30       	cpi	r24, 0x08	; 8
    28d8:	08 f0       	brcs	.+2      	; 0x28dc <DIO_SetPinDirection+0x2a>
    28da:	ea c0       	rjmp	.+468    	; 0x2ab0 <DIO_SetPinDirection+0x1fe>
	{
		if ( u8PinDirCopy == OUTPUT )
    28dc:	8b 81       	ldd	r24, Y+3	; 0x03
    28de:	81 30       	cpi	r24, 0x01	; 1
    28e0:	09 f0       	breq	.+2      	; 0x28e4 <DIO_SetPinDirection+0x32>
    28e2:	6f c0       	rjmp	.+222    	; 0x29c2 <DIO_SetPinDirection+0x110>
		{
			/* Check on the Required PORT Number */
			switch (u8PortIdCopy)
    28e4:	89 81       	ldd	r24, Y+1	; 0x01
    28e6:	28 2f       	mov	r18, r24
    28e8:	30 e0       	ldi	r19, 0x00	; 0
    28ea:	3f 83       	std	Y+7, r19	; 0x07
    28ec:	2e 83       	std	Y+6, r18	; 0x06
    28ee:	8e 81       	ldd	r24, Y+6	; 0x06
    28f0:	9f 81       	ldd	r25, Y+7	; 0x07
    28f2:	81 30       	cpi	r24, 0x01	; 1
    28f4:	91 05       	cpc	r25, r1
    28f6:	49 f1       	breq	.+82     	; 0x294a <DIO_SetPinDirection+0x98>
    28f8:	2e 81       	ldd	r18, Y+6	; 0x06
    28fa:	3f 81       	ldd	r19, Y+7	; 0x07
    28fc:	22 30       	cpi	r18, 0x02	; 2
    28fe:	31 05       	cpc	r19, r1
    2900:	2c f4       	brge	.+10     	; 0x290c <DIO_SetPinDirection+0x5a>
    2902:	8e 81       	ldd	r24, Y+6	; 0x06
    2904:	9f 81       	ldd	r25, Y+7	; 0x07
    2906:	00 97       	sbiw	r24, 0x00	; 0
    2908:	61 f0       	breq	.+24     	; 0x2922 <DIO_SetPinDirection+0x70>
    290a:	d2 c0       	rjmp	.+420    	; 0x2ab0 <DIO_SetPinDirection+0x1fe>
    290c:	2e 81       	ldd	r18, Y+6	; 0x06
    290e:	3f 81       	ldd	r19, Y+7	; 0x07
    2910:	22 30       	cpi	r18, 0x02	; 2
    2912:	31 05       	cpc	r19, r1
    2914:	71 f1       	breq	.+92     	; 0x2972 <DIO_SetPinDirection+0xc0>
    2916:	8e 81       	ldd	r24, Y+6	; 0x06
    2918:	9f 81       	ldd	r25, Y+7	; 0x07
    291a:	83 30       	cpi	r24, 0x03	; 3
    291c:	91 05       	cpc	r25, r1
    291e:	e9 f1       	breq	.+122    	; 0x299a <DIO_SetPinDirection+0xe8>
    2920:	c7 c0       	rjmp	.+398    	; 0x2ab0 <DIO_SetPinDirection+0x1fe>
			{
				case PORTA_DIO: SET_BIT(DDRA_Register,u8PinIdCopy); break;
    2922:	aa e3       	ldi	r26, 0x3A	; 58
    2924:	b0 e0       	ldi	r27, 0x00	; 0
    2926:	ea e3       	ldi	r30, 0x3A	; 58
    2928:	f0 e0       	ldi	r31, 0x00	; 0
    292a:	80 81       	ld	r24, Z
    292c:	48 2f       	mov	r20, r24
    292e:	8a 81       	ldd	r24, Y+2	; 0x02
    2930:	28 2f       	mov	r18, r24
    2932:	30 e0       	ldi	r19, 0x00	; 0
    2934:	81 e0       	ldi	r24, 0x01	; 1
    2936:	90 e0       	ldi	r25, 0x00	; 0
    2938:	02 2e       	mov	r0, r18
    293a:	02 c0       	rjmp	.+4      	; 0x2940 <DIO_SetPinDirection+0x8e>
    293c:	88 0f       	add	r24, r24
    293e:	99 1f       	adc	r25, r25
    2940:	0a 94       	dec	r0
    2942:	e2 f7       	brpl	.-8      	; 0x293c <DIO_SetPinDirection+0x8a>
    2944:	84 2b       	or	r24, r20
    2946:	8c 93       	st	X, r24
    2948:	b3 c0       	rjmp	.+358    	; 0x2ab0 <DIO_SetPinDirection+0x1fe>
				case PORTB_DIO: SET_BIT(DDRB_Register,u8PinIdCopy); break;
    294a:	a7 e3       	ldi	r26, 0x37	; 55
    294c:	b0 e0       	ldi	r27, 0x00	; 0
    294e:	e7 e3       	ldi	r30, 0x37	; 55
    2950:	f0 e0       	ldi	r31, 0x00	; 0
    2952:	80 81       	ld	r24, Z
    2954:	48 2f       	mov	r20, r24
    2956:	8a 81       	ldd	r24, Y+2	; 0x02
    2958:	28 2f       	mov	r18, r24
    295a:	30 e0       	ldi	r19, 0x00	; 0
    295c:	81 e0       	ldi	r24, 0x01	; 1
    295e:	90 e0       	ldi	r25, 0x00	; 0
    2960:	02 2e       	mov	r0, r18
    2962:	02 c0       	rjmp	.+4      	; 0x2968 <DIO_SetPinDirection+0xb6>
    2964:	88 0f       	add	r24, r24
    2966:	99 1f       	adc	r25, r25
    2968:	0a 94       	dec	r0
    296a:	e2 f7       	brpl	.-8      	; 0x2964 <DIO_SetPinDirection+0xb2>
    296c:	84 2b       	or	r24, r20
    296e:	8c 93       	st	X, r24
    2970:	9f c0       	rjmp	.+318    	; 0x2ab0 <DIO_SetPinDirection+0x1fe>
				case PORTC_DIO: SET_BIT(DDRC_Register,u8PinIdCopy); break;
    2972:	a4 e3       	ldi	r26, 0x34	; 52
    2974:	b0 e0       	ldi	r27, 0x00	; 0
    2976:	e4 e3       	ldi	r30, 0x34	; 52
    2978:	f0 e0       	ldi	r31, 0x00	; 0
    297a:	80 81       	ld	r24, Z
    297c:	48 2f       	mov	r20, r24
    297e:	8a 81       	ldd	r24, Y+2	; 0x02
    2980:	28 2f       	mov	r18, r24
    2982:	30 e0       	ldi	r19, 0x00	; 0
    2984:	81 e0       	ldi	r24, 0x01	; 1
    2986:	90 e0       	ldi	r25, 0x00	; 0
    2988:	02 2e       	mov	r0, r18
    298a:	02 c0       	rjmp	.+4      	; 0x2990 <DIO_SetPinDirection+0xde>
    298c:	88 0f       	add	r24, r24
    298e:	99 1f       	adc	r25, r25
    2990:	0a 94       	dec	r0
    2992:	e2 f7       	brpl	.-8      	; 0x298c <DIO_SetPinDirection+0xda>
    2994:	84 2b       	or	r24, r20
    2996:	8c 93       	st	X, r24
    2998:	8b c0       	rjmp	.+278    	; 0x2ab0 <DIO_SetPinDirection+0x1fe>
				case PORTD_DIO: SET_BIT(DDRD_Register,u8PinIdCopy); break;
    299a:	a1 e3       	ldi	r26, 0x31	; 49
    299c:	b0 e0       	ldi	r27, 0x00	; 0
    299e:	e1 e3       	ldi	r30, 0x31	; 49
    29a0:	f0 e0       	ldi	r31, 0x00	; 0
    29a2:	80 81       	ld	r24, Z
    29a4:	48 2f       	mov	r20, r24
    29a6:	8a 81       	ldd	r24, Y+2	; 0x02
    29a8:	28 2f       	mov	r18, r24
    29aa:	30 e0       	ldi	r19, 0x00	; 0
    29ac:	81 e0       	ldi	r24, 0x01	; 1
    29ae:	90 e0       	ldi	r25, 0x00	; 0
    29b0:	02 2e       	mov	r0, r18
    29b2:	02 c0       	rjmp	.+4      	; 0x29b8 <DIO_SetPinDirection+0x106>
    29b4:	88 0f       	add	r24, r24
    29b6:	99 1f       	adc	r25, r25
    29b8:	0a 94       	dec	r0
    29ba:	e2 f7       	brpl	.-8      	; 0x29b4 <DIO_SetPinDirection+0x102>
    29bc:	84 2b       	or	r24, r20
    29be:	8c 93       	st	X, r24
    29c0:	77 c0       	rjmp	.+238    	; 0x2ab0 <DIO_SetPinDirection+0x1fe>
			}
		}
		
		else if ( u8PinDirCopy == INPUT )
    29c2:	8b 81       	ldd	r24, Y+3	; 0x03
    29c4:	88 23       	and	r24, r24
    29c6:	09 f0       	breq	.+2      	; 0x29ca <DIO_SetPinDirection+0x118>
    29c8:	73 c0       	rjmp	.+230    	; 0x2ab0 <DIO_SetPinDirection+0x1fe>
		{
			/* Check on the Required PORT Number */
			switch (u8PortIdCopy)
    29ca:	89 81       	ldd	r24, Y+1	; 0x01
    29cc:	28 2f       	mov	r18, r24
    29ce:	30 e0       	ldi	r19, 0x00	; 0
    29d0:	3d 83       	std	Y+5, r19	; 0x05
    29d2:	2c 83       	std	Y+4, r18	; 0x04
    29d4:	8c 81       	ldd	r24, Y+4	; 0x04
    29d6:	9d 81       	ldd	r25, Y+5	; 0x05
    29d8:	81 30       	cpi	r24, 0x01	; 1
    29da:	91 05       	cpc	r25, r1
    29dc:	59 f1       	breq	.+86     	; 0x2a34 <DIO_SetPinDirection+0x182>
    29de:	2c 81       	ldd	r18, Y+4	; 0x04
    29e0:	3d 81       	ldd	r19, Y+5	; 0x05
    29e2:	22 30       	cpi	r18, 0x02	; 2
    29e4:	31 05       	cpc	r19, r1
    29e6:	2c f4       	brge	.+10     	; 0x29f2 <DIO_SetPinDirection+0x140>
    29e8:	8c 81       	ldd	r24, Y+4	; 0x04
    29ea:	9d 81       	ldd	r25, Y+5	; 0x05
    29ec:	00 97       	sbiw	r24, 0x00	; 0
    29ee:	69 f0       	breq	.+26     	; 0x2a0a <DIO_SetPinDirection+0x158>
    29f0:	5f c0       	rjmp	.+190    	; 0x2ab0 <DIO_SetPinDirection+0x1fe>
    29f2:	2c 81       	ldd	r18, Y+4	; 0x04
    29f4:	3d 81       	ldd	r19, Y+5	; 0x05
    29f6:	22 30       	cpi	r18, 0x02	; 2
    29f8:	31 05       	cpc	r19, r1
    29fa:	89 f1       	breq	.+98     	; 0x2a5e <DIO_SetPinDirection+0x1ac>
    29fc:	8c 81       	ldd	r24, Y+4	; 0x04
    29fe:	9d 81       	ldd	r25, Y+5	; 0x05
    2a00:	83 30       	cpi	r24, 0x03	; 3
    2a02:	91 05       	cpc	r25, r1
    2a04:	09 f4       	brne	.+2      	; 0x2a08 <DIO_SetPinDirection+0x156>
    2a06:	40 c0       	rjmp	.+128    	; 0x2a88 <DIO_SetPinDirection+0x1d6>
    2a08:	53 c0       	rjmp	.+166    	; 0x2ab0 <DIO_SetPinDirection+0x1fe>
			{
				case PORTA_DIO: CLR_BIT(DDRA_Register,u8PinIdCopy); break;
    2a0a:	aa e3       	ldi	r26, 0x3A	; 58
    2a0c:	b0 e0       	ldi	r27, 0x00	; 0
    2a0e:	ea e3       	ldi	r30, 0x3A	; 58
    2a10:	f0 e0       	ldi	r31, 0x00	; 0
    2a12:	80 81       	ld	r24, Z
    2a14:	48 2f       	mov	r20, r24
    2a16:	8a 81       	ldd	r24, Y+2	; 0x02
    2a18:	28 2f       	mov	r18, r24
    2a1a:	30 e0       	ldi	r19, 0x00	; 0
    2a1c:	81 e0       	ldi	r24, 0x01	; 1
    2a1e:	90 e0       	ldi	r25, 0x00	; 0
    2a20:	02 2e       	mov	r0, r18
    2a22:	02 c0       	rjmp	.+4      	; 0x2a28 <DIO_SetPinDirection+0x176>
    2a24:	88 0f       	add	r24, r24
    2a26:	99 1f       	adc	r25, r25
    2a28:	0a 94       	dec	r0
    2a2a:	e2 f7       	brpl	.-8      	; 0x2a24 <DIO_SetPinDirection+0x172>
    2a2c:	80 95       	com	r24
    2a2e:	84 23       	and	r24, r20
    2a30:	8c 93       	st	X, r24
    2a32:	3e c0       	rjmp	.+124    	; 0x2ab0 <DIO_SetPinDirection+0x1fe>
				case PORTB_DIO: CLR_BIT(DDRB_Register,u8PinIdCopy); break;
    2a34:	a7 e3       	ldi	r26, 0x37	; 55
    2a36:	b0 e0       	ldi	r27, 0x00	; 0
    2a38:	e7 e3       	ldi	r30, 0x37	; 55
    2a3a:	f0 e0       	ldi	r31, 0x00	; 0
    2a3c:	80 81       	ld	r24, Z
    2a3e:	48 2f       	mov	r20, r24
    2a40:	8a 81       	ldd	r24, Y+2	; 0x02
    2a42:	28 2f       	mov	r18, r24
    2a44:	30 e0       	ldi	r19, 0x00	; 0
    2a46:	81 e0       	ldi	r24, 0x01	; 1
    2a48:	90 e0       	ldi	r25, 0x00	; 0
    2a4a:	02 2e       	mov	r0, r18
    2a4c:	02 c0       	rjmp	.+4      	; 0x2a52 <DIO_SetPinDirection+0x1a0>
    2a4e:	88 0f       	add	r24, r24
    2a50:	99 1f       	adc	r25, r25
    2a52:	0a 94       	dec	r0
    2a54:	e2 f7       	brpl	.-8      	; 0x2a4e <DIO_SetPinDirection+0x19c>
    2a56:	80 95       	com	r24
    2a58:	84 23       	and	r24, r20
    2a5a:	8c 93       	st	X, r24
    2a5c:	29 c0       	rjmp	.+82     	; 0x2ab0 <DIO_SetPinDirection+0x1fe>
				case PORTC_DIO: CLR_BIT(DDRC_Register,u8PinIdCopy); break;
    2a5e:	a4 e3       	ldi	r26, 0x34	; 52
    2a60:	b0 e0       	ldi	r27, 0x00	; 0
    2a62:	e4 e3       	ldi	r30, 0x34	; 52
    2a64:	f0 e0       	ldi	r31, 0x00	; 0
    2a66:	80 81       	ld	r24, Z
    2a68:	48 2f       	mov	r20, r24
    2a6a:	8a 81       	ldd	r24, Y+2	; 0x02
    2a6c:	28 2f       	mov	r18, r24
    2a6e:	30 e0       	ldi	r19, 0x00	; 0
    2a70:	81 e0       	ldi	r24, 0x01	; 1
    2a72:	90 e0       	ldi	r25, 0x00	; 0
    2a74:	02 2e       	mov	r0, r18
    2a76:	02 c0       	rjmp	.+4      	; 0x2a7c <DIO_SetPinDirection+0x1ca>
    2a78:	88 0f       	add	r24, r24
    2a7a:	99 1f       	adc	r25, r25
    2a7c:	0a 94       	dec	r0
    2a7e:	e2 f7       	brpl	.-8      	; 0x2a78 <DIO_SetPinDirection+0x1c6>
    2a80:	80 95       	com	r24
    2a82:	84 23       	and	r24, r20
    2a84:	8c 93       	st	X, r24
    2a86:	14 c0       	rjmp	.+40     	; 0x2ab0 <DIO_SetPinDirection+0x1fe>
				case PORTD_DIO: CLR_BIT(DDRD_Register,u8PinIdCopy); break;
    2a88:	a1 e3       	ldi	r26, 0x31	; 49
    2a8a:	b0 e0       	ldi	r27, 0x00	; 0
    2a8c:	e1 e3       	ldi	r30, 0x31	; 49
    2a8e:	f0 e0       	ldi	r31, 0x00	; 0
    2a90:	80 81       	ld	r24, Z
    2a92:	48 2f       	mov	r20, r24
    2a94:	8a 81       	ldd	r24, Y+2	; 0x02
    2a96:	28 2f       	mov	r18, r24
    2a98:	30 e0       	ldi	r19, 0x00	; 0
    2a9a:	81 e0       	ldi	r24, 0x01	; 1
    2a9c:	90 e0       	ldi	r25, 0x00	; 0
    2a9e:	02 2e       	mov	r0, r18
    2aa0:	02 c0       	rjmp	.+4      	; 0x2aa6 <DIO_SetPinDirection+0x1f4>
    2aa2:	88 0f       	add	r24, r24
    2aa4:	99 1f       	adc	r25, r25
    2aa6:	0a 94       	dec	r0
    2aa8:	e2 f7       	brpl	.-8      	; 0x2aa2 <DIO_SetPinDirection+0x1f0>
    2aaa:	80 95       	com	r24
    2aac:	84 23       	and	r24, r20
    2aae:	8c 93       	st	X, r24
	
	else
	{
		/* Do nothing, Error in the Pin ID or PORT ID */
	}
}
    2ab0:	27 96       	adiw	r28, 0x07	; 7
    2ab2:	0f b6       	in	r0, 0x3f	; 63
    2ab4:	f8 94       	cli
    2ab6:	de bf       	out	0x3e, r29	; 62
    2ab8:	0f be       	out	0x3f, r0	; 63
    2aba:	cd bf       	out	0x3d, r28	; 61
    2abc:	cf 91       	pop	r28
    2abe:	df 91       	pop	r29
    2ac0:	08 95       	ret

00002ac2 <DIO_SetPortDirection>:


/* IO Ports */
void DIO_SetPortDirection (u8 u8PortId, u8 u8PortDir)
{
    2ac2:	df 93       	push	r29
    2ac4:	cf 93       	push	r28
    2ac6:	00 d0       	rcall	.+0      	; 0x2ac8 <DIO_SetPortDirection+0x6>
    2ac8:	00 d0       	rcall	.+0      	; 0x2aca <DIO_SetPortDirection+0x8>
    2aca:	cd b7       	in	r28, 0x3d	; 61
    2acc:	de b7       	in	r29, 0x3e	; 62
    2ace:	89 83       	std	Y+1, r24	; 0x01
    2ad0:	6a 83       	std	Y+2, r22	; 0x02
	/* Check on the Required PORT Number */
	switch (u8PortId)
    2ad2:	89 81       	ldd	r24, Y+1	; 0x01
    2ad4:	28 2f       	mov	r18, r24
    2ad6:	30 e0       	ldi	r19, 0x00	; 0
    2ad8:	3c 83       	std	Y+4, r19	; 0x04
    2ada:	2b 83       	std	Y+3, r18	; 0x03
    2adc:	8b 81       	ldd	r24, Y+3	; 0x03
    2ade:	9c 81       	ldd	r25, Y+4	; 0x04
    2ae0:	81 30       	cpi	r24, 0x01	; 1
    2ae2:	91 05       	cpc	r25, r1
    2ae4:	d1 f0       	breq	.+52     	; 0x2b1a <DIO_SetPortDirection+0x58>
    2ae6:	2b 81       	ldd	r18, Y+3	; 0x03
    2ae8:	3c 81       	ldd	r19, Y+4	; 0x04
    2aea:	22 30       	cpi	r18, 0x02	; 2
    2aec:	31 05       	cpc	r19, r1
    2aee:	2c f4       	brge	.+10     	; 0x2afa <DIO_SetPortDirection+0x38>
    2af0:	8b 81       	ldd	r24, Y+3	; 0x03
    2af2:	9c 81       	ldd	r25, Y+4	; 0x04
    2af4:	00 97       	sbiw	r24, 0x00	; 0
    2af6:	61 f0       	breq	.+24     	; 0x2b10 <DIO_SetPortDirection+0x4e>
    2af8:	1e c0       	rjmp	.+60     	; 0x2b36 <DIO_SetPortDirection+0x74>
    2afa:	2b 81       	ldd	r18, Y+3	; 0x03
    2afc:	3c 81       	ldd	r19, Y+4	; 0x04
    2afe:	22 30       	cpi	r18, 0x02	; 2
    2b00:	31 05       	cpc	r19, r1
    2b02:	81 f0       	breq	.+32     	; 0x2b24 <DIO_SetPortDirection+0x62>
    2b04:	8b 81       	ldd	r24, Y+3	; 0x03
    2b06:	9c 81       	ldd	r25, Y+4	; 0x04
    2b08:	83 30       	cpi	r24, 0x03	; 3
    2b0a:	91 05       	cpc	r25, r1
    2b0c:	81 f0       	breq	.+32     	; 0x2b2e <DIO_SetPortDirection+0x6c>
    2b0e:	13 c0       	rjmp	.+38     	; 0x2b36 <DIO_SetPortDirection+0x74>
	{
			case PORTA_DIO: DDRA_Register = u8PortDir; break;
    2b10:	ea e3       	ldi	r30, 0x3A	; 58
    2b12:	f0 e0       	ldi	r31, 0x00	; 0
    2b14:	8a 81       	ldd	r24, Y+2	; 0x02
    2b16:	80 83       	st	Z, r24
    2b18:	0e c0       	rjmp	.+28     	; 0x2b36 <DIO_SetPortDirection+0x74>
			case PORTB_DIO: DDRB_Register = u8PortDir; break;
    2b1a:	e7 e3       	ldi	r30, 0x37	; 55
    2b1c:	f0 e0       	ldi	r31, 0x00	; 0
    2b1e:	8a 81       	ldd	r24, Y+2	; 0x02
    2b20:	80 83       	st	Z, r24
    2b22:	09 c0       	rjmp	.+18     	; 0x2b36 <DIO_SetPortDirection+0x74>
			case PORTC_DIO: DDRC_Register = u8PortDir; break;
    2b24:	e4 e3       	ldi	r30, 0x34	; 52
    2b26:	f0 e0       	ldi	r31, 0x00	; 0
    2b28:	8a 81       	ldd	r24, Y+2	; 0x02
    2b2a:	80 83       	st	Z, r24
    2b2c:	04 c0       	rjmp	.+8      	; 0x2b36 <DIO_SetPortDirection+0x74>
			case PORTD_DIO: DDRD_Register = u8PortDir; break;
    2b2e:	e1 e3       	ldi	r30, 0x31	; 49
    2b30:	f0 e0       	ldi	r31, 0x00	; 0
    2b32:	8a 81       	ldd	r24, Y+2	; 0x02
    2b34:	80 83       	st	Z, r24
		default: /* Wrong Port ID */       break;
	}
}
    2b36:	0f 90       	pop	r0
    2b38:	0f 90       	pop	r0
    2b3a:	0f 90       	pop	r0
    2b3c:	0f 90       	pop	r0
    2b3e:	cf 91       	pop	r28
    2b40:	df 91       	pop	r29
    2b42:	08 95       	ret

00002b44 <DIO_SetPortValue>:

void DIO_SetPortValue (u8 u8PortId, u8 u8PortVal)
{
    2b44:	df 93       	push	r29
    2b46:	cf 93       	push	r28
    2b48:	00 d0       	rcall	.+0      	; 0x2b4a <DIO_SetPortValue+0x6>
    2b4a:	00 d0       	rcall	.+0      	; 0x2b4c <DIO_SetPortValue+0x8>
    2b4c:	cd b7       	in	r28, 0x3d	; 61
    2b4e:	de b7       	in	r29, 0x3e	; 62
    2b50:	89 83       	std	Y+1, r24	; 0x01
    2b52:	6a 83       	std	Y+2, r22	; 0x02
	/* Check on the Required PORT Number */
	switch (u8PortId)
    2b54:	89 81       	ldd	r24, Y+1	; 0x01
    2b56:	28 2f       	mov	r18, r24
    2b58:	30 e0       	ldi	r19, 0x00	; 0
    2b5a:	3c 83       	std	Y+4, r19	; 0x04
    2b5c:	2b 83       	std	Y+3, r18	; 0x03
    2b5e:	8b 81       	ldd	r24, Y+3	; 0x03
    2b60:	9c 81       	ldd	r25, Y+4	; 0x04
    2b62:	81 30       	cpi	r24, 0x01	; 1
    2b64:	91 05       	cpc	r25, r1
    2b66:	d1 f0       	breq	.+52     	; 0x2b9c <DIO_SetPortValue+0x58>
    2b68:	2b 81       	ldd	r18, Y+3	; 0x03
    2b6a:	3c 81       	ldd	r19, Y+4	; 0x04
    2b6c:	22 30       	cpi	r18, 0x02	; 2
    2b6e:	31 05       	cpc	r19, r1
    2b70:	2c f4       	brge	.+10     	; 0x2b7c <DIO_SetPortValue+0x38>
    2b72:	8b 81       	ldd	r24, Y+3	; 0x03
    2b74:	9c 81       	ldd	r25, Y+4	; 0x04
    2b76:	00 97       	sbiw	r24, 0x00	; 0
    2b78:	61 f0       	breq	.+24     	; 0x2b92 <DIO_SetPortValue+0x4e>
    2b7a:	1e c0       	rjmp	.+60     	; 0x2bb8 <DIO_SetPortValue+0x74>
    2b7c:	2b 81       	ldd	r18, Y+3	; 0x03
    2b7e:	3c 81       	ldd	r19, Y+4	; 0x04
    2b80:	22 30       	cpi	r18, 0x02	; 2
    2b82:	31 05       	cpc	r19, r1
    2b84:	81 f0       	breq	.+32     	; 0x2ba6 <DIO_SetPortValue+0x62>
    2b86:	8b 81       	ldd	r24, Y+3	; 0x03
    2b88:	9c 81       	ldd	r25, Y+4	; 0x04
    2b8a:	83 30       	cpi	r24, 0x03	; 3
    2b8c:	91 05       	cpc	r25, r1
    2b8e:	81 f0       	breq	.+32     	; 0x2bb0 <DIO_SetPortValue+0x6c>
    2b90:	13 c0       	rjmp	.+38     	; 0x2bb8 <DIO_SetPortValue+0x74>
	{
			case PORTA_DIO: PORTA_Register = u8PortVal; break;
    2b92:	eb e3       	ldi	r30, 0x3B	; 59
    2b94:	f0 e0       	ldi	r31, 0x00	; 0
    2b96:	8a 81       	ldd	r24, Y+2	; 0x02
    2b98:	80 83       	st	Z, r24
    2b9a:	0e c0       	rjmp	.+28     	; 0x2bb8 <DIO_SetPortValue+0x74>
			case PORTB_DIO: PORTB_Register = u8PortVal; break;
    2b9c:	e8 e3       	ldi	r30, 0x38	; 56
    2b9e:	f0 e0       	ldi	r31, 0x00	; 0
    2ba0:	8a 81       	ldd	r24, Y+2	; 0x02
    2ba2:	80 83       	st	Z, r24
    2ba4:	09 c0       	rjmp	.+18     	; 0x2bb8 <DIO_SetPortValue+0x74>
			case PORTC_DIO: PORTC_Register = u8PortVal; break;
    2ba6:	e5 e3       	ldi	r30, 0x35	; 53
    2ba8:	f0 e0       	ldi	r31, 0x00	; 0
    2baa:	8a 81       	ldd	r24, Y+2	; 0x02
    2bac:	80 83       	st	Z, r24
    2bae:	04 c0       	rjmp	.+8      	; 0x2bb8 <DIO_SetPortValue+0x74>
			case PORTD_DIO: PORTD_Register = u8PortVal; break;
    2bb0:	e2 e3       	ldi	r30, 0x32	; 50
    2bb2:	f0 e0       	ldi	r31, 0x00	; 0
    2bb4:	8a 81       	ldd	r24, Y+2	; 0x02
    2bb6:	80 83       	st	Z, r24
		default: /* Wrong Port ID */        break;
	}
}
    2bb8:	0f 90       	pop	r0
    2bba:	0f 90       	pop	r0
    2bbc:	0f 90       	pop	r0
    2bbe:	0f 90       	pop	r0
    2bc0:	cf 91       	pop	r28
    2bc2:	df 91       	pop	r29
    2bc4:	08 95       	ret

00002bc6 <main>:
xTaskHandle xTask2_Handle = NULL ;



int main (void)
{
    2bc6:	af 92       	push	r10
    2bc8:	bf 92       	push	r11
    2bca:	cf 92       	push	r12
    2bcc:	df 92       	push	r13
    2bce:	ef 92       	push	r14
    2bd0:	ff 92       	push	r15
    2bd2:	0f 93       	push	r16
    2bd4:	df 93       	push	r29
    2bd6:	cf 93       	push	r28
    2bd8:	cd b7       	in	r28, 0x3d	; 61
    2bda:	de b7       	in	r29, 0x3e	; 62
	vid_SystemInit() ;
    2bdc:	0e 94 2d 16 	call	0x2c5a	; 0x2c5a <vid_SystemInit>



	xTaskCreate( vTask1_Function,"RedLed_ON",configMINIMAL_STACK_SIZE,NULL, 1,&xTask1_Handle );
    2be0:	25 e6       	ldi	r18, 0x65	; 101
    2be2:	30 e0       	ldi	r19, 0x00	; 0
    2be4:	89 e1       	ldi	r24, 0x19	; 25
    2be6:	96 e1       	ldi	r25, 0x16	; 22
    2be8:	e4 e0       	ldi	r30, 0x04	; 4
    2bea:	f1 e0       	ldi	r31, 0x01	; 1
    2bec:	b9 01       	movw	r22, r18
    2bee:	45 e5       	ldi	r20, 0x55	; 85
    2bf0:	50 e0       	ldi	r21, 0x00	; 0
    2bf2:	20 e0       	ldi	r18, 0x00	; 0
    2bf4:	30 e0       	ldi	r19, 0x00	; 0
    2bf6:	01 e0       	ldi	r16, 0x01	; 1
    2bf8:	7f 01       	movw	r14, r30
    2bfa:	cc 24       	eor	r12, r12
    2bfc:	dd 24       	eor	r13, r13
    2bfe:	aa 24       	eor	r10, r10
    2c00:	bb 24       	eor	r11, r11
    2c02:	0e 94 e2 0b 	call	0x17c4	; 0x17c4 <xTaskGenericCreate>
	xTaskCreate( vTask2_Function,"RedLed_OFF",configMINIMAL_STACK_SIZE,NULL, 1,&xTask2_Handle );
    2c06:	2f e6       	ldi	r18, 0x6F	; 111
    2c08:	30 e0       	ldi	r19, 0x00	; 0
    2c0a:	83 e2       	ldi	r24, 0x23	; 35
    2c0c:	96 e1       	ldi	r25, 0x16	; 22
    2c0e:	e6 e0       	ldi	r30, 0x06	; 6
    2c10:	f1 e0       	ldi	r31, 0x01	; 1
    2c12:	b9 01       	movw	r22, r18
    2c14:	45 e5       	ldi	r20, 0x55	; 85
    2c16:	50 e0       	ldi	r21, 0x00	; 0
    2c18:	20 e0       	ldi	r18, 0x00	; 0
    2c1a:	30 e0       	ldi	r19, 0x00	; 0
    2c1c:	01 e0       	ldi	r16, 0x01	; 1
    2c1e:	7f 01       	movw	r14, r30
    2c20:	cc 24       	eor	r12, r12
    2c22:	dd 24       	eor	r13, r13
    2c24:	aa 24       	eor	r10, r10
    2c26:	bb 24       	eor	r11, r11
    2c28:	0e 94 e2 0b 	call	0x17c4	; 0x17c4 <xTaskGenericCreate>

	vTaskStartScheduler() ;
    2c2c:	0e 94 db 0d 	call	0x1bb6	; 0x1bb6 <vTaskStartScheduler>
    2c30:	ff cf       	rjmp	.-2      	; 0x2c30 <main+0x6a>

00002c32 <vTask1_Function>:

}


void vTask1_Function ( void *param )
{
    2c32:	df 93       	push	r29
    2c34:	cf 93       	push	r28
    2c36:	00 d0       	rcall	.+0      	; 0x2c38 <vTask1_Function+0x6>
    2c38:	cd b7       	in	r28, 0x3d	; 61
    2c3a:	de b7       	in	r29, 0x3e	; 62
    2c3c:	9a 83       	std	Y+2, r25	; 0x02
    2c3e:	89 83       	std	Y+1, r24	; 0x01
	while(1)
	{
		RedLed_ON    ();
    2c40:	0e 94 3e 16 	call	0x2c7c	; 0x2c7c <RedLed_ON>
    2c44:	fd cf       	rjmp	.-6      	; 0x2c40 <vTask1_Function+0xe>

00002c46 <vTask2_Function>:
}



void vTask2_Function ( void *param )
{
    2c46:	df 93       	push	r29
    2c48:	cf 93       	push	r28
    2c4a:	00 d0       	rcall	.+0      	; 0x2c4c <vTask2_Function+0x6>
    2c4c:	cd b7       	in	r28, 0x3d	; 61
    2c4e:	de b7       	in	r29, 0x3e	; 62
    2c50:	9a 83       	std	Y+2, r25	; 0x02
    2c52:	89 83       	std	Y+1, r24	; 0x01
	while(1)
	{
		RedLed_OFF   ();
    2c54:	0e 94 4a 16 	call	0x2c94	; 0x2c94 <RedLed_OFF>
    2c58:	fd cf       	rjmp	.-6      	; 0x2c54 <vTask2_Function+0xe>

00002c5a <vid_SystemInit>:
#include "config.h"

/***--------------------------------------------------------------***/

void vid_SystemInit (void)
{
    2c5a:	df 93       	push	r29
    2c5c:	cf 93       	push	r28
    2c5e:	cd b7       	in	r28, 0x3d	; 61
    2c60:	de b7       	in	r29, 0x3e	; 62
	DIO_SetPinDirection (PORTA_DIO, RED_LED, OUTPUT);
    2c62:	80 e0       	ldi	r24, 0x00	; 0
    2c64:	60 e0       	ldi	r22, 0x00	; 0
    2c66:	41 e0       	ldi	r20, 0x01	; 1
    2c68:	0e 94 59 14 	call	0x28b2	; 0x28b2 <DIO_SetPinDirection>
	DIO_SetPinDirection (PORTA_DIO, GREEN_LED, OUTPUT);
    2c6c:	80 e0       	ldi	r24, 0x00	; 0
    2c6e:	61 e0       	ldi	r22, 0x01	; 1
    2c70:	41 e0       	ldi	r20, 0x01	; 1
    2c72:	0e 94 59 14 	call	0x28b2	; 0x28b2 <DIO_SetPinDirection>
}
    2c76:	cf 91       	pop	r28
    2c78:	df 91       	pop	r29
    2c7a:	08 95       	ret

00002c7c <RedLed_ON>:

/***--------------------------------------------------------------***/

void RedLed_ON (void)
{
    2c7c:	df 93       	push	r29
    2c7e:	cf 93       	push	r28
    2c80:	cd b7       	in	r28, 0x3d	; 61
    2c82:	de b7       	in	r29, 0x3e	; 62
	DIO_SetPinValue (PORTA_DIO, RED_LED, HIGH);
    2c84:	80 e0       	ldi	r24, 0x00	; 0
    2c86:	60 e0       	ldi	r22, 0x00	; 0
    2c88:	41 e0       	ldi	r20, 0x01	; 1
    2c8a:	0e 94 cd 12 	call	0x259a	; 0x259a <DIO_SetPinValue>
}
    2c8e:	cf 91       	pop	r28
    2c90:	df 91       	pop	r29
    2c92:	08 95       	ret

00002c94 <RedLed_OFF>:

/***--------------------------------------------------------------***/

void RedLed_OFF (void)
{
    2c94:	df 93       	push	r29
    2c96:	cf 93       	push	r28
    2c98:	cd b7       	in	r28, 0x3d	; 61
    2c9a:	de b7       	in	r29, 0x3e	; 62
	DIO_SetPinValue (PORTA_DIO, RED_LED, LOW);
    2c9c:	80 e0       	ldi	r24, 0x00	; 0
    2c9e:	60 e0       	ldi	r22, 0x00	; 0
    2ca0:	40 e0       	ldi	r20, 0x00	; 0
    2ca2:	0e 94 cd 12 	call	0x259a	; 0x259a <DIO_SetPinValue>
}
    2ca6:	cf 91       	pop	r28
    2ca8:	df 91       	pop	r29
    2caa:	08 95       	ret

00002cac <GreenLed_ON>:


/***--------------------------------------------------------------***/

void GreenLed_ON (void)
{
    2cac:	df 93       	push	r29
    2cae:	cf 93       	push	r28
    2cb0:	cd b7       	in	r28, 0x3d	; 61
    2cb2:	de b7       	in	r29, 0x3e	; 62
	DIO_SetPinValue (PORTA_DIO, GREEN_LED, HIGH);
    2cb4:	80 e0       	ldi	r24, 0x00	; 0
    2cb6:	61 e0       	ldi	r22, 0x01	; 1
    2cb8:	41 e0       	ldi	r20, 0x01	; 1
    2cba:	0e 94 cd 12 	call	0x259a	; 0x259a <DIO_SetPinValue>
}
    2cbe:	cf 91       	pop	r28
    2cc0:	df 91       	pop	r29
    2cc2:	08 95       	ret

00002cc4 <GreenLed_OFF>:

/***--------------------------------------------------------------***/

void GreenLed_OFF (void)
{
    2cc4:	df 93       	push	r29
    2cc6:	cf 93       	push	r28
    2cc8:	cd b7       	in	r28, 0x3d	; 61
    2cca:	de b7       	in	r29, 0x3e	; 62
	DIO_SetPinValue (PORTA_DIO, GREEN_LED, LOW);
    2ccc:	80 e0       	ldi	r24, 0x00	; 0
    2cce:	61 e0       	ldi	r22, 0x01	; 1
    2cd0:	40 e0       	ldi	r20, 0x00	; 0
    2cd2:	0e 94 cd 12 	call	0x259a	; 0x259a <DIO_SetPinValue>
}
    2cd6:	cf 91       	pop	r28
    2cd8:	df 91       	pop	r29
    2cda:	08 95       	ret

00002cdc <malloc>:
    2cdc:	cf 93       	push	r28
    2cde:	df 93       	push	r29
    2ce0:	bc 01       	movw	r22, r24
    2ce2:	82 30       	cpi	r24, 0x02	; 2
    2ce4:	91 05       	cpc	r25, r1
    2ce6:	10 f4       	brcc	.+4      	; 0x2cec <malloc+0x10>
    2ce8:	62 e0       	ldi	r22, 0x02	; 2
    2cea:	70 e0       	ldi	r23, 0x00	; 0
    2cec:	a0 91 0a 01 	lds	r26, 0x010A
    2cf0:	b0 91 0b 01 	lds	r27, 0x010B
    2cf4:	ed 01       	movw	r28, r26
    2cf6:	e0 e0       	ldi	r30, 0x00	; 0
    2cf8:	f0 e0       	ldi	r31, 0x00	; 0
    2cfa:	40 e0       	ldi	r20, 0x00	; 0
    2cfc:	50 e0       	ldi	r21, 0x00	; 0
    2cfe:	21 c0       	rjmp	.+66     	; 0x2d42 <malloc+0x66>
    2d00:	88 81       	ld	r24, Y
    2d02:	99 81       	ldd	r25, Y+1	; 0x01
    2d04:	86 17       	cp	r24, r22
    2d06:	97 07       	cpc	r25, r23
    2d08:	69 f4       	brne	.+26     	; 0x2d24 <malloc+0x48>
    2d0a:	8a 81       	ldd	r24, Y+2	; 0x02
    2d0c:	9b 81       	ldd	r25, Y+3	; 0x03
    2d0e:	30 97       	sbiw	r30, 0x00	; 0
    2d10:	19 f0       	breq	.+6      	; 0x2d18 <malloc+0x3c>
    2d12:	93 83       	std	Z+3, r25	; 0x03
    2d14:	82 83       	std	Z+2, r24	; 0x02
    2d16:	04 c0       	rjmp	.+8      	; 0x2d20 <malloc+0x44>
    2d18:	90 93 0b 01 	sts	0x010B, r25
    2d1c:	80 93 0a 01 	sts	0x010A, r24
    2d20:	fe 01       	movw	r30, r28
    2d22:	34 c0       	rjmp	.+104    	; 0x2d8c <malloc+0xb0>
    2d24:	68 17       	cp	r22, r24
    2d26:	79 07       	cpc	r23, r25
    2d28:	38 f4       	brcc	.+14     	; 0x2d38 <malloc+0x5c>
    2d2a:	41 15       	cp	r20, r1
    2d2c:	51 05       	cpc	r21, r1
    2d2e:	19 f0       	breq	.+6      	; 0x2d36 <malloc+0x5a>
    2d30:	84 17       	cp	r24, r20
    2d32:	95 07       	cpc	r25, r21
    2d34:	08 f4       	brcc	.+2      	; 0x2d38 <malloc+0x5c>
    2d36:	ac 01       	movw	r20, r24
    2d38:	fe 01       	movw	r30, r28
    2d3a:	8a 81       	ldd	r24, Y+2	; 0x02
    2d3c:	9b 81       	ldd	r25, Y+3	; 0x03
    2d3e:	9c 01       	movw	r18, r24
    2d40:	e9 01       	movw	r28, r18
    2d42:	20 97       	sbiw	r28, 0x00	; 0
    2d44:	e9 f6       	brne	.-70     	; 0x2d00 <malloc+0x24>
    2d46:	41 15       	cp	r20, r1
    2d48:	51 05       	cpc	r21, r1
    2d4a:	a9 f1       	breq	.+106    	; 0x2db6 <malloc+0xda>
    2d4c:	ca 01       	movw	r24, r20
    2d4e:	86 1b       	sub	r24, r22
    2d50:	97 0b       	sbc	r25, r23
    2d52:	04 97       	sbiw	r24, 0x04	; 4
    2d54:	08 f4       	brcc	.+2      	; 0x2d58 <malloc+0x7c>
    2d56:	ba 01       	movw	r22, r20
    2d58:	e0 e0       	ldi	r30, 0x00	; 0
    2d5a:	f0 e0       	ldi	r31, 0x00	; 0
    2d5c:	2a c0       	rjmp	.+84     	; 0x2db2 <malloc+0xd6>
    2d5e:	8d 91       	ld	r24, X+
    2d60:	9c 91       	ld	r25, X
    2d62:	11 97       	sbiw	r26, 0x01	; 1
    2d64:	84 17       	cp	r24, r20
    2d66:	95 07       	cpc	r25, r21
    2d68:	f9 f4       	brne	.+62     	; 0x2da8 <malloc+0xcc>
    2d6a:	64 17       	cp	r22, r20
    2d6c:	75 07       	cpc	r23, r21
    2d6e:	81 f4       	brne	.+32     	; 0x2d90 <malloc+0xb4>
    2d70:	12 96       	adiw	r26, 0x02	; 2
    2d72:	8d 91       	ld	r24, X+
    2d74:	9c 91       	ld	r25, X
    2d76:	13 97       	sbiw	r26, 0x03	; 3
    2d78:	30 97       	sbiw	r30, 0x00	; 0
    2d7a:	19 f0       	breq	.+6      	; 0x2d82 <malloc+0xa6>
    2d7c:	93 83       	std	Z+3, r25	; 0x03
    2d7e:	82 83       	std	Z+2, r24	; 0x02
    2d80:	04 c0       	rjmp	.+8      	; 0x2d8a <malloc+0xae>
    2d82:	90 93 0b 01 	sts	0x010B, r25
    2d86:	80 93 0a 01 	sts	0x010A, r24
    2d8a:	fd 01       	movw	r30, r26
    2d8c:	32 96       	adiw	r30, 0x02	; 2
    2d8e:	4f c0       	rjmp	.+158    	; 0x2e2e <malloc+0x152>
    2d90:	ca 01       	movw	r24, r20
    2d92:	86 1b       	sub	r24, r22
    2d94:	97 0b       	sbc	r25, r23
    2d96:	fd 01       	movw	r30, r26
    2d98:	e8 0f       	add	r30, r24
    2d9a:	f9 1f       	adc	r31, r25
    2d9c:	61 93       	st	Z+, r22
    2d9e:	71 93       	st	Z+, r23
    2da0:	02 97       	sbiw	r24, 0x02	; 2
    2da2:	8d 93       	st	X+, r24
    2da4:	9c 93       	st	X, r25
    2da6:	43 c0       	rjmp	.+134    	; 0x2e2e <malloc+0x152>
    2da8:	fd 01       	movw	r30, r26
    2daa:	82 81       	ldd	r24, Z+2	; 0x02
    2dac:	93 81       	ldd	r25, Z+3	; 0x03
    2dae:	9c 01       	movw	r18, r24
    2db0:	d9 01       	movw	r26, r18
    2db2:	10 97       	sbiw	r26, 0x00	; 0
    2db4:	a1 f6       	brne	.-88     	; 0x2d5e <malloc+0x82>
    2db6:	80 91 08 01 	lds	r24, 0x0108
    2dba:	90 91 09 01 	lds	r25, 0x0109
    2dbe:	89 2b       	or	r24, r25
    2dc0:	41 f4       	brne	.+16     	; 0x2dd2 <malloc+0xf6>
    2dc2:	80 91 7c 00 	lds	r24, 0x007C
    2dc6:	90 91 7d 00 	lds	r25, 0x007D
    2dca:	90 93 09 01 	sts	0x0109, r25
    2dce:	80 93 08 01 	sts	0x0108, r24
    2dd2:	40 91 7e 00 	lds	r20, 0x007E
    2dd6:	50 91 7f 00 	lds	r21, 0x007F
    2dda:	41 15       	cp	r20, r1
    2ddc:	51 05       	cpc	r21, r1
    2dde:	41 f4       	brne	.+16     	; 0x2df0 <malloc+0x114>
    2de0:	4d b7       	in	r20, 0x3d	; 61
    2de2:	5e b7       	in	r21, 0x3e	; 62
    2de4:	80 91 7a 00 	lds	r24, 0x007A
    2de8:	90 91 7b 00 	lds	r25, 0x007B
    2dec:	48 1b       	sub	r20, r24
    2dee:	59 0b       	sbc	r21, r25
    2df0:	20 91 08 01 	lds	r18, 0x0108
    2df4:	30 91 09 01 	lds	r19, 0x0109
    2df8:	24 17       	cp	r18, r20
    2dfa:	35 07       	cpc	r19, r21
    2dfc:	b0 f4       	brcc	.+44     	; 0x2e2a <malloc+0x14e>
    2dfe:	ca 01       	movw	r24, r20
    2e00:	82 1b       	sub	r24, r18
    2e02:	93 0b       	sbc	r25, r19
    2e04:	86 17       	cp	r24, r22
    2e06:	97 07       	cpc	r25, r23
    2e08:	80 f0       	brcs	.+32     	; 0x2e2a <malloc+0x14e>
    2e0a:	ab 01       	movw	r20, r22
    2e0c:	4e 5f       	subi	r20, 0xFE	; 254
    2e0e:	5f 4f       	sbci	r21, 0xFF	; 255
    2e10:	84 17       	cp	r24, r20
    2e12:	95 07       	cpc	r25, r21
    2e14:	50 f0       	brcs	.+20     	; 0x2e2a <malloc+0x14e>
    2e16:	42 0f       	add	r20, r18
    2e18:	53 1f       	adc	r21, r19
    2e1a:	50 93 09 01 	sts	0x0109, r21
    2e1e:	40 93 08 01 	sts	0x0108, r20
    2e22:	f9 01       	movw	r30, r18
    2e24:	61 93       	st	Z+, r22
    2e26:	71 93       	st	Z+, r23
    2e28:	02 c0       	rjmp	.+4      	; 0x2e2e <malloc+0x152>
    2e2a:	e0 e0       	ldi	r30, 0x00	; 0
    2e2c:	f0 e0       	ldi	r31, 0x00	; 0
    2e2e:	cf 01       	movw	r24, r30
    2e30:	df 91       	pop	r29
    2e32:	cf 91       	pop	r28
    2e34:	08 95       	ret

00002e36 <free>:
    2e36:	cf 93       	push	r28
    2e38:	df 93       	push	r29
    2e3a:	00 97       	sbiw	r24, 0x00	; 0
    2e3c:	09 f4       	brne	.+2      	; 0x2e40 <free+0xa>
    2e3e:	50 c0       	rjmp	.+160    	; 0x2ee0 <free+0xaa>
    2e40:	ec 01       	movw	r28, r24
    2e42:	22 97       	sbiw	r28, 0x02	; 2
    2e44:	1b 82       	std	Y+3, r1	; 0x03
    2e46:	1a 82       	std	Y+2, r1	; 0x02
    2e48:	a0 91 0a 01 	lds	r26, 0x010A
    2e4c:	b0 91 0b 01 	lds	r27, 0x010B
    2e50:	10 97       	sbiw	r26, 0x00	; 0
    2e52:	09 f1       	breq	.+66     	; 0x2e96 <free+0x60>
    2e54:	40 e0       	ldi	r20, 0x00	; 0
    2e56:	50 e0       	ldi	r21, 0x00	; 0
    2e58:	ac 17       	cp	r26, r28
    2e5a:	bd 07       	cpc	r27, r29
    2e5c:	08 f1       	brcs	.+66     	; 0x2ea0 <free+0x6a>
    2e5e:	bb 83       	std	Y+3, r27	; 0x03
    2e60:	aa 83       	std	Y+2, r26	; 0x02
    2e62:	fe 01       	movw	r30, r28
    2e64:	21 91       	ld	r18, Z+
    2e66:	31 91       	ld	r19, Z+
    2e68:	e2 0f       	add	r30, r18
    2e6a:	f3 1f       	adc	r31, r19
    2e6c:	ae 17       	cp	r26, r30
    2e6e:	bf 07       	cpc	r27, r31
    2e70:	79 f4       	brne	.+30     	; 0x2e90 <free+0x5a>
    2e72:	8d 91       	ld	r24, X+
    2e74:	9c 91       	ld	r25, X
    2e76:	11 97       	sbiw	r26, 0x01	; 1
    2e78:	28 0f       	add	r18, r24
    2e7a:	39 1f       	adc	r19, r25
    2e7c:	2e 5f       	subi	r18, 0xFE	; 254
    2e7e:	3f 4f       	sbci	r19, 0xFF	; 255
    2e80:	39 83       	std	Y+1, r19	; 0x01
    2e82:	28 83       	st	Y, r18
    2e84:	12 96       	adiw	r26, 0x02	; 2
    2e86:	8d 91       	ld	r24, X+
    2e88:	9c 91       	ld	r25, X
    2e8a:	13 97       	sbiw	r26, 0x03	; 3
    2e8c:	9b 83       	std	Y+3, r25	; 0x03
    2e8e:	8a 83       	std	Y+2, r24	; 0x02
    2e90:	41 15       	cp	r20, r1
    2e92:	51 05       	cpc	r21, r1
    2e94:	71 f4       	brne	.+28     	; 0x2eb2 <free+0x7c>
    2e96:	d0 93 0b 01 	sts	0x010B, r29
    2e9a:	c0 93 0a 01 	sts	0x010A, r28
    2e9e:	20 c0       	rjmp	.+64     	; 0x2ee0 <free+0xaa>
    2ea0:	12 96       	adiw	r26, 0x02	; 2
    2ea2:	8d 91       	ld	r24, X+
    2ea4:	9c 91       	ld	r25, X
    2ea6:	13 97       	sbiw	r26, 0x03	; 3
    2ea8:	ad 01       	movw	r20, r26
    2eaa:	00 97       	sbiw	r24, 0x00	; 0
    2eac:	11 f0       	breq	.+4      	; 0x2eb2 <free+0x7c>
    2eae:	dc 01       	movw	r26, r24
    2eb0:	d3 cf       	rjmp	.-90     	; 0x2e58 <free+0x22>
    2eb2:	fa 01       	movw	r30, r20
    2eb4:	d3 83       	std	Z+3, r29	; 0x03
    2eb6:	c2 83       	std	Z+2, r28	; 0x02
    2eb8:	21 91       	ld	r18, Z+
    2eba:	31 91       	ld	r19, Z+
    2ebc:	e2 0f       	add	r30, r18
    2ebe:	f3 1f       	adc	r31, r19
    2ec0:	ce 17       	cp	r28, r30
    2ec2:	df 07       	cpc	r29, r31
    2ec4:	69 f4       	brne	.+26     	; 0x2ee0 <free+0xaa>
    2ec6:	88 81       	ld	r24, Y
    2ec8:	99 81       	ldd	r25, Y+1	; 0x01
    2eca:	28 0f       	add	r18, r24
    2ecc:	39 1f       	adc	r19, r25
    2ece:	2e 5f       	subi	r18, 0xFE	; 254
    2ed0:	3f 4f       	sbci	r19, 0xFF	; 255
    2ed2:	fa 01       	movw	r30, r20
    2ed4:	31 83       	std	Z+1, r19	; 0x01
    2ed6:	20 83       	st	Z, r18
    2ed8:	8a 81       	ldd	r24, Y+2	; 0x02
    2eda:	9b 81       	ldd	r25, Y+3	; 0x03
    2edc:	93 83       	std	Z+3, r25	; 0x03
    2ede:	82 83       	std	Z+2, r24	; 0x02
    2ee0:	df 91       	pop	r29
    2ee2:	cf 91       	pop	r28
    2ee4:	08 95       	ret

00002ee6 <memcpy>:
    2ee6:	fb 01       	movw	r30, r22
    2ee8:	dc 01       	movw	r26, r24
    2eea:	02 c0       	rjmp	.+4      	; 0x2ef0 <memcpy+0xa>
    2eec:	01 90       	ld	r0, Z+
    2eee:	0d 92       	st	X+, r0
    2ef0:	41 50       	subi	r20, 0x01	; 1
    2ef2:	50 40       	sbci	r21, 0x00	; 0
    2ef4:	d8 f7       	brcc	.-10     	; 0x2eec <memcpy+0x6>
    2ef6:	08 95       	ret

00002ef8 <memset>:
    2ef8:	dc 01       	movw	r26, r24
    2efa:	01 c0       	rjmp	.+2      	; 0x2efe <memset+0x6>
    2efc:	6d 93       	st	X+, r22
    2efe:	41 50       	subi	r20, 0x01	; 1
    2f00:	50 40       	sbci	r21, 0x00	; 0
    2f02:	e0 f7       	brcc	.-8      	; 0x2efc <memset+0x4>
    2f04:	08 95       	ret

00002f06 <strncpy>:
    2f06:	fb 01       	movw	r30, r22
    2f08:	dc 01       	movw	r26, r24
    2f0a:	41 50       	subi	r20, 0x01	; 1
    2f0c:	50 40       	sbci	r21, 0x00	; 0
    2f0e:	48 f0       	brcs	.+18     	; 0x2f22 <strncpy+0x1c>
    2f10:	01 90       	ld	r0, Z+
    2f12:	0d 92       	st	X+, r0
    2f14:	00 20       	and	r0, r0
    2f16:	c9 f7       	brne	.-14     	; 0x2f0a <strncpy+0x4>
    2f18:	01 c0       	rjmp	.+2      	; 0x2f1c <strncpy+0x16>
    2f1a:	1d 92       	st	X+, r1
    2f1c:	41 50       	subi	r20, 0x01	; 1
    2f1e:	50 40       	sbci	r21, 0x00	; 0
    2f20:	e0 f7       	brcc	.-8      	; 0x2f1a <strncpy+0x14>
    2f22:	08 95       	ret

00002f24 <_exit>:
    2f24:	f8 94       	cli

00002f26 <__stop_program>:
    2f26:	ff cf       	rjmp	.-2      	; 0x2f26 <__stop_program>
